---
title: Comparateurs de valeurs-EF Core
description: Utilisation de comparateurs de valeur pour contrôler la façon dont EF Core compare les valeurs de propriété
author: ajcvickers
ms.date: 01/16/2021
uid: core/modeling/value-comparers
ms.openlocfilehash: 9318b41479b43b327c76a11cc99b4f7695fa88d3
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023898"
---
# <a name="value-comparers"></a><span data-ttu-id="afe0b-103">Comparateurs de valeurs</span><span class="sxs-lookup"><span data-stu-id="afe0b-103">Value Comparers</span></span>

> [!NOTE]
> <span data-ttu-id="afe0b-104">Cette fonctionnalité a été introduite dans EF Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="afe0b-104">This feature was introduced in EF Core 3.0.</span></span>

> [!TIP]
> <span data-ttu-id="afe0b-105">Vous trouverez le code de ce document sur GitHub en tant qu' [exemple exécutable](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Modeling/ValueConversions/).</span><span class="sxs-lookup"><span data-stu-id="afe0b-105">The code in this document can be found on GitHub as a [runnable sample](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Modeling/ValueConversions/).</span></span>

## <a name="background"></a><span data-ttu-id="afe0b-106">Arrière-plan</span><span class="sxs-lookup"><span data-stu-id="afe0b-106">Background</span></span>

<span data-ttu-id="afe0b-107">Le [suivi des modifications](xref:core/change-tracking/index) signifie que EF Core détermine automatiquement les modifications qui ont été effectuées par l’application sur une instance d’entité chargée, afin que ces modifications puissent être enregistrées dans la base de données lorsque <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="afe0b-107">[Change tracking](xref:core/change-tracking/index) means that EF Core automatically determines what changes were performed by the application on a loaded entity instance, so that those changes can be saved back to the database when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="afe0b-108">EF Core effectue généralement cette opération en prenant un *instantané* de l’instance lorsqu’elle est chargée à partir de la base de données, et en *comparant* cet instantané à l’instance transmise à l’application.</span><span class="sxs-lookup"><span data-stu-id="afe0b-108">EF Core usually performs this by taking a *snapshot* of the instance when it's loaded from the database, and *comparing* that snapshot to the instance handed out to the application.</span></span>

<span data-ttu-id="afe0b-109">EF Core est fourni avec une logique intégrée pour effectuer des captures instantanées et comparer la plupart des types standard utilisés dans les bases de données, de sorte que les utilisateurs n’ont généralement pas à se soucier de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="afe0b-109">EF Core comes with built-in logic for snapshotting and comparing most standard types used in databases, so users don't usually need to worry about this topic.</span></span> <span data-ttu-id="afe0b-110">Toutefois, lorsqu’une propriété est mappée par le biais d’un [convertisseur de valeur](xref:core/modeling/value-conversions), EF Core doit effectuer une comparaison sur les types utilisateur arbitraires, ce qui peut être complexe.</span><span class="sxs-lookup"><span data-stu-id="afe0b-110">However, when a property is mapped through a [value converter](xref:core/modeling/value-conversions), EF Core needs to perform comparison on arbitrary user types, which may be complex.</span></span> <span data-ttu-id="afe0b-111">Par défaut, EF Core utilise la comparaison d’égalité par défaut définie par les types (par exemple, la `Equals` méthode); pour l’instantané, les [types valeur](/dotnet/csharp/language-reference/builtin-types/value-types) sont copiés pour produire l’instantané, tandis que pour les [types référence](/dotnet/csharp/language-reference/keywords/reference-types) , aucune copie n’est effectuée et la même instance est utilisée comme instantané.</span><span class="sxs-lookup"><span data-stu-id="afe0b-111">By default, EF Core uses the default equality comparison defined by types (e.g. the `Equals` method); for snapshotting, [value types](/dotnet/csharp/language-reference/builtin-types/value-types) are copied to produce the snapshot, while for [reference types](/dotnet/csharp/language-reference/keywords/reference-types) no copying occurs, and the same instance is used as the snapshot.</span></span>

<span data-ttu-id="afe0b-112">Dans les cas où le comportement de comparaison intégré n’est pas approprié, les utilisateurs peuvent fournir un *comparateur de valeur*, qui contient la logique de capture instantanée, de comparaison et de calcul d’un code de hachage.</span><span class="sxs-lookup"><span data-stu-id="afe0b-112">In cases where the built-in comparison behavior isn't appropriate, users may provide a *value comparer*, which contains logic for snapshotting, comparing and calculating a hash code.</span></span> <span data-ttu-id="afe0b-113">Par exemple, le code suivant configure la conversion de valeur pour `List<int>` que la propriété soit une valeur convertie en chaîne JSON dans la base de données, et définit également un comparateur de valeur approprié :</span><span class="sxs-lookup"><span data-stu-id="afe0b-113">For example, the following sets up value conversion for `List<int>` property to be value converted to a JSON string in the database, and defines an appropriate value comparer as well:</span></span>

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ConfigureListProperty)]

<span data-ttu-id="afe0b-114">Pour plus d’informations, consultez les [classes mutables](#mutable-classes) ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="afe0b-114">See [mutable classes](#mutable-classes) below for further details.</span></span>

<span data-ttu-id="afe0b-115">Notez que les comparateurs de valeur sont également utilisés pour déterminer si deux valeurs de clé sont identiques lors de la résolution des relations. Cela est expliqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="afe0b-115">Note that value comparers are also used when determining whether two key values are the same when resolving relationships; this is explained below.</span></span>

## <a name="shallow-vs-deep-comparison"></a><span data-ttu-id="afe0b-116">Comparaison superficielle et profonde</span><span class="sxs-lookup"><span data-stu-id="afe0b-116">Shallow vs. deep comparison</span></span>

<span data-ttu-id="afe0b-117">Pour les petits types de valeurs immuables, tels que `int` , la logique par défaut de EF Core fonctionne correctement : la valeur est copiée telle quelle lorsqu’elle est instantanée et comparée à la comparaison d’égalité intégrée du type.</span><span class="sxs-lookup"><span data-stu-id="afe0b-117">For small, immutable value types such as `int`, EF Core's default logic works well: the value is copied as-is when snapshotted, and compared with the type's built-in equality comparison.</span></span> <span data-ttu-id="afe0b-118">Lors de l’implémentation de votre propre comparateur de valeur, il est important de déterminer si la logique de comparaison profonde ou superficielle est appropriée.</span><span class="sxs-lookup"><span data-stu-id="afe0b-118">When implementing your own value comparer, it's important to consider whether deep or shallow comparison (and snapshotting) logic is appropriate.</span></span>

<span data-ttu-id="afe0b-119">Utilisez des tableaux d’octets, qui peuvent être arbitrairement grands.</span><span class="sxs-lookup"><span data-stu-id="afe0b-119">Consider byte arrays, which can be arbitrarily large.</span></span> <span data-ttu-id="afe0b-120">Elles peuvent être comparées :</span><span class="sxs-lookup"><span data-stu-id="afe0b-120">These could be compared:</span></span>

* <span data-ttu-id="afe0b-121">Par référence, de telle sorte qu’une différence est détectée uniquement si un nouveau tableau d’octets est utilisé</span><span class="sxs-lookup"><span data-stu-id="afe0b-121">By reference, such that a difference is only detected if a new byte array is used</span></span>
* <span data-ttu-id="afe0b-122">Par comparaison profonde, de telle sorte que la mutation des octets du tableau soit détectée</span><span class="sxs-lookup"><span data-stu-id="afe0b-122">By deep comparison, such that mutation of the bytes in the array is detected</span></span>

<span data-ttu-id="afe0b-123">Par défaut, EF Core utilise la première de ces approches pour les tableaux d’octets non-clés.</span><span class="sxs-lookup"><span data-stu-id="afe0b-123">By default, EF Core uses the first of these approaches for non-key byte arrays.</span></span> <span data-ttu-id="afe0b-124">Autrement dit, seules les références sont comparées et une modification est détectée uniquement lorsqu’un tableau d’octets existant est remplacé par un nouveau.</span><span class="sxs-lookup"><span data-stu-id="afe0b-124">That is, only references are compared and a change is detected only when an existing byte array is replaced with a new one.</span></span> <span data-ttu-id="afe0b-125">Il s’agit d’une décision pragmatique qui évite de copier des tableaux entiers et de les comparer octet-à-octet lors de l’exécution <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> .</span><span class="sxs-lookup"><span data-stu-id="afe0b-125">This is a pragmatic decision that avoids copying entire arrays and comparing them byte-to-byte when executing <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>.</span></span> <span data-ttu-id="afe0b-126">Cela signifie que le scénario courant de remplacement, par exemple, d’une image par une autre est géré de manière performante.</span><span class="sxs-lookup"><span data-stu-id="afe0b-126">It means that the common scenario of replacing, say, one image with another is handled in a performant way.</span></span>

<span data-ttu-id="afe0b-127">En revanche, l’égalité des références ne fonctionne pas quand les tableaux d’octets sont utilisés pour représenter des clés binaires, car il est très peu probable qu’une propriété FK soit définie sur la _même instance_ qu’une propriété PK à laquelle elle doit être comparée.</span><span class="sxs-lookup"><span data-stu-id="afe0b-127">On the other hand, reference equality would not work when byte arrays are used to represent binary keys, since it's very unlikely that an FK property is set to the _same instance_ as a PK property to which it needs to be compared.</span></span> <span data-ttu-id="afe0b-128">Par conséquent, EF Core utilise des comparaisons approfondies pour les tableaux d’octets agissant comme clés ; Il est peu probable qu’il y ait un gain de performances considérable puisque les clés binaires sont généralement courtes.</span><span class="sxs-lookup"><span data-stu-id="afe0b-128">Therefore, EF Core uses deep comparisons for byte arrays acting as keys; this is unlikely to have a big performance hit since binary keys are usually short.</span></span>

<span data-ttu-id="afe0b-129">Notez que la logique de comparaison et d’instantané choisie doit correspondre les unes aux autres : la comparaison profonde requiert un instantané profond pour fonctionner correctement.</span><span class="sxs-lookup"><span data-stu-id="afe0b-129">Note that the chosen comparison and snapshotting logic must correspond to each other: deep comparison requires deep snapshotting to function correctly.</span></span>

## <a name="simple-immutable-classes"></a><span data-ttu-id="afe0b-130">Classes immuables simples</span><span class="sxs-lookup"><span data-stu-id="afe0b-130">Simple immutable classes</span></span>

<span data-ttu-id="afe0b-131">Prenons l’exemple d’une propriété qui utilise un convertisseur de valeur pour mapper une classe simple et immuable.</span><span class="sxs-lookup"><span data-stu-id="afe0b-131">Consider a property that uses a value converter to map a simple, immutable class.</span></span>

[!code-csharp[SimpleImmutableClass](../../../samples/core/Modeling/ValueConversions/MappingImmutableClassProperty.cs?name=SimpleImmutableClass)]

[!code-csharp[ConfigureImmutableClassProperty](../../../samples/core/Modeling/ValueConversions/MappingImmutableClassProperty.cs?name=ConfigureImmutableClassProperty)]

<span data-ttu-id="afe0b-132">Les propriétés de ce type n’ont pas besoin de comparaisons ou d’instantanés spéciaux, car :</span><span class="sxs-lookup"><span data-stu-id="afe0b-132">Properties of this type do not need special comparisons or snapshots because:</span></span>

* <span data-ttu-id="afe0b-133">L’égalité est substituée afin que les différentes instances soient correctement comparées</span><span class="sxs-lookup"><span data-stu-id="afe0b-133">Equality is overridden so that different instances will compare correctly</span></span>
* <span data-ttu-id="afe0b-134">Le type est immuable, donc il n’y a aucun risque de mutation d’une valeur d’instantané</span><span class="sxs-lookup"><span data-stu-id="afe0b-134">The type is immutable, so there is no chance of mutating a snapshot value</span></span>

<span data-ttu-id="afe0b-135">Ainsi, dans ce cas, le comportement par défaut de EF Core est parfait.</span><span class="sxs-lookup"><span data-stu-id="afe0b-135">So in this case the default behavior of EF Core is fine as it is.</span></span>

## <a name="simple-immutable-structs"></a><span data-ttu-id="afe0b-136">Structs simples immuables</span><span class="sxs-lookup"><span data-stu-id="afe0b-136">Simple immutable structs</span></span>

<span data-ttu-id="afe0b-137">Le mappage des structs simples est également simple et ne nécessite pas de comparateurs spéciaux ou de capture instantanée.</span><span class="sxs-lookup"><span data-stu-id="afe0b-137">The mapping for simple structs is also simple and requires no special comparers or snapshotting.</span></span>

[!code-csharp[SimpleImmutableStruct](../../../samples/core/Modeling/ValueConversions/MappingImmutableStructProperty.cs?name=SimpleImmutableStruct)]

[!code-csharp[ConfigureImmutableStructProperty](../../../samples/core/Modeling/ValueConversions/MappingImmutableStructProperty.cs?name=ConfigureImmutableStructProperty)]

<span data-ttu-id="afe0b-138">EF Core dispose d’une prise en charge intégrée pour générer des comparaisons compilées et membre des propriétés de struct.</span><span class="sxs-lookup"><span data-stu-id="afe0b-138">EF Core has built-in support for generating compiled, memberwise comparisons of struct properties.</span></span> <span data-ttu-id="afe0b-139">Cela signifie que les structs n’ont pas besoin d’être substitués par l’égalité pour EF Core, mais vous pouvez toujours choisir de le faire pour d' [autres raisons](/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type).</span><span class="sxs-lookup"><span data-stu-id="afe0b-139">This means structs don't need to have equality overridden for EF Core, but you may still choose to do this for [other reasons](/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type).</span></span> <span data-ttu-id="afe0b-140">De même, les captures instantanées spéciales ne sont pas nécessaires, car les structs sont immuables et sont toujours copiés membre.</span><span class="sxs-lookup"><span data-stu-id="afe0b-140">Also, special snapshotting is not needed since structs are immutable and are always copied memberwise anyway.</span></span> <span data-ttu-id="afe0b-141">(Cela est également vrai pour les structs mutables, mais les [structs mutables doivent en général être évités](/dotnet/csharp/write-safe-efficient-code).)</span><span class="sxs-lookup"><span data-stu-id="afe0b-141">(This is also true for mutable structs, but [mutable structs should in general be avoided](/dotnet/csharp/write-safe-efficient-code).)</span></span>

## <a name="mutable-classes"></a><span data-ttu-id="afe0b-142">Classes mutables</span><span class="sxs-lookup"><span data-stu-id="afe0b-142">Mutable classes</span></span>

<span data-ttu-id="afe0b-143">Il est recommandé d’utiliser des types immuables (classes ou structs) avec des convertisseurs de valeurs dans la mesure du possible.</span><span class="sxs-lookup"><span data-stu-id="afe0b-143">It is recommended that you use immutable types (classes or structs) with value converters when possible.</span></span> <span data-ttu-id="afe0b-144">Cela est généralement plus efficace et a une sémantique plus propre que l’utilisation d’un type mutable.</span><span class="sxs-lookup"><span data-stu-id="afe0b-144">This is usually more efficient and has cleaner semantics than using a mutable type.</span></span> <span data-ttu-id="afe0b-145">Toutefois, cela étant dit, il est courant d’utiliser des propriétés de types que l’application ne peut pas modifier.</span><span class="sxs-lookup"><span data-stu-id="afe0b-145">However, that being said, it is common to use properties of types that the application cannot change.</span></span> <span data-ttu-id="afe0b-146">Par exemple, le mappage d’une propriété contenant une liste de nombres :</span><span class="sxs-lookup"><span data-stu-id="afe0b-146">For example, mapping a property containing a list of numbers:</span></span>

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ListProperty)]

<span data-ttu-id="afe0b-147">La classe <xref:System.Collections.Generic.List%601> :</span><span class="sxs-lookup"><span data-stu-id="afe0b-147">The <xref:System.Collections.Generic.List%601> class:</span></span>

* <span data-ttu-id="afe0b-148">A une égalité de référence ; deux listes contenant les mêmes valeurs sont traitées comme différentes.</span><span class="sxs-lookup"><span data-stu-id="afe0b-148">Has reference equality; two lists containing the same values are treated as different.</span></span>
* <span data-ttu-id="afe0b-149">Est mutable ; les valeurs de la liste peuvent être ajoutées et supprimées.</span><span class="sxs-lookup"><span data-stu-id="afe0b-149">Is mutable; values in the list can be added and removed.</span></span>

<span data-ttu-id="afe0b-150">Une conversion de valeur typique sur une propriété de liste peut convertir la liste vers et à partir de JSON :</span><span class="sxs-lookup"><span data-stu-id="afe0b-150">A typical value conversion on a list property might convert the list to and from JSON:</span></span>

### <a name="ef-core-50"></a>[<span data-ttu-id="afe0b-151">EF Core 5.0</span><span class="sxs-lookup"><span data-stu-id="afe0b-151">EF Core 5.0</span></span>](#tab/ef5)

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ConfigureListProperty&highlight=7-10)]

### <a name="older-versions"></a>[<span data-ttu-id="afe0b-152">Versions antérieures</span><span class="sxs-lookup"><span data-stu-id="afe0b-152">Older versions</span></span>](#tab/older-versions)

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListPropertyOld.cs?name=ConfigureListProperty&highlight=8-11,17)]

***

<span data-ttu-id="afe0b-153">Le <xref:Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer%601> constructeur accepte trois expressions :</span><span class="sxs-lookup"><span data-stu-id="afe0b-153">The <xref:Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer%601> constructor accepts three expressions:</span></span>

* <span data-ttu-id="afe0b-154">Expression pour vérifier l’égalité</span><span class="sxs-lookup"><span data-stu-id="afe0b-154">An expression for checking equality</span></span>
* <span data-ttu-id="afe0b-155">Expression pour la génération d’un code de hachage</span><span class="sxs-lookup"><span data-stu-id="afe0b-155">An expression for generating a hash code</span></span>
* <span data-ttu-id="afe0b-156">Expression pour effectuer un instantané d’une valeur</span><span class="sxs-lookup"><span data-stu-id="afe0b-156">An expression to snapshot a value</span></span>

<span data-ttu-id="afe0b-157">Dans ce cas, la comparaison est effectuée en vérifiant si les séquences de nombres sont identiques.</span><span class="sxs-lookup"><span data-stu-id="afe0b-157">In this case the comparison is done by checking if the sequences of numbers are the same.</span></span>

<span data-ttu-id="afe0b-158">De même, le code de hachage est généré à partir de cette même séquence.</span><span class="sxs-lookup"><span data-stu-id="afe0b-158">Likewise, the hash code is built from this same sequence.</span></span> <span data-ttu-id="afe0b-159">(Notez qu’il s’agit d’un code de hachage sur des valeurs mutables et peut donc [provoquer des problèmes](https://ericlippert.com/2011/02/28/guidelines-and-rules-for-gethashcode/).</span><span class="sxs-lookup"><span data-stu-id="afe0b-159">(Note that this is a hash code over mutable values and hence can [cause problems](https://ericlippert.com/2011/02/28/guidelines-and-rules-for-gethashcode/).</span></span> <span data-ttu-id="afe0b-160">Plutôt immuable si vous le pouvez.)</span><span class="sxs-lookup"><span data-stu-id="afe0b-160">Be immutable instead if you can.)</span></span>

<span data-ttu-id="afe0b-161">L’instantané est créé en clonant la liste avec `ToList` .</span><span class="sxs-lookup"><span data-stu-id="afe0b-161">The snapshot is created by cloning the list with `ToList`.</span></span> <span data-ttu-id="afe0b-162">Là encore, cela est nécessaire uniquement si les listes vont être mutées.</span><span class="sxs-lookup"><span data-stu-id="afe0b-162">Again, this is only needed if the lists are going to be mutated.</span></span> <span data-ttu-id="afe0b-163">Plutôt immuable si vous le pouvez.</span><span class="sxs-lookup"><span data-stu-id="afe0b-163">Be immutable instead if you can.</span></span>

> [!NOTE]
> <span data-ttu-id="afe0b-164">Les convertisseurs de valeurs et les comparateurs sont construits à l’aide d’expressions plutôt que de délégués simples.</span><span class="sxs-lookup"><span data-stu-id="afe0b-164">Value converters and comparers are constructed using expressions rather than simple delegates.</span></span> <span data-ttu-id="afe0b-165">Cela est dû au fait que EF Core insère ces expressions dans une arborescence d’expressions bien plus complexe qui est ensuite compilée dans un délégué de forme d’entité.</span><span class="sxs-lookup"><span data-stu-id="afe0b-165">This is because EF Core inserts these expressions into a much more complex expression tree that is then compiled into an entity shaper delegate.</span></span> <span data-ttu-id="afe0b-166">Conceptuellement, cela est similaire à l’incorporation du compilateur.</span><span class="sxs-lookup"><span data-stu-id="afe0b-166">Conceptually, this is similar to compiler inlining.</span></span> <span data-ttu-id="afe0b-167">Par exemple, une conversion simple peut simplement être une compilation dans un cast, plutôt qu’un appel à une autre méthode pour effectuer la conversion.</span><span class="sxs-lookup"><span data-stu-id="afe0b-167">For example, a simple conversion may just be a compiled in cast, rather than a call to another method to do the conversion.</span></span>

## <a name="key-comparers"></a><span data-ttu-id="afe0b-168">Comparateurs de clés</span><span class="sxs-lookup"><span data-stu-id="afe0b-168">Key comparers</span></span>

<span data-ttu-id="afe0b-169">La section background explique pourquoi les comparaisons clés peuvent nécessiter une sémantique spéciale.</span><span class="sxs-lookup"><span data-stu-id="afe0b-169">The background section covers why key comparisons may require special semantics.</span></span> <span data-ttu-id="afe0b-170">Veillez à créer un comparateur approprié pour les clés lors de leur définition sur une propriété de clé primaire, principale ou étrangère.</span><span class="sxs-lookup"><span data-stu-id="afe0b-170">Make sure to create a comparer that is appropriate for keys when setting it on a primary, principal, or foreign key property.</span></span>

<span data-ttu-id="afe0b-171">Utilisez <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A> dans les rares cas où une sémantique différente est requise sur la même propriété.</span><span class="sxs-lookup"><span data-stu-id="afe0b-171">Use <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A> in the rare cases where different semantics is required on the same property.</span></span>

> [!NOTE]
> <span data-ttu-id="afe0b-172"><xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetStructuralValueComparer%2A> a été obsolète dans EF Core 5,0.</span><span class="sxs-lookup"><span data-stu-id="afe0b-172"><xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetStructuralValueComparer%2A> has been obsoleted in EF Core 5.0.</span></span> <span data-ttu-id="afe0b-173">Utilisez <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="afe0b-173">Use <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A> instead.</span></span>

## <a name="overriding-the-default-comparer"></a><span data-ttu-id="afe0b-174">Substitution du comparateur par défaut</span><span class="sxs-lookup"><span data-stu-id="afe0b-174">Overriding the default comparer</span></span>

<span data-ttu-id="afe0b-175">Parfois, la comparaison par défaut utilisée par EF Core peut ne pas convenir.</span><span class="sxs-lookup"><span data-stu-id="afe0b-175">Sometimes the default comparison used by EF Core may not be appropriate.</span></span> <span data-ttu-id="afe0b-176">Par exemple, la mutation des tableaux d’octets n’est pas, par défaut, détectée dans EF Core.</span><span class="sxs-lookup"><span data-stu-id="afe0b-176">For example, mutation of byte arrays is not, by default, detected in EF Core.</span></span> <span data-ttu-id="afe0b-177">Vous pouvez la remplacer en définissant un autre comparateur sur la propriété :</span><span class="sxs-lookup"><span data-stu-id="afe0b-177">This can be overridden by setting a different comparer on the property:</span></span>

[!code-csharp[OverrideComparer](../../../samples/core/Modeling/ValueConversions/OverridingByteArrayComparisons.cs?name=OverrideComparer)]

<span data-ttu-id="afe0b-178">EF Core comparera maintenant les séquences d’octets et détectera donc les mutations de tableau d’octets.</span><span class="sxs-lookup"><span data-stu-id="afe0b-178">EF Core will now compare byte sequences and will therefore detect byte array mutations.</span></span>
