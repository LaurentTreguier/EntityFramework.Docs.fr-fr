---
title: Interrogation efficace-EF Core
description: Guide des performances pour l’interrogation efficace à l’aide de Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-querying
ms.openlocfilehash: e14837b779f2fbe8d5bf10206c6a336a952fc35b
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023872"
---
# <a name="efficient-querying"></a><span data-ttu-id="e6958-103">Interrogation efficace</span><span class="sxs-lookup"><span data-stu-id="e6958-103">Efficient Querying</span></span>

<span data-ttu-id="e6958-104">L’interrogation efficace est un vaste sujet qui couvre des sujets aussi larges que des index, des stratégies de chargement d’entités associées et bien d’autres.</span><span class="sxs-lookup"><span data-stu-id="e6958-104">Querying efficiently is a vast subject, that covers subjects as wide-ranging as indexes, related entity loading strategies, and many others.</span></span> <span data-ttu-id="e6958-105">Cette section détaille certains thèmes courants pour accélérer l’exécution de vos requêtes et les pièges que les utilisateurs rencontrent généralement.</span><span class="sxs-lookup"><span data-stu-id="e6958-105">This section details some common themes for making your queries faster, and pitfalls users typically encounter.</span></span>

## <a name="use-indexes-properly"></a><span data-ttu-id="e6958-106">Utiliser correctement les index</span><span class="sxs-lookup"><span data-stu-id="e6958-106">Use indexes properly</span></span>

<span data-ttu-id="e6958-107">Le principal facteur déterminant si une requête s’exécute rapidement ou non est qu’elle utilise correctement les index quand cela est approprié : les bases de données sont généralement utilisées pour stocker de grandes quantités de données, et les requêtes qui traversent des tables entières sont généralement des sources de problèmes de performances graves.</span><span class="sxs-lookup"><span data-stu-id="e6958-107">The main deciding factor in whether a query runs fast or not is whether it will properly utilize indexes where appropriate: databases are typically used to hold large amounts of data, and queries which traverse entire tables are typically sources of serious performance issues.</span></span> <span data-ttu-id="e6958-108">Les problèmes d’indexation ne sont pas faciles à repérer, car il n’est pas immédiatement évident qu’une requête donnée utilise ou non un index.</span><span class="sxs-lookup"><span data-stu-id="e6958-108">Indexing issues aren't easy to spot, because it isn't immediately obvious whether a given query will use an index or not.</span></span> <span data-ttu-id="e6958-109">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="e6958-109">For example:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Indexes)]

<span data-ttu-id="e6958-110">Une bonne façon de détecter les problèmes d’indexation consiste à identifier d’abord une requête lente, puis à examiner son plan de requête via l’outil favori de votre base de données. Pour plus d’informations sur la façon de procéder, consultez la page [diagnostic des performances](xref:core/performance/performance-diagnosis) .</span><span class="sxs-lookup"><span data-stu-id="e6958-110">A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via your database's favorite tool; see the [performance diagnosis](xref:core/performance/performance-diagnosis) page for more information on how to do that.</span></span> <span data-ttu-id="e6958-111">Le plan de requête indique si la requête parcourt la table entière ou utilise un index.</span><span class="sxs-lookup"><span data-stu-id="e6958-111">The query plan displays whether the query traverses the entire table, or uses an index.</span></span>

<span data-ttu-id="e6958-112">En règle générale, il n’existe pas de connaissance d’EF spéciale pour utiliser des index ou diagnostiquer des problèmes de performances associés. la connaissance générale des bases de données liées aux index s’applique aux applications EF en ce qui concerne les applications qui n’utilisent pas EF.</span><span class="sxs-lookup"><span data-stu-id="e6958-112">As a general rule, there isn't any special EF knowledge to using indexes or diagnosing performance issues related to them; general database knowledge related to indexes is just as relevant to EF applications as to applications not using EF.</span></span> <span data-ttu-id="e6958-113">La liste suivante répertorie certaines recommandations générales à prendre en compte lors de l’utilisation d’index :</span><span class="sxs-lookup"><span data-stu-id="e6958-113">The following lists some general guidelines to keep in mind when using indexes:</span></span>

* <span data-ttu-id="e6958-114">Alors que les index accélèrent les requêtes, ils ralentissent également les mises à jour, car ils doivent être tenus à jour.</span><span class="sxs-lookup"><span data-stu-id="e6958-114">While indexes speed up queries, they also slow down updates since they need to be kept up-to-date.</span></span> <span data-ttu-id="e6958-115">Évitez de définir des index qui ne sont pas nécessaires et envisagez d’utiliser des [filtres d’index](xref:core/modeling/indexes#index-filter) pour limiter l’index à un sous-ensemble de lignes, réduisant ainsi cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="e6958-115">Avoid defining indexes which aren't needed, and consider using [index filters](xref:core/modeling/indexes#index-filter) to limit the index to a subset of the rows, thereby reducing this overhead.</span></span>
* <span data-ttu-id="e6958-116">Les index composites peuvent accélérer les requêtes qui filtrent sur plusieurs colonnes, mais ils peuvent également accélérer les requêtes qui ne filtrent pas sur toutes les colonnes de l’index, en fonction de l’ordre.</span><span class="sxs-lookup"><span data-stu-id="e6958-116">Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don't filter on all the index's columns - depending on ordering.</span></span> <span data-ttu-id="e6958-117">Par exemple, un index sur les colonnes A et B accélère les requêtes en filtrant par A et B, ainsi que les requêtes de filtrage uniquement par un, mais il n’accélère pas le filtrage des requêtes sur uniquement par B.</span><span class="sxs-lookup"><span data-stu-id="e6958-117">For example, an index on columns A and B speed up queries filtering by A and B, as well as queries filtering only by A, but it does not speed up queries filtering over only by B.</span></span>
* <span data-ttu-id="e6958-118">Si une requête filtre par une expression sur une colonne (par exemple `price / 2` ,), un index simple ne peut pas être utilisé.</span><span class="sxs-lookup"><span data-stu-id="e6958-118">If a query filters by an expression over a column (e.g. `price / 2`), a simple index cannot be used.</span></span> <span data-ttu-id="e6958-119">Toutefois, vous pouvez définir une [colonne persistante stockée](xref:core/modeling/generated-properties#computed-columns) pour votre expression et créer un index sur cette colonne.</span><span class="sxs-lookup"><span data-stu-id="e6958-119">However, you can define a [stored persisted column](xref:core/modeling/generated-properties#computed-columns) for your expression, and create an index over that.</span></span> <span data-ttu-id="e6958-120">Certaines bases de données prennent également en charge les index d’expressions, qui peuvent être utilisés directement pour accélérer le filtrage des requêtes par toute expression.</span><span class="sxs-lookup"><span data-stu-id="e6958-120">Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression.</span></span>
* <span data-ttu-id="e6958-121">Les différentes bases de données permettent de configurer des index de différentes manières, et dans de nombreux cas EF Core fournisseurs les exposent via l’API Fluent.</span><span class="sxs-lookup"><span data-stu-id="e6958-121">Different databases allow indexes to be configured in various ways, and in many cases EF Core providers expose these via the Fluent API.</span></span> <span data-ttu-id="e6958-122">Par exemple, le fournisseur de SQL Server vous permet de configurer si un index est [en cluster](xref:core/providers/sql-server/indexes#clustering)ou de définir son [facteur de remplissage](xref:core/providers/sql-server/indexes#fill-factor).</span><span class="sxs-lookup"><span data-stu-id="e6958-122">For example, the SQL Server provider allows you to configure whether an index is [clustered](xref:core/providers/sql-server/indexes#clustering), or set its [fill factor](xref:core/providers/sql-server/indexes#fill-factor).</span></span> <span data-ttu-id="e6958-123">Pour plus d’informations, consultez la documentation de votre fournisseur.</span><span class="sxs-lookup"><span data-stu-id="e6958-123">Consult your provider's documentation for more information.</span></span>

## <a name="project-only-properties-you-need"></a><span data-ttu-id="e6958-124">Propriétés du projet uniquement dont vous avez besoin</span><span class="sxs-lookup"><span data-stu-id="e6958-124">Project only properties you need</span></span>

<span data-ttu-id="e6958-125">EF Core facilite grandement l’interrogation des instances d’entité, puis l’utilisation de ces instances dans le code.</span><span class="sxs-lookup"><span data-stu-id="e6958-125">EF Core makes it very easy to query out entity instances, and then use those instances in code.</span></span> <span data-ttu-id="e6958-126">Toutefois, l’interrogation des instances d’entité peut souvent extraire plus de données que nécessaire de votre base de données.</span><span class="sxs-lookup"><span data-stu-id="e6958-126">However, querying entity instances can frequently pull back more data than necessary from your database.</span></span> <span data-ttu-id="e6958-127">Tenez compte des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="e6958-127">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectEntities)]

<span data-ttu-id="e6958-128">Bien que ce code ait uniquement besoin de la propriété de chaque blog `Url` , la totalité de l’entité de blog est extraite et les colonnes inutiles sont transférées à partir de la base de données :</span><span class="sxs-lookup"><span data-stu-id="e6958-128">Although this code only actually needs each Blog's `Url` property, the entire Blog entity is fetched, and unneeded columns are transferred from the database:</span></span>

```sql
SELECT [b].[BlogId], [b].[CreationDate], [b].[Name], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="e6958-129">Vous pouvez l’optimiser en utilisant `Select` pour indiquer à EF les colonnes à projeter :</span><span class="sxs-lookup"><span data-stu-id="e6958-129">This can be optimized by using `Select` to tell EF which columns to project out:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectSingleProperty)]

<span data-ttu-id="e6958-130">Le SQL obtenu extrait uniquement les colonnes nécessaires :</span><span class="sxs-lookup"><span data-stu-id="e6958-130">The resulting SQL pulls back only the needed columns:</span></span>

```csharp
SELECT [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="e6958-131">Si vous devez projeter plusieurs colonnes, projetez dans un type anonyme C# avec les propriétés de votre choix.</span><span class="sxs-lookup"><span data-stu-id="e6958-131">If you need to project out more than one column, project out to a C# anonymous type with the properties you want.</span></span>

<span data-ttu-id="e6958-132">Notez que cette technique est très utile pour les requêtes en lecture seule, mais les choses sont plus compliquées si vous devez *mettre à jour* les blogs extraits, puisque le suivi des modifications d’EF ne fonctionne qu’avec des instances d’entité.</span><span class="sxs-lookup"><span data-stu-id="e6958-132">Note that this technique is very useful for read-only queries, but things get more complicated if you need to *update* the fetched blogs, since EF's change tracking only works with entity instances.</span></span> <span data-ttu-id="e6958-133">Il est possible d’effectuer des mises à jour sans avoir à charger des entités entières en attachant une instance de blog modifiée et en indiquant à EF les propriétés qui ont changé, mais il s’agit d’une technique plus avancée qui peut ne pas en être intéressante.</span><span class="sxs-lookup"><span data-stu-id="e6958-133">It's possible to perform updates without loading entire entities by attaching a modified Blog instance and telling EF which properties have changed, but that is a more advanced technique that may not be worth it.</span></span>

## <a name="limit-the-resultset-size"></a><span data-ttu-id="e6958-134">Limiter la taille du jeu de résultats</span><span class="sxs-lookup"><span data-stu-id="e6958-134">Limit the resultset size</span></span>

<span data-ttu-id="e6958-135">Par défaut, une requête retourne toutes les lignes qui correspondent à ses filtres :</span><span class="sxs-lookup"><span data-stu-id="e6958-135">By default, a query returns all rows that matches its filters:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NoLimit)]

<span data-ttu-id="e6958-136">Étant donné que le nombre de lignes retournées dépend de données réelles dans votre base de données, il est impossible de connaître la quantité de données qui sera chargée à partir de la base de données, la quantité de mémoire qui sera prise en charge par les résultats et la quantité de charge supplémentaire générée lors du traitement de ces résultats (par exemple, en les envoyant à un navigateur d’utilisateur sur le réseau</span><span class="sxs-lookup"><span data-stu-id="e6958-136">Since the number of rows returned depends on actual data in your database, it's impossible to know how much data will be loaded from the database, how much memory will be taken up by the results, and how much additional load will be generated when processing these results (e.g. by sending them to a user browser over the network).</span></span> <span data-ttu-id="e6958-137">De manière cruciale, les bases de données de test contiennent souvent peu de données, de sorte que tout fonctionne bien pendant les tests, mais que des problèmes de performances apparaissent soudainement lorsque l’exécution de la requête commence sur des données réelles et que de nombreuses lignes sont retournées.</span><span class="sxs-lookup"><span data-stu-id="e6958-137">Crucially, test databases frequently contain little data, so that everything works well while testing, but performance problems suddenly appear when the query starts running on real-world data and many rows are returned.</span></span>

<span data-ttu-id="e6958-138">Par conséquent, il est généralement intéressant de penser à limiter le nombre de résultats :</span><span class="sxs-lookup"><span data-stu-id="e6958-138">As a result, it's usually worth giving thought to limiting the number of results:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Limit25)]

<span data-ttu-id="e6958-139">Au minimum, votre interface utilisateur peut afficher un message indiquant que des lignes supplémentaires peuvent exister dans la base de données (et autoriser leur récupération d’une autre manière).</span><span class="sxs-lookup"><span data-stu-id="e6958-139">At a minimum, your UI could show a message indicating that more rows may exist in the database (and allow retrieving them in some other manner).</span></span> <span data-ttu-id="e6958-140">Une solution complète implémente la *pagination*, où votre interface utilisateur n’affiche qu’un certain nombre de lignes à la fois, et permet aux utilisateurs d’avancer jusqu’à la page suivante, si nécessaire. Cela combine généralement les <xref:System.Linq.Enumerable.Take%2A> <xref:System.Linq.Enumerable.Skip%2A> opérateurs et pour sélectionner chaque fois une plage spécifique dans le jeu de résultats.</span><span class="sxs-lookup"><span data-stu-id="e6958-140">A full-blown solution would implement *paging*, where your UI only shows a certain number of rows at a time, and allow users to advance to the next page as needed; this typically combines the <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> operators to select a specific range in the resultset each time.</span></span>

## <a name="avoid-cartesian-explosion-when-loading-related-entities"></a><span data-ttu-id="e6958-141">Éviter l’explosion cartésiene lors du chargement des entités associées</span><span class="sxs-lookup"><span data-stu-id="e6958-141">Avoid cartesian explosion when loading related entities</span></span>

<span data-ttu-id="e6958-142">Dans les bases de données relationnelles, toutes les entités associées sont chargées en introduisant des JOINTUREs dans une requête unique.</span><span class="sxs-lookup"><span data-stu-id="e6958-142">In relational databases, all related entities are loaded by introducing JOINs in single query.</span></span>

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

<span data-ttu-id="e6958-143">Si un blog classique contient plusieurs publications connexes, les lignes de ces publications dupliqueront les informations du blog.</span><span class="sxs-lookup"><span data-stu-id="e6958-143">If a typical blog has multiple related posts, rows for these posts will duplicate the blog's information.</span></span> <span data-ttu-id="e6958-144">Cette duplication porte sur le problème de « explosion cartésien ».</span><span class="sxs-lookup"><span data-stu-id="e6958-144">This duplication leads to the so-called "cartesian explosion" problem.</span></span> <span data-ttu-id="e6958-145">À mesure que des relations un-à-plusieurs sont chargées, la quantité de données dupliquées peut croître et nuire aux performances de votre application.</span><span class="sxs-lookup"><span data-stu-id="e6958-145">As more one-to-many relationships are loaded, the amount of duplicated data may grow and adversely affect the performance of your application.</span></span>

<span data-ttu-id="e6958-146">EF permet d’éviter cet effet via l’utilisation de « requêtes fractionnées », qui chargent les entités associées par le biais de requêtes distinctes.</span><span class="sxs-lookup"><span data-stu-id="e6958-146">EF allows avoiding this effect via the use of "split queries", which load the related entities via separate queries.</span></span> <span data-ttu-id="e6958-147">Pour plus d’informations, consultez [la documentation sur les requêtes Split et Single](xref:core/querying/single-split-queries).</span><span class="sxs-lookup"><span data-stu-id="e6958-147">For more information, read [the documentation on split and single queries](xref:core/querying/single-split-queries).</span></span>

> [!NOTE]
> <span data-ttu-id="e6958-148">L’implémentation actuelle des [requêtes fractionnées](xref:core/querying/single-split-queries) exécute un aller-retour pour chaque requête.</span><span class="sxs-lookup"><span data-stu-id="e6958-148">The current implementation of [split queries](xref:core/querying/single-split-queries) executes a roundtrip for each query.</span></span> <span data-ttu-id="e6958-149">Nous prévoyons d’améliorer cette amélioration à l’avenir et d’exécuter toutes les requêtes en un seul aller-retour.</span><span class="sxs-lookup"><span data-stu-id="e6958-149">We plan to improve this in the future, and execute all queries in a single roundtrip.</span></span>

## <a name="load-related-entities-eagerly-when-possible"></a><span data-ttu-id="e6958-150">Charger les entités associées de façon dynamique lorsque cela est possible</span><span class="sxs-lookup"><span data-stu-id="e6958-150">Load related entities eagerly when possible</span></span>

<span data-ttu-id="e6958-151">Avant de poursuivre cette section, il est recommandé de lire [la page dédiée sur les entités associées](xref:core/querying/related-data) .</span><span class="sxs-lookup"><span data-stu-id="e6958-151">It's recommended to read [the dedicated page on related entities](xref:core/querying/related-data) before continuing with this section.</span></span>

<span data-ttu-id="e6958-152">En ce qui concerne les entités associées, nous savons généralement à l’avance ce que nous devons charger : un exemple classique est le chargement d’un certain ensemble de blogs, ainsi que l’ensemble de leurs publications.</span><span class="sxs-lookup"><span data-stu-id="e6958-152">When dealing with related entities, we usually know in advance what we need to load: a typical example would be loading a certain set of Blogs, along with all their Posts.</span></span> <span data-ttu-id="e6958-153">Dans ces scénarios, il est toujours préférable d’utiliser le [chargement hâtif](xref:core/querying/related-data/eager), afin qu’EF puisse extraire toutes les données requises dans un seul aller-retour.</span><span class="sxs-lookup"><span data-stu-id="e6958-153">In these scenarios, it is always better to use [eager loading](xref:core/querying/related-data/eager), so that EF can fetch all the required data in one roundtrip.</span></span> <span data-ttu-id="e6958-154">La fonctionnalité [include filtrée](xref:core/querying/related-data/eager#filtered-include) , introduite dans EF Core 5,0, vous permet également de limiter les entités associées que vous souhaitez charger, tout en conservant le processus de chargement hâtif et donc réalisable dans un seul aller-retour :</span><span class="sxs-lookup"><span data-stu-id="e6958-154">The [filtered include](xref:core/querying/related-data/eager#filtered-include) feature, introduced in EF Core 5.0, also allows you to limit which related entities you'd like to load, while keeping the loading process eager and therefore doable in a single roundtrip:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs#FilteredInclude)]

<span data-ttu-id="e6958-155">Dans d’autres scénarios, il est possible que nous ne sachions pas quelle entité associée nous allons avoir besoin avant d’obtenir son entité principale.</span><span class="sxs-lookup"><span data-stu-id="e6958-155">In other scenarios, we may not know which related entity we're going to need before we get its principal entity.</span></span> <span data-ttu-id="e6958-156">Par exemple, lors du chargement d’un blog, nous pouvons être amenés à consulter d’autres sources de données, éventuellement un WebService, afin de savoir si nous sommes intéressés par les publications de ce blog.</span><span class="sxs-lookup"><span data-stu-id="e6958-156">For example, when loading some Blog, we may need to consult some other data source - possibly a webservice - in order to know whether we're interested in that Blog's Posts.</span></span> <span data-ttu-id="e6958-157">Dans ce cas, le chargement [explicite](xref:core/querying/related-data/explicit) ou [différé](xref:core/querying/related-data/lazy) peut être utilisé pour extraire séparément les entités associées et remplir la navigation des publications du blog.</span><span class="sxs-lookup"><span data-stu-id="e6958-157">In these cases, [explicit](xref:core/querying/related-data/explicit) or [lazy](xref:core/querying/related-data/lazy) loading can be used to fetch related entities separately, and populate the Blog's Posts navigation.</span></span> <span data-ttu-id="e6958-158">Notez que dans la mesure où ces méthodes ne sont pas impatientes, elles nécessitent des allers-retours supplémentaires vers la base de données, qui est source de ralentissement. selon votre scénario spécifique, il peut être plus efficace de toujours charger toutes les publications, plutôt que d’exécuter les allers-retours supplémentaires et d’obtenir uniquement les publications dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="e6958-158">Note that since these methods aren't eager, they require additional roundtrips to the database, which is source of slowdown; depending on your specific scenario, it may be more efficient to just always load all Posts, rather than to execute the additional roundtrips and selectively get only the Posts you need.</span></span>

### <a name="beware-of-lazy-loading"></a><span data-ttu-id="e6958-159">Méfiez-vous du chargement différé</span><span class="sxs-lookup"><span data-stu-id="e6958-159">Beware of lazy loading</span></span>

<span data-ttu-id="e6958-160">Le [chargement différé](xref:core/querying/related-data/lazy) semble souvent un moyen très utile d’écrire la logique de la base de données, car EF Core charge automatiquement les entités associées à partir de la base de données à mesure que votre code y accède.</span><span class="sxs-lookup"><span data-stu-id="e6958-160">[Lazy loading](xref:core/querying/related-data/lazy) often seems like a very useful way to write database logic, since EF Core automatically loads related entities from the database as they are accessed by your code.</span></span> <span data-ttu-id="e6958-161">Cela évite le chargement des entités associées qui ne sont pas nécessaires (par exemple, le [chargement explicite](xref:core/querying/related-data/explicit)) et, apparemment, évite au programmeur d’avoir à gérer complètement les entités associées.</span><span class="sxs-lookup"><span data-stu-id="e6958-161">This avoids loading related entities that aren't needed (like [explicit loading](xref:core/querying/related-data/explicit)), and seemingly frees the programmer from having to deal with related entities altogether.</span></span> <span data-ttu-id="e6958-162">Toutefois, le chargement différé est particulièrement sujet à la génération de boucles supplémentaires inutiles qui peuvent ralentir l’application.</span><span class="sxs-lookup"><span data-stu-id="e6958-162">However, lazy loading is particularly prone for producing unneeded extra roundtrips which can slow the application.</span></span>

<span data-ttu-id="e6958-163">Tenez compte des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="e6958-163">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NPlusOne)]

<span data-ttu-id="e6958-164">Ce morceau de code apparemment inoffensif parcourt tous les blogs et leurs publications, en les imprimant. L’activation de la [journalisation des instructions](xref:core/logging-events-diagnostics/index) de EF Core révèle ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="e6958-164">This seemingly innocent piece of code iterates through all the blogs and their posts, printing them out. Turning on EF Core's [statement logging](xref:core/logging-events-diagnostics/index) reveals the following:</span></span>

```console
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[BlogId], [b].[Rating], [b].[Url]
      FROM [Blogs] AS [b]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__p_0='1'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='2'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='3'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0

... and so on
```

<span data-ttu-id="e6958-165">Comment cela se fait-il ?</span><span class="sxs-lookup"><span data-stu-id="e6958-165">What's going on here?</span></span> <span data-ttu-id="e6958-166">Pourquoi toutes ces requêtes sont-elles envoyées pour les boucles simples ci-dessus ?</span><span class="sxs-lookup"><span data-stu-id="e6958-166">Why are all these queries being sent for the simple loops above?</span></span> <span data-ttu-id="e6958-167">Avec le chargement différé, les publications d’un blog sont chargées uniquement (différées) lors de l’accès à la propriété Posts. par conséquent, chaque itération dans le foreach interne déclenche une requête de base de données supplémentaire, dans son propre aller-retour.</span><span class="sxs-lookup"><span data-stu-id="e6958-167">With lazy loading, a Blog's Posts are only (lazily) loaded when its Posts property is accessed; as a result, each iteration in the inner foreach triggers an additional database query, in its own roundtrip.</span></span> <span data-ttu-id="e6958-168">Par conséquent, une fois que la requête initiale a chargé tous les blogs, nous avons une autre requête *par blog*, en chargeant toutes ses publications. C’est ce que l’on appelle parfois le problème *N + 1* et cela peut entraîner des problèmes de performances très importants.</span><span class="sxs-lookup"><span data-stu-id="e6958-168">As a result, after the initial query loading all the blogs, we then have another query *per blog*, loading all its posts; this is sometimes called the *N+1* problem, and it can cause very significant performance issues.</span></span>

<span data-ttu-id="e6958-169">En supposant que nous aurons besoin de tous les billets de blog, il est judicieux d’utiliser le chargement hâtif ici à la place.</span><span class="sxs-lookup"><span data-stu-id="e6958-169">Assuming we're going to need all of the blogs' posts, it makes sense to use eager loading here instead.</span></span> <span data-ttu-id="e6958-170">Nous pouvons utiliser l’opérateur [include](xref:core/querying/related-data/eager#eager-loading) pour effectuer le chargement, mais puisque nous avons uniquement besoin des URL des blogs (et nous devrions uniquement [charger ce qui est nécessaire](xref:core/performance/efficient-querying#project-only-properties-you-need)).</span><span class="sxs-lookup"><span data-stu-id="e6958-170">We can use the [Include](xref:core/querying/related-data/eager#eager-loading) operator to perform the loading, but since we only need the Blogs' URLs (and we should only [load what's needed](xref:core/performance/efficient-querying#project-only-properties-you-need)).</span></span> <span data-ttu-id="e6958-171">Nous allons donc utiliser une projection à la place :</span><span class="sxs-lookup"><span data-stu-id="e6958-171">So we'll use a projection instead:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#EagerlyLoadRelatedAndProject)]

<span data-ttu-id="e6958-172">Ainsi, EF Core récupérer tous les blogs, ainsi que leurs publications, en une seule requête.</span><span class="sxs-lookup"><span data-stu-id="e6958-172">This will make EF Core fetch all the Blogs - along with their Posts - in a single query.</span></span> <span data-ttu-id="e6958-173">Dans certains cas, il peut également être utile d’éviter les effets d’éclatement cartésien en utilisant des [requêtes fractionnées](xref:core/querying/single-split-queries).</span><span class="sxs-lookup"><span data-stu-id="e6958-173">In some cases, it may also be useful to avoid cartesian explosion effects by using [split queries](xref:core/querying/single-split-queries).</span></span>

> [!WARNING]
> <span data-ttu-id="e6958-174">Étant donné que le chargement différé permet de déclencher très facilement le problème N + 1 par inadvertance, il est recommandé de l’éviter.</span><span class="sxs-lookup"><span data-stu-id="e6958-174">Because lazy loading makes it extremely easy to inadvertently trigger the N+1 problem, it is recommended to avoid it.</span></span> <span data-ttu-id="e6958-175">Le chargement hâtif ou explicite rend très clair dans le code source lorsqu’un aller-retour de base de données se produit.</span><span class="sxs-lookup"><span data-stu-id="e6958-175">Eager or explicit loading make it very clear in the source code when a database roundtrip occurs.</span></span>

## <a name="buffering-and-streaming"></a><span data-ttu-id="e6958-176">Mise en mémoire tampon et diffusion en continu</span><span class="sxs-lookup"><span data-stu-id="e6958-176">Buffering and streaming</span></span>

<span data-ttu-id="e6958-177">La mise en mémoire tampon fait référence au chargement de tous les résultats de votre requête dans la mémoire, tandis que la diffusion en continu signifie que EF envoie un résultat unique à l’application à chaque fois, sans jamais contenir l’intégralité du jeu de résultats en mémoire.</span><span class="sxs-lookup"><span data-stu-id="e6958-177">Buffering refers to loading all your query results into memory, whereas streaming means that EF hands the application a single result each time, never containing the entire resultset in memory.</span></span> <span data-ttu-id="e6958-178">En principe, les besoins en mémoire d’une requête de streaming sont fixes : ils sont les mêmes si la requête retourne 1 ligne ou 1000 ; en revanche, une requête de mise en mémoire tampon requiert plus de mémoire, plus les lignes sont retournées.</span><span class="sxs-lookup"><span data-stu-id="e6958-178">In principle, the memory requirements of a streaming query are fixed - they are the same whether the query returns 1 row or 1000; a buffering query, on the other hand, requires more memory the more rows are returned.</span></span> <span data-ttu-id="e6958-179">Pour les requêtes qui génèrent des jeux de résultats volumineux, il peut s’agir d’un facteur de performance important.</span><span class="sxs-lookup"><span data-stu-id="e6958-179">For queries that result large resultsets, this can be an important performance factor.</span></span>

<span data-ttu-id="e6958-180">La façon dont les mémoires tampons ou les flux de requête dépendent de la façon dont elles sont évaluées :</span><span class="sxs-lookup"><span data-stu-id="e6958-180">Whether a query buffers or streams depends on how it is evaluated:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#BufferingAndStreaming)]

<span data-ttu-id="e6958-181">Si vos requêtes renvoient simplement quelques résultats, vous n’avez probablement pas à vous soucier de cela.</span><span class="sxs-lookup"><span data-stu-id="e6958-181">If your queries return just a few results, then you probably don't have to worry about this.</span></span> <span data-ttu-id="e6958-182">Toutefois, si votre requête peut retourner un grand nombre de lignes, il est utile de réfléchir à la diffusion en continu au lieu de la mise en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="e6958-182">However, if your query might return large numbers of rows, it's worth giving thought to streaming instead of buffering.</span></span>

> [!NOTE]
> <span data-ttu-id="e6958-183">Évitez d' <xref:System.Linq.Enumerable.ToList%2A> <xref:System.Linq.Enumerable.ToArray%2A> utiliser ou si vous envisagez d’utiliser un autre opérateur LINQ sur le résultat, cela entraînera inutilement la mise en mémoire tampon de tous les résultats.</span><span class="sxs-lookup"><span data-stu-id="e6958-183">Avoid using <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> if you intend to use another LINQ operator on the result - this will needlessly buffer all results into memory.</span></span> <span data-ttu-id="e6958-184">Utilisez <xref:System.Linq.Enumerable.AsEnumerable%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="e6958-184">Use <xref:System.Linq.Enumerable.AsEnumerable%2A> instead.</span></span>

### <a name="internal-buffering-by-ef"></a><span data-ttu-id="e6958-185">Mise en mémoire tampon interne par EF</span><span class="sxs-lookup"><span data-stu-id="e6958-185">Internal buffering by EF</span></span>

<span data-ttu-id="e6958-186">Dans certaines situations, EF met lui-même en mémoire tampon le ResultSet en interne, quelle que soit la façon dont vous évaluez votre requête.</span><span class="sxs-lookup"><span data-stu-id="e6958-186">In certain situations, EF will itself buffer the resultset internally, regardless of how you evaluate your query.</span></span> <span data-ttu-id="e6958-187">Les deux cas où cela se produit sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="e6958-187">The two cases where this happens are:</span></span>

* <span data-ttu-id="e6958-188">Lorsqu’une stratégie de nouvelle tentative d’exécution est en place.</span><span class="sxs-lookup"><span data-stu-id="e6958-188">When a retrying execution strategy is in place.</span></span> <span data-ttu-id="e6958-189">Cela permet de s’assurer que les mêmes résultats sont retournés si la requête est retentée ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="e6958-189">This is done to make sure the same results are returned if the query is retried later.</span></span>
* <span data-ttu-id="e6958-190">Lorsque la [requête Split](xref:core/querying/single-split-queries) est utilisée, les jeux de résultats de toutes les requêtes sauf la dernière sont mis en mémoire tampon, sauf si mars est activé sur SQL Server.</span><span class="sxs-lookup"><span data-stu-id="e6958-190">When [split query](xref:core/querying/single-split-queries) is used, the resultsets of all but the last query are buffered - unless MARS is enabled on SQL Server.</span></span> <span data-ttu-id="e6958-191">Cela est dû au fait qu’il est généralement impossible d’avoir plusieurs jeux de résultats de requête actifs en même temps.</span><span class="sxs-lookup"><span data-stu-id="e6958-191">This is because it is usually impossible to have multiple query resultsets active at the same time.</span></span>

<span data-ttu-id="e6958-192">Notez que cette mise en mémoire tampon interne se produit en plus de la mise en mémoire tampon que vous provoquez via les opérateurs LINQ.</span><span class="sxs-lookup"><span data-stu-id="e6958-192">Note that this internal buffering occurs in addition to any buffering you cause via LINQ operators.</span></span> <span data-ttu-id="e6958-193">Par exemple, si vous utilisez <xref:System.Linq.Enumerable.ToList%2A> sur une requête et qu’une stratégie de nouvelle tentative d’exécution est en place, le jeu de résultats est chargé en mémoire *deux fois*: en interne par EF, et une fois par <xref:System.Linq.Enumerable.ToList%2A> .</span><span class="sxs-lookup"><span data-stu-id="e6958-193">For example, if you use <xref:System.Linq.Enumerable.ToList%2A> on a query and a retrying execution strategy is in place, the resultset is loaded into memory *twice*: once internally by EF, and once by <xref:System.Linq.Enumerable.ToList%2A>.</span></span>

## <a name="tracking-no-tracking-and-identity-resolution"></a><span data-ttu-id="e6958-194">Suivi, sans suivi et résolution d’identité</span><span class="sxs-lookup"><span data-stu-id="e6958-194">Tracking, no-tracking and identity resolution</span></span>

<span data-ttu-id="e6958-195">Avant de poursuivre cette section, il est recommandé de lire [la page dédiée sur le suivi et le non-suivi](xref:core/querying/tracking) .</span><span class="sxs-lookup"><span data-stu-id="e6958-195">It's recommended to read [the dedicated page on tracking and no-tracking](xref:core/querying/tracking) before continuing with this section.</span></span>

<span data-ttu-id="e6958-196">EF effectue le suivi des instances d’entité par défaut, afin que les modifications qui s’y appliquent soient détectées et rendues persistantes quand <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="e6958-196">EF tracks entity instances by default, so that changes on them are detected and persisted when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="e6958-197">Un autre effet des requêtes de suivi est que EF détecte si une instance a déjà été chargée pour vos données et retourne automatiquement cette instance suivie plutôt que d’en retourner une nouvelle. C’est ce que l’on appelle la *résolution d’identité*.</span><span class="sxs-lookup"><span data-stu-id="e6958-197">Another effect of tracking queries is that EF detects if an instance has already been loaded for your data, and will automatically return that tracked instance rather than returning a new one; this is called *identity resolution*.</span></span> <span data-ttu-id="e6958-198">Du point de vue des performances, le suivi des modifications signifie ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="e6958-198">From a performance perspective, change tracking means the following:</span></span>

* <span data-ttu-id="e6958-199">EF gère en interne un dictionnaire d’instances suivies.</span><span class="sxs-lookup"><span data-stu-id="e6958-199">EF internally maintains a dictionary of tracked instances.</span></span> <span data-ttu-id="e6958-200">Lorsque de nouvelles données sont chargées, EF vérifie le dictionnaire pour déterminer si une instance est déjà suivie pour la clé de cette entité (résolution d’identité).</span><span class="sxs-lookup"><span data-stu-id="e6958-200">When new data is loaded, EF checks the dictionary to see if an instance is already tracked for that entity's key (identity resolution).</span></span> <span data-ttu-id="e6958-201">La maintenance du dictionnaire et les recherches prennent un certain temps lors du chargement des résultats de la requête.</span><span class="sxs-lookup"><span data-stu-id="e6958-201">The dictionary maintenance and lookups take up some time when loading the query's results.</span></span>
* <span data-ttu-id="e6958-202">Avant de transmettre une instance chargée à l’application, EF *capture les instantanés* de cette instance et conserve l’instantané en interne.</span><span class="sxs-lookup"><span data-stu-id="e6958-202">Before handing a loaded instance to the application, EF *snapshots* that instance and keeps the snapshot internally.</span></span> <span data-ttu-id="e6958-203">Lorsque <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> est appelé, l’instance de l’application est comparée à celle de l’instantané pour détecter les modifications à rendre persistantes.</span><span class="sxs-lookup"><span data-stu-id="e6958-203">When <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called, the application's instance is compared with the snapshot to discover the changes to be persisted.</span></span> <span data-ttu-id="e6958-204">L’instantané prend plus de mémoire et le processus d’instantané prend du temps. Il est parfois possible de spécifier un comportement d’interblocage différent, éventuellement plus efficace par le biais de [comparateurs de valeur](xref:core/modeling/value-comparers), ou d’utiliser des proxys de suivi des modifications pour contourner complètement le processus d’instantané (bien que cela soit fourni avec son propre ensemble de inconvénients).</span><span class="sxs-lookup"><span data-stu-id="e6958-204">The snapshot takes up more memory, and the snapshotting process itself takes time; it's sometimes possible to specify different, possibly more efficient snapshotting behavior via [value comparers](xref:core/modeling/value-comparers), or to use change-tracking proxies to bypass the snapshotting process altogether (though that comes with its own set of disadvantages).</span></span>

<span data-ttu-id="e6958-205">Dans les scénarios en lecture seule où les modifications ne sont pas enregistrées dans la base de données, les retards ci-dessus peuvent être évités en utilisant des [requêtes sans suivi](xref:core/querying/tracking#no-tracking-queries).</span><span class="sxs-lookup"><span data-stu-id="e6958-205">In read-only scenarios where changes aren't saved back to the database, the above overheads can be avoided by using [no-tracking queries](xref:core/querying/tracking#no-tracking-queries).</span></span> <span data-ttu-id="e6958-206">Toutefois, étant donné que les requêtes sans suivi n’effectuent pas de résolution d’identité, une ligne de base de données référencée par plusieurs autres lignes chargées est matérialisée comme des instances différentes.</span><span class="sxs-lookup"><span data-stu-id="e6958-206">However, since no-tracking queries do not perform identity resolution, a database row which is referenced by multiple other loaded rows will be materialized as different instances.</span></span>

<span data-ttu-id="e6958-207">Pour illustrer cela, supposons que nous chargeons un grand nombre de publications à partir de la base de données, ainsi que le blog référencé par chaque publication.</span><span class="sxs-lookup"><span data-stu-id="e6958-207">To illustrate, assume we are loading a large number of Posts from the database, as well as the Blog referenced by each Post.</span></span> <span data-ttu-id="e6958-208">Si 100 publications se produisent pour faire référence au même blog, une requête de suivi le détecte via la résolution d’identité et toutes les instances post font référence à la même instance de blog dédupliquée.</span><span class="sxs-lookup"><span data-stu-id="e6958-208">If 100 Posts happen to reference the same Blog, a tracking query detects this via identity resolution, and all Post instances will refer the same de-duplicated Blog instance.</span></span> <span data-ttu-id="e6958-209">Une requête sans suivi, en revanche, duplique les mêmes heures du blog 100 et le code d’application doit être écrit en conséquence.</span><span class="sxs-lookup"><span data-stu-id="e6958-209">A no-tracking query, in contrast, duplicates the same Blog 100 times - and application code must be written accordingly.</span></span>

<span data-ttu-id="e6958-210">Voici les résultats d’un test comparatif comparaison entre le suivi et le non-suivi pour une requête chargeant 10 blogs avec 20 publications chacun.</span><span class="sxs-lookup"><span data-stu-id="e6958-210">Here are the results for a benchmark comparing tracking vs. no-tracking behavior for a query loading 10 Blogs with 20 Posts each.</span></span> <span data-ttu-id="e6958-211">[Le code source est disponible ici. n'](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/QueryTrackingBehavior.cs)hésitez pas à l’utiliser comme base pour vos propres mesures.</span><span class="sxs-lookup"><span data-stu-id="e6958-211">[The source code is available here](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/QueryTrackingBehavior.cs), feel free to use it as a basis for your own measurements.</span></span>

|       <span data-ttu-id="e6958-212">Méthode</span><span class="sxs-lookup"><span data-stu-id="e6958-212">Method</span></span> | <span data-ttu-id="e6958-213">NumBlogs</span><span class="sxs-lookup"><span data-stu-id="e6958-213">NumBlogs</span></span> | <span data-ttu-id="e6958-214">NumPostsPerBlog</span><span class="sxs-lookup"><span data-stu-id="e6958-214">NumPostsPerBlog</span></span> |       <span data-ttu-id="e6958-215">Moyenne</span><span class="sxs-lookup"><span data-stu-id="e6958-215">Mean</span></span> |    <span data-ttu-id="e6958-216">Erreur</span><span class="sxs-lookup"><span data-stu-id="e6958-216">Error</span></span> |   <span data-ttu-id="e6958-217">StdDev</span><span class="sxs-lookup"><span data-stu-id="e6958-217">StdDev</span></span> |     <span data-ttu-id="e6958-218">Médiane</span><span class="sxs-lookup"><span data-stu-id="e6958-218">Median</span></span> | <span data-ttu-id="e6958-219">Proportions</span><span class="sxs-lookup"><span data-stu-id="e6958-219">Ratio</span></span> | <span data-ttu-id="e6958-220">RatioSD</span><span class="sxs-lookup"><span data-stu-id="e6958-220">RatioSD</span></span> |   <span data-ttu-id="e6958-221">Génération 0</span><span class="sxs-lookup"><span data-stu-id="e6958-221">Gen 0</span></span> |   <span data-ttu-id="e6958-222">GEN 1</span><span class="sxs-lookup"><span data-stu-id="e6958-222">Gen 1</span></span> | <span data-ttu-id="e6958-223">Génération 2</span><span class="sxs-lookup"><span data-stu-id="e6958-223">Gen 2</span></span> | <span data-ttu-id="e6958-224">Allocated</span><span class="sxs-lookup"><span data-stu-id="e6958-224">Allocated</span></span> |
|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|
|   <span data-ttu-id="e6958-225">AsTracking</span><span class="sxs-lookup"><span data-stu-id="e6958-225">AsTracking</span></span> |       <span data-ttu-id="e6958-226">10</span><span class="sxs-lookup"><span data-stu-id="e6958-226">10</span></span> |              <span data-ttu-id="e6958-227">20</span><span class="sxs-lookup"><span data-stu-id="e6958-227">20</span></span> | <span data-ttu-id="e6958-228">1 414,7 US</span><span class="sxs-lookup"><span data-stu-id="e6958-228">1,414.7 us</span></span> | <span data-ttu-id="e6958-229">27,20 US</span><span class="sxs-lookup"><span data-stu-id="e6958-229">27.20 us</span></span> | <span data-ttu-id="e6958-230">45,44 US</span><span class="sxs-lookup"><span data-stu-id="e6958-230">45.44 us</span></span> | <span data-ttu-id="e6958-231">1 405,5 US</span><span class="sxs-lookup"><span data-stu-id="e6958-231">1,405.5 us</span></span> |  <span data-ttu-id="e6958-232">1.00</span><span class="sxs-lookup"><span data-stu-id="e6958-232">1.00</span></span> |    <span data-ttu-id="e6958-233">0,00</span><span class="sxs-lookup"><span data-stu-id="e6958-233">0.00</span></span> | <span data-ttu-id="e6958-234">60,5469</span><span class="sxs-lookup"><span data-stu-id="e6958-234">60.5469</span></span> | <span data-ttu-id="e6958-235">13,6719</span><span class="sxs-lookup"><span data-stu-id="e6958-235">13.6719</span></span> |     - | <span data-ttu-id="e6958-236">380,11 KO</span><span class="sxs-lookup"><span data-stu-id="e6958-236">380.11 KB</span></span> |
| <span data-ttu-id="e6958-237">AsNoTracking</span><span class="sxs-lookup"><span data-stu-id="e6958-237">AsNoTracking</span></span> |       <span data-ttu-id="e6958-238">10</span><span class="sxs-lookup"><span data-stu-id="e6958-238">10</span></span> |              <span data-ttu-id="e6958-239">20</span><span class="sxs-lookup"><span data-stu-id="e6958-239">20</span></span> |   <span data-ttu-id="e6958-240">993,3 US</span><span class="sxs-lookup"><span data-stu-id="e6958-240">993.3 us</span></span> | <span data-ttu-id="e6958-241">24,04 US</span><span class="sxs-lookup"><span data-stu-id="e6958-241">24.04 us</span></span> | <span data-ttu-id="e6958-242">65,40 US</span><span class="sxs-lookup"><span data-stu-id="e6958-242">65.40 us</span></span> |   <span data-ttu-id="e6958-243">966,2 US</span><span class="sxs-lookup"><span data-stu-id="e6958-243">966.2 us</span></span> |  <span data-ttu-id="e6958-244">0.71</span><span class="sxs-lookup"><span data-stu-id="e6958-244">0.71</span></span> |    <span data-ttu-id="e6958-245">0,05</span><span class="sxs-lookup"><span data-stu-id="e6958-245">0.05</span></span> | <span data-ttu-id="e6958-246">37,1094</span><span class="sxs-lookup"><span data-stu-id="e6958-246">37.1094</span></span> |  <span data-ttu-id="e6958-247">6,8359</span><span class="sxs-lookup"><span data-stu-id="e6958-247">6.8359</span></span> |     - | <span data-ttu-id="e6958-248">232,89 KO</span><span class="sxs-lookup"><span data-stu-id="e6958-248">232.89 KB</span></span> |

<span data-ttu-id="e6958-249">Enfin, il est possible d’effectuer des mises à jour sans la surcharge du suivi des modifications, en utilisant une requête de non-suivi, puis en attachant l’instance retournée au contexte, en spécifiant les modifications à apporter.</span><span class="sxs-lookup"><span data-stu-id="e6958-249">Finally, it is possible to perform updates without the overhead of change tracking, by utilizing a no-tracking query and then attaching the returned instance to the context, specifying which changes are to be made.</span></span> <span data-ttu-id="e6958-250">Cela transfère la charge du suivi des modifications d’EF à l’utilisateur et ne doit être tentée que si la surcharge de suivi des modifications a été révélée inacceptable par le biais du profilage ou de l’évaluation.</span><span class="sxs-lookup"><span data-stu-id="e6958-250">This transfers the burden of change tracking from EF to the user, and should only be attempted if the change tracking overhead has been shown to be unacceptable via profiling or benchmarking.</span></span>

## <a name="using-raw-sql"></a><span data-ttu-id="e6958-251">Utilisation du SQL brut</span><span class="sxs-lookup"><span data-stu-id="e6958-251">Using raw SQL</span></span>

<span data-ttu-id="e6958-252">Dans certains cas, il existe un SQL plus optimisé pour votre requête, qu’EF ne génère pas.</span><span class="sxs-lookup"><span data-stu-id="e6958-252">In some cases, more optimized SQL exists for your query, which EF does not generate.</span></span> <span data-ttu-id="e6958-253">Cela peut se produire lorsque la construction SQL est une extension spécifique à votre base de données qui n’est pas prise en charge, ou simplement parce que EF ne la convertit pas encore.</span><span class="sxs-lookup"><span data-stu-id="e6958-253">This can happen when the SQL construct is an extension specific to your database that's unsupported, or simply because EF does not translate to it yet.</span></span> <span data-ttu-id="e6958-254">Dans ce cas, l’écriture de SQL à la main peut améliorer considérablement les performances et EF prend en charge plusieurs façons de procéder.</span><span class="sxs-lookup"><span data-stu-id="e6958-254">In these cases, writing SQL by hand can provide a substantial performance boost, and EF supports several ways to do this.</span></span>

* <span data-ttu-id="e6958-255">Utilisez le SQL brut [directement dans votre requête](xref:core/querying/raw-sql), par exemple via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A> .</span><span class="sxs-lookup"><span data-stu-id="e6958-255">Use raw SQL [directly in your query](xref:core/querying/raw-sql), e.g. via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A>.</span></span> <span data-ttu-id="e6958-256">EF vous permet même de composer le SQL brut à l’aide de requêtes LINQ classiques, ce qui vous permet d’exprimer uniquement une partie de la requête dans le SQL brut.</span><span class="sxs-lookup"><span data-stu-id="e6958-256">EF even lets you compose over the raw SQL with regular LINQ queries, allowing you to express only a part of the query in raw SQL.</span></span> <span data-ttu-id="e6958-257">Il s’agit d’une bonne technique lorsque le SQL brut ne doit être utilisé que dans une seule requête dans votre base de code.</span><span class="sxs-lookup"><span data-stu-id="e6958-257">This is a good technique when the raw SQL only needs to be used in a single query in your codebase.</span></span>
* <span data-ttu-id="e6958-258">Définissez une [fonction définie par l’utilisateur](xref:core/querying/database-functions) (UDF), puis appelez-la à partir de vos requêtes.</span><span class="sxs-lookup"><span data-stu-id="e6958-258">Define a [user-defined function](xref:core/querying/database-functions) (UDF), and then call that from your queries.</span></span> <span data-ttu-id="e6958-259">Notez que depuis 5,0, EF permet aux fonctions définies par l’utilisateur de retourner des jeux de résultats complets. ces fonctions sont connues sous le nom de fonctions table (TVF). elle permet également de mapper une `DbSet` à une fonction, en faisant en sorte qu’elle ressemble simplement à une autre table.</span><span class="sxs-lookup"><span data-stu-id="e6958-259">Note that since 5.0, EF allows UDFs to return full resultsets - these are known as table-valued functions (TVFs) - and also allows mapping a `DbSet` to a function, making it look just like just another table.</span></span>
* <span data-ttu-id="e6958-260">Définissez une vue de base de données et interrogez-la dans vos requêtes.</span><span class="sxs-lookup"><span data-stu-id="e6958-260">Define a database view and query from it in your queries.</span></span> <span data-ttu-id="e6958-261">Notez que contrairement aux fonctions, les vues ne peuvent pas accepter de paramètres.</span><span class="sxs-lookup"><span data-stu-id="e6958-261">Note that unlike functions, views cannot accept parameters.</span></span>

> [!NOTE]
> <span data-ttu-id="e6958-262">Le SQL brut doit généralement être utilisé en dernier recours, après avoir vérifié que EF ne peut pas générer le SQL souhaité, et lorsque les performances sont suffisamment importantes pour que la requête donnée les justifie.</span><span class="sxs-lookup"><span data-stu-id="e6958-262">Raw SQL should generally be used as a last resort, after making sure that EF can't generate the SQL you want, and when performance is important enough for the given query to justify it.</span></span> <span data-ttu-id="e6958-263">L’utilisation de SQL brut apporte des inconvénients importants en matière de maintenance.</span><span class="sxs-lookup"><span data-stu-id="e6958-263">Using raw SQL brings considerable maintenance disadvantages.</span></span>

## <a name="asynchronous-programming"></a><span data-ttu-id="e6958-264">Programmation asynchrone</span><span class="sxs-lookup"><span data-stu-id="e6958-264">Asynchronous programming</span></span>

<span data-ttu-id="e6958-265">En règle générale, pour que votre application soit évolutive, il est important de toujours utiliser des API asynchrones plutôt que synchrones (par exemple, <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> plutôt que <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> ).</span><span class="sxs-lookup"><span data-stu-id="e6958-265">As a general rule, in order for your application to be scalable, it's important to always use asynchronous APIs rather than synchronous one (e.g. <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> rather than <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>).</span></span> <span data-ttu-id="e6958-266">Les API synchrones bloquent le thread pendant la durée des e/s de base de données, ce qui améliore le besoin de threads et le nombre de commutateurs de contexte de thread qui doivent se produire.</span><span class="sxs-lookup"><span data-stu-id="e6958-266">Synchronous APIs block the thread for the duration of database I/O, increasing the need for threads and the number of thread context switches that must occur.</span></span>

<span data-ttu-id="e6958-267">Pour plus d’informations, consultez la page sur la [programmation asynchrone](xref:core/miscellaneous/async).</span><span class="sxs-lookup"><span data-stu-id="e6958-267">For more information, see the page on [async programming](xref:core/miscellaneous/async).</span></span>

> [!WARNING]
> <span data-ttu-id="e6958-268">Évitez de mélanger du code synchrone et asynchrone au sein d’une même application. il est très facile de déclencher par inadvertance des problèmes de privation subtils de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="e6958-268">Avoid mixing synchronous and asynchronous code in the same application - it's very easy to inadvertently trigger subtle thread-pool starvation issues.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="e6958-269">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="e6958-269">Additional resources</span></span>

<span data-ttu-id="e6958-270">Consultez la [section performances](xref:core/querying/null-comparisons#writing-performant-queries) de la page de documentation de comparaison null pour connaître les meilleures pratiques lors de la comparaison de valeurs Nullable.</span><span class="sxs-lookup"><span data-stu-id="e6958-270">See the [performance section](xref:core/querying/null-comparisons#writing-performant-queries) of the null comparison documentation page for some best practices when comparing nullable values.</span></span>
