---
title: Modélisation des performances-EF Core
description: Modélisation efficace lors de l’utilisation de Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: fc16ec67c3865aa7b7a95519463ca7493a2709b0
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657822"
---
# <a name="modeling-for-performance"></a><span data-ttu-id="34c39-103">Modélisation des performances</span><span class="sxs-lookup"><span data-stu-id="34c39-103">Modeling for Performance</span></span>

<span data-ttu-id="34c39-104">Dans de nombreux cas, la façon dont vous modélisez le modèle peut avoir un impact important sur les performances de votre application. Bien qu’un modèle correctement normalisé et « correct » soit généralement un bon point de départ, dans des applications réelles, certaines compromissions pragmatiques peuvent être longues pour obtenir de bonnes performances.</span><span class="sxs-lookup"><span data-stu-id="34c39-104">In many cases, the way you model can have a profound impact on the performance of your application; while a properly normalized and "correct" model is usually a good starting point, in real-world applications some pragmatic compromises can go a long way for achieving good performance.</span></span> <span data-ttu-id="34c39-105">Étant donné qu’il est assez difficile de modifier votre modèle une fois qu’une application s’exécute en production, il est utile de garder à l’esprit les performances lors de la création du modèle initial.</span><span class="sxs-lookup"><span data-stu-id="34c39-105">Since it's quite difficult to change your model once an application is running in production, it's worth keeping performance in mind when creating the initial model.</span></span>

## <a name="denormalization-and-caching"></a><span data-ttu-id="34c39-106">Dénormalisation et mise en cache</span><span class="sxs-lookup"><span data-stu-id="34c39-106">Denormalization and caching</span></span>

<span data-ttu-id="34c39-107">La *dénormalisation* est la pratique consistant à ajouter des données redondantes à votre schéma, généralement afin d’éliminer les jointures lors de l’interrogation.</span><span class="sxs-lookup"><span data-stu-id="34c39-107">*Denormalization* is the practice of adding redundant data to your schema, usually in order to eliminate joins when querying.</span></span> <span data-ttu-id="34c39-108">Par exemple, pour un modèle avec des blogs et des billets, où chaque publication a une évaluation, vous pouvez être amené à afficher fréquemment l’évaluation moyenne du blog.</span><span class="sxs-lookup"><span data-stu-id="34c39-108">For example, for a model with Blogs and Posts, where each Post has a Rating, you may be required to frequently show the average rating of the Blog.</span></span> <span data-ttu-id="34c39-109">L’approche la plus simple consiste à regrouper les publications par blog et à calculer la moyenne dans le cadre de la requête. mais cela nécessite une jointure coûteuse entre les deux tables.</span><span class="sxs-lookup"><span data-stu-id="34c39-109">The simple approach to this would group the Posts by their Blog, and calculate the average as part of the query; but this requires a costly join between the two tables.</span></span> <span data-ttu-id="34c39-110">La dénormalisation ajoute la moyenne calculée de toutes les publications à une nouvelle colonne sur le blog, afin qu’elle soit immédiatement accessible, sans jointure ou calcul.</span><span class="sxs-lookup"><span data-stu-id="34c39-110">Denormalization would add the calculated average of all posts to a new column on Blog, so that it is immediately accessible, without joining or calculating.</span></span>

<span data-ttu-id="34c39-111">L’exemple ci-dessus peut être considéré comme une forme de *mise en cache* : les informations agrégées des publications sont mises en cache sur leur blog. et comme avec n’importe quelle mise en cache, le problème est de maintenir à jour la valeur mise en cache avec les données qu’elle met en cache.</span><span class="sxs-lookup"><span data-stu-id="34c39-111">The above can be viewed as a form of *caching* - aggregate information from the Posts is cached on their Blog; and like with any caching, the problem is how to keep the cached value up to date with the data it's caching.</span></span> <span data-ttu-id="34c39-112">Dans de nombreux cas, il est OK que les données mises en cache se décalent un peu ; par exemple, dans l’exemple ci-dessus, il est généralement raisonnable que l’évaluation moyenne du blog ne soit pas complètement à jour à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="34c39-112">In many cases, it's OK for the cached data to lag for a bit; for example, in the example above, it's usually reasonable for the blog's average rating to not be completely up to date at any given point.</span></span> <span data-ttu-id="34c39-113">Si c’est le cas, vous pouvez le recalculer à chaque instant, puis dans le cas contraire, un système plus élaboré doit être configuré pour maintenir à jour les valeurs mises en cache.</span><span class="sxs-lookup"><span data-stu-id="34c39-113">If that's the case, you can have it recalculated every now and then; otherwise, a more elaborate system must be set up to keep the cached values up to date.</span></span>

<span data-ttu-id="34c39-114">Les informations suivantes décrivent certaines techniques de dénormalisation et de mise en cache dans EF Core, et pointent vers les sections pertinentes de la documentation.</span><span class="sxs-lookup"><span data-stu-id="34c39-114">The following details some techniques for denormalization and caching in EF Core, and points to the relevant sections in the documentation.</span></span>

### <a name="stored-computed-columns"></a><span data-ttu-id="34c39-115">Colonnes calculées stockées</span><span class="sxs-lookup"><span data-stu-id="34c39-115">Stored computed columns</span></span>

<span data-ttu-id="34c39-116">Si les données à mettre en cache sont un produit d’autres colonnes de la même table, une [colonne calculée stockée](xref:core/modeling/generated-properties#computed-columns) peut être une solution parfaite.</span><span class="sxs-lookup"><span data-stu-id="34c39-116">If the data to be cached is a product of other columns in the same table, then a [stored computed column](xref:core/modeling/generated-properties#computed-columns) can be a perfect solution.</span></span> <span data-ttu-id="34c39-117">Par exemple, un `Customer` peut avoir `FirstName` des `LastName` colonnes et, mais il peut être nécessaire de rechercher le *nom complet* du client.</span><span class="sxs-lookup"><span data-stu-id="34c39-117">For example, a `Customer` may have `FirstName` and `LastName` columns, but we may need to search by the customer's *full name*.</span></span> <span data-ttu-id="34c39-118">Une colonne calculée stockée est gérée automatiquement par la base de données, qui la recalcule à chaque modification de la ligne. vous pouvez même définir un index sur celle-ci pour accélérer les requêtes.</span><span class="sxs-lookup"><span data-stu-id="34c39-118">A stored computed column is automatically maintained by the database - which recalculates it whenever the row is changed - and you can even define an index over it to speed up queries.</span></span>

### <a name="update-cache-columns-when-inputs-change"></a><span data-ttu-id="34c39-119">Mettre à jour les colonnes du cache lors de la modification des entrées</span><span class="sxs-lookup"><span data-stu-id="34c39-119">Update cache columns when inputs change</span></span>

<span data-ttu-id="34c39-120">Si votre colonne mise en cache doit référencer des entrées provenant de l’extérieur de la ligne de la table, vous ne pouvez pas utiliser de colonnes calculées.</span><span class="sxs-lookup"><span data-stu-id="34c39-120">If your cached column needs to reference inputs from outside the table's row, you cannot use computed columns.</span></span> <span data-ttu-id="34c39-121">Toutefois, il est toujours possible de recalculer la colonne chaque fois que son entrée change ; par exemple, vous pouvez recalculer la notation moyenne du blog chaque fois qu’une publication est modifiée, ajoutée ou supprimée.</span><span class="sxs-lookup"><span data-stu-id="34c39-121">However, it is still possible to recalculate the column whenever its input changes; for example, you could recalculate the average Blog's rating every time a Post is changed, added or removed.</span></span> <span data-ttu-id="34c39-122">Veillez à identifier les conditions exactes lorsque le recalcul est nécessaire. sinon, la valeur mise en cache ne sera plus synchronisée.</span><span class="sxs-lookup"><span data-stu-id="34c39-122">Be sure to identify the exact conditions when recalculation is needed, otherwise your cached value will go out of sync.</span></span>

<span data-ttu-id="34c39-123">Pour ce faire, vous pouvez procéder à la mise à jour par le biais de l’API de EF Core régulière.</span><span class="sxs-lookup"><span data-stu-id="34c39-123">One way to do this, is to perform the update yourself, via the regular EF Core API.</span></span> <span data-ttu-id="34c39-124">`SaveChanges`Les [événements](xref:core/logging-events-diagnostics/events) ou les [intercepteurs](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) peuvent être utilisés pour vérifier automatiquement si des publications sont en cours de mise à jour et pour effectuer le recalcul de cette façon.</span><span class="sxs-lookup"><span data-stu-id="34c39-124">`SaveChanges` [Events](xref:core/logging-events-diagnostics/events) or [interceptors](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) can be used to automatically check if any Posts are being updated, and to perform the recalculation that way.</span></span> <span data-ttu-id="34c39-125">Notez que cela implique généralement des allers-retours de base de données supplémentaires, car des commandes supplémentaires doivent être envoyées.</span><span class="sxs-lookup"><span data-stu-id="34c39-125">Note that this typically entails additional database roundtrips, as additional commands must be sent.</span></span>

<span data-ttu-id="34c39-126">Pour d’autres applications sensibles aux performances, les déclencheurs de base de données peuvent être définis pour effectuer automatiquement le recalcul dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="34c39-126">For more perf-sensitive applications, database triggers can be defined to automatically perform the recalculation in the database.</span></span> <span data-ttu-id="34c39-127">Cela enregistre les allers-retours de base de données supplémentaires, se produit automatiquement dans la même transaction que la mise à jour principale et peut être plus simple à configurer.</span><span class="sxs-lookup"><span data-stu-id="34c39-127">This saves the extra database roundtrips, automatically occurs within the same transaction as the main update, and can be simpler to set up.</span></span> <span data-ttu-id="34c39-128">EF ne fournit pas d’API spécifique pour la création ou la gestion des déclencheurs, mais il est parfait de [créer une migration vide et d’ajouter la définition du déclencheur par le biais de SQL brut](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="34c39-128">EF doesn't provide any specific API for creating or maintaining triggers, but it's perfectly fine to [create an empty migration and add the trigger definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

### <a name="materialized-views"></a><span data-ttu-id="34c39-129">Vues matérialisées</span><span class="sxs-lookup"><span data-stu-id="34c39-129">Materialized views</span></span>

<span data-ttu-id="34c39-130">Les vues matérialisées sont similaires aux vues régulières, à ceci près que leurs données sont stockées sur le disque (« matérialisé »), plutôt que calculées chaque fois que la vue est interrogée.</span><span class="sxs-lookup"><span data-stu-id="34c39-130">Materialized views are similar to regular views, except that their data is stored on disk ("materialized"), rather than calculated every time when the view is queried.</span></span> <span data-ttu-id="34c39-131">Cet outil est utile lorsque vous ne souhaitez pas simplement ajouter une seule colonne de cache à une base de données existante, mais que vous souhaitez plutôt mettre en cache l’ensemble du jeu de résultats des résultats d’une requête complexe et coûteuse, comme s’il s’agissait d’une table normale. Ces résultats peuvent ensuite être interrogés de façon très économique sans calcul ou jointures.</span><span class="sxs-lookup"><span data-stu-id="34c39-131">This tool is useful when you don't want to simply add a single cache column to an existing database, but rather want to cache the entire resultset of a complicated and expensive query's results, just as if it were a regular table; these results can then be queried very cheaply without any computation or joins happening.</span></span> <span data-ttu-id="34c39-132">Contrairement aux colonnes calculées, les vues matérialisées ne sont pas automatiquement mises à jour lorsque leurs tables sous-jacentes changent. elles doivent être actualisées manuellement.</span><span class="sxs-lookup"><span data-stu-id="34c39-132">Unlike computed columns, materialized views aren't automatically updated when their underlying tables change - they must be manually refreshed.</span></span> <span data-ttu-id="34c39-133">Si les données mises en cache peuvent avoir un décalage, l’actualisation de la vue peut être effectuée via un minuteur. une autre option consiste à configurer des déclencheurs de base de données pour passer en revue une vue matérialisée lorsque certains événements de base de données se produisent.</span><span class="sxs-lookup"><span data-stu-id="34c39-133">If the cached data can lag, refreshing the view can be done via a timer; another option is to set up database triggers to review a materialized view once certain database events occur.</span></span>

<span data-ttu-id="34c39-134">EF ne fournit actuellement aucune API spécifique pour la création ou la gestion d’affichages, matérialisés ou autres. mais il est tout à fait parfait de [créer une migration vide et d’ajouter la définition de la vue par le biais de SQL brut](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="34c39-134">EF doesn't currently provide any specific API for creating or maintaining views, materialized or otherwise; but it's perfectly fine to [create an empty migration and add the view definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

## <a name="inheritance-mapping"></a><span data-ttu-id="34c39-135">Mappage de l’héritage</span><span class="sxs-lookup"><span data-stu-id="34c39-135">Inheritance mapping</span></span>

<span data-ttu-id="34c39-136">Avant de poursuivre cette section, il est recommandé de lire [la page dédiée sur l’héritage](xref:core/modeling/inheritance) .</span><span class="sxs-lookup"><span data-stu-id="34c39-136">It's recommended to read [the dedicated page on inheritance](xref:core/modeling/inheritance) before continuing with this section.</span></span>

<span data-ttu-id="34c39-137">EF Core prend actuellement en charge deux techniques pour mapper un modèle d’héritage à une base de données relationnelle :</span><span class="sxs-lookup"><span data-stu-id="34c39-137">EF Core currently supports two techniques for mapping an inheritance model to a relational database:</span></span>

* <span data-ttu-id="34c39-138">TPH ( **table par hiérarchie** ), dans laquelle une hiérarchie .net entière de classes est mappée à une table de base de données unique</span><span class="sxs-lookup"><span data-stu-id="34c39-138">**Table-per-hierarchy** (TPH), in which an entire .NET hierarchy of classes is mapped to a single database table</span></span>
* <span data-ttu-id="34c39-139">**Table par type** (TPT), dans laquelle chaque type de la hiérarchie .net est mappé à une table différente dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="34c39-139">**Table-per-type** (TPT), in which each type in the .NET hierarchy is mapped to a different table in the database.</span></span>

<span data-ttu-id="34c39-140">Le choix de la technique de mappage de l’héritage peut avoir un impact considérable sur les performances de l’application. il est recommandé de mesurer soigneusement avant de procéder à un choix.</span><span class="sxs-lookup"><span data-stu-id="34c39-140">The choice of inheritance mapping technique can have a considerable impact on application performance - it's recommended to carefully measure before committing to a choice.</span></span>

<span data-ttu-id="34c39-141">Les gens choisissent parfois TPT, car il s’agit d’une technique de « nettoyage ». une table distincte pour chaque type .NET rend le schéma de base de données similaire à la hiérarchie des types .NET.</span><span class="sxs-lookup"><span data-stu-id="34c39-141">People sometimes choose TPT because it appears to be the "cleaner" technique; a separate table for each .NET type makes the database schema look similar to the .NET type hierarchy.</span></span> <span data-ttu-id="34c39-142">En outre, dans la mesure où TPH doit représenter l’intégralité de la hiérarchie dans une seule table, les lignes ont *toutes les* colonnes, quel que soit le type réellement détenu dans la ligne, et les colonnes non liées sont toujours vides et inutilisées.</span><span class="sxs-lookup"><span data-stu-id="34c39-142">In addition, since TPH must represent the entire hierarchy in a single table, rows have *all* columns regardless of the type actually being held in the row, and unrelated columns are always empty and unused.</span></span> <span data-ttu-id="34c39-143">Hormis le fait qu’il s’agit d’une technique de mappage « sans nettoyage », beaucoup pensent que ces colonnes vides occupent de l’espace considérable dans la base de données et peuvent également nuire aux performances.</span><span class="sxs-lookup"><span data-stu-id="34c39-143">Aside from seeming to be an "unclean" mapping technique, many believe that these empty columns take up considerable space in the database and may hurt performance as well.</span></span>

<span data-ttu-id="34c39-144">Toutefois, la mesure montre que TPT est dans la plupart des cas la technique de mappage inférieure du point de vue des performances ; Lorsque toutes les données de TPH proviennent d’une seule table, les requêtes TPT doivent rejoindre ensemble plusieurs tables, et les jointures sont l’une des principales sources de problèmes de performances dans les bases de données relationnelles.</span><span class="sxs-lookup"><span data-stu-id="34c39-144">However, measuring shows that TPT is in most cases the inferior mapping technique from a performance standpoint; where all data in TPH comes from a single table, TPT queries must join together multiple tables, and joins are one of the primary sources of performance issues in relational databases.</span></span> <span data-ttu-id="34c39-145">Les bases de données ont généralement tendance à gérer correctement les colonnes vides, et les fonctionnalités telles que les [SQL Server les colonnes éparses](/sql/relational-databases/tables/use-sparse-columns) peuvent encore réduire cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="34c39-145">Databases also generally tend to deal well with empty columns, and features such as [SQL Server sparse columns](/sql/relational-databases/tables/use-sparse-columns) can reduce this overhead even further.</span></span>

<span data-ttu-id="34c39-146">Pour obtenir un exemple concret, [consultez ce test d’évaluation](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) qui définit un modèle simple avec une hiérarchie de type 7. 5000 lignes sont amorcées pour chaque type-total 35000 lignes-et l’évaluation charge simplement toutes les lignes de la base de données :</span><span class="sxs-lookup"><span data-stu-id="34c39-146">For a concrete example, [see this benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) which sets up a simple model with a 7-type hierarchy; 5000 rows are seeded for each type - totalling 35000 rows - and the benchmark simply loads all rows from the database:</span></span>

| <span data-ttu-id="34c39-147">Méthode</span><span class="sxs-lookup"><span data-stu-id="34c39-147">Method</span></span> |     <span data-ttu-id="34c39-148">Moyenne</span><span class="sxs-lookup"><span data-stu-id="34c39-148">Mean</span></span> |   <span data-ttu-id="34c39-149">Erreur</span><span class="sxs-lookup"><span data-stu-id="34c39-149">Error</span></span> |  <span data-ttu-id="34c39-150">StdDev</span><span class="sxs-lookup"><span data-stu-id="34c39-150">StdDev</span></span> |     <span data-ttu-id="34c39-151">Génération 0</span><span class="sxs-lookup"><span data-stu-id="34c39-151">Gen 0</span></span> |     <span data-ttu-id="34c39-152">GEN 1</span><span class="sxs-lookup"><span data-stu-id="34c39-152">Gen 1</span></span> |     <span data-ttu-id="34c39-153">Génération 2</span><span class="sxs-lookup"><span data-stu-id="34c39-153">Gen 2</span></span> | <span data-ttu-id="34c39-154">Allocated</span><span class="sxs-lookup"><span data-stu-id="34c39-154">Allocated</span></span> |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    <span data-ttu-id="34c39-155">HIÉRARCHIE</span><span class="sxs-lookup"><span data-stu-id="34c39-155">TPH</span></span> | <span data-ttu-id="34c39-156">132,3 ms</span><span class="sxs-lookup"><span data-stu-id="34c39-156">132.3 ms</span></span> | <span data-ttu-id="34c39-157">2,29 ms</span><span class="sxs-lookup"><span data-stu-id="34c39-157">2.29 ms</span></span> | <span data-ttu-id="34c39-158">2,03 MS</span><span class="sxs-lookup"><span data-stu-id="34c39-158">2.03 ms</span></span> | <span data-ttu-id="34c39-159">8000,0000</span><span class="sxs-lookup"><span data-stu-id="34c39-159">8000.0000</span></span> | <span data-ttu-id="34c39-160">3000,0000</span><span class="sxs-lookup"><span data-stu-id="34c39-160">3000.0000</span></span> | <span data-ttu-id="34c39-161">1250,0000</span><span class="sxs-lookup"><span data-stu-id="34c39-161">1250.0000</span></span> |  <span data-ttu-id="34c39-162">44,49 MO</span><span class="sxs-lookup"><span data-stu-id="34c39-162">44.49 MB</span></span> |
|    <span data-ttu-id="34c39-163">TPT</span><span class="sxs-lookup"><span data-stu-id="34c39-163">TPT</span></span> | <span data-ttu-id="34c39-164">201,3 ms</span><span class="sxs-lookup"><span data-stu-id="34c39-164">201.3 ms</span></span> | <span data-ttu-id="34c39-165">3,32 ms</span><span class="sxs-lookup"><span data-stu-id="34c39-165">3.32 ms</span></span> | <span data-ttu-id="34c39-166">3,10 ms</span><span class="sxs-lookup"><span data-stu-id="34c39-166">3.10 ms</span></span> | <span data-ttu-id="34c39-167">9000,0000</span><span class="sxs-lookup"><span data-stu-id="34c39-167">9000.0000</span></span> | <span data-ttu-id="34c39-168">4000,0000</span><span class="sxs-lookup"><span data-stu-id="34c39-168">4000.0000</span></span> |         - |  <span data-ttu-id="34c39-169">61,84 MO</span><span class="sxs-lookup"><span data-stu-id="34c39-169">61.84 MB</span></span> |

<span data-ttu-id="34c39-170">Comme vous pouvez le voir, TPH est beaucoup plus efficace que TPT pour ce scénario.</span><span class="sxs-lookup"><span data-stu-id="34c39-170">As can be seen, TPH is considerably more efficient than TPT for this scenario.</span></span> <span data-ttu-id="34c39-171">Notez que les résultats réels dépendent toujours de la requête spécifique en cours d’exécution et du nombre de tables dans la hiérarchie, afin que les autres requêtes puissent présenter un écart de performances différent. vous êtes encouragé à utiliser ce code d’évaluation comme modèle pour tester d’autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="34c39-171">Note that actual results always depend on the specific query being executed and the number of tables in the hierarchy, so other queries may show a different performance gap; you're encouraged to use this benchmark code as a template for testing other queries.</span></span>
