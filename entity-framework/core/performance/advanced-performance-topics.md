---
title: Rubriques avancées sur les performances
description: Rubriques avancées sur les performances de Entity Framework Core
author: rick-anderson
ms.author: riande
ms.date: 12/9/2020
uid: core/performance/advanced-performance-topics
ms.openlocfilehash: 3c0340e1b36cbbb96d23db0633cb2eebc04dd970
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657831"
---
# <a name="advanced-performance-topics"></a><span data-ttu-id="8b309-103">Rubriques avancées sur les performances</span><span class="sxs-lookup"><span data-stu-id="8b309-103">Advanced Performance Topics</span></span>

## <a name="dbcontext-pooling"></a><span data-ttu-id="8b309-104">Regroupement DbContext</span><span class="sxs-lookup"><span data-stu-id="8b309-104">DbContext pooling</span></span>

<span data-ttu-id="8b309-105">`AddDbContextPool` active le regroupement d' `DbContext` instances.</span><span class="sxs-lookup"><span data-stu-id="8b309-105">`AddDbContextPool` enables pooling of `DbContext` instances.</span></span> <span data-ttu-id="8b309-106">Le regroupement de contexte peut augmenter le débit dans des scénarios à grande échelle tels que les serveurs Web en réutilisant des instances de contexte, plutôt que de créer des instances pour chaque demande.</span><span class="sxs-lookup"><span data-stu-id="8b309-106">Context pooling can increase throughput in high-scale scenarios such as web servers by reusing context instances, rather than creating new instances for each request.</span></span>

<span data-ttu-id="8b309-107">Le modèle typique d’une application ASP.NET Core utilisant EF Core implique l’inscription d’un type personnalisé dans <xref:Microsoft.EntityFrameworkCore.DbContext> le conteneur d' [injection de dépendances](/aspnet/core/fundamentals/dependency-injection) et l’obtention d’instances de ce type par le biais de paramètres de constructeur dans les contrôleurs ou les Razor pages.</span><span class="sxs-lookup"><span data-stu-id="8b309-107">The typical pattern in an ASP.NET Core app using EF Core involves registering a custom <xref:Microsoft.EntityFrameworkCore.DbContext> type into the [dependency injection](/aspnet/core/fundamentals/dependency-injection) container and obtaining instances of that type through constructor parameters in controllers or Razor Pages.</span></span> <span data-ttu-id="8b309-108">À l’aide de l’injection de constructeur, une nouvelle instance de contexte est créée pour chaque requête.</span><span class="sxs-lookup"><span data-stu-id="8b309-108">Using constructor injection, a new context instance is created for each request.</span></span>

<span data-ttu-id="8b309-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> active un pool d’instances de contexte réutilisables.</span><span class="sxs-lookup"><span data-stu-id="8b309-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> enables a pool of reusable context instances.</span></span> <span data-ttu-id="8b309-110">Pour utiliser le regroupement de contexte, utilisez la `AddDbContextPool` méthode au lieu de lors de l' `AddDbContext` inscription du service :</span><span class="sxs-lookup"><span data-stu-id="8b309-110">To use context pooling, use the `AddDbContextPool` method instead of `AddDbContext` during service registration:</span></span>

```csharp
services.AddDbContextPool<BloggingContext>(
    options => options.UseSqlServer(connectionString));
```

<span data-ttu-id="8b309-111">Lorsque `AddDbContextPool` est utilisé, au moment où une instance de contexte est demandée, EF vérifie d’abord si une instance est disponible dans le pool.</span><span class="sxs-lookup"><span data-stu-id="8b309-111">When `AddDbContextPool` is used, at the time a context instance is requested, EF first checks if there is an instance available in the pool.</span></span> <span data-ttu-id="8b309-112">Une fois finalisé le traitement de la demande, tout état sur l’instance est réinitialisé et l’instance elle-même est retournée au pool.</span><span class="sxs-lookup"><span data-stu-id="8b309-112">Once the request processing finalizes, any state on the instance is reset and the instance is itself returned to the pool.</span></span>

<span data-ttu-id="8b309-113">Ce concept est similaire à celui de l’utilisation du regroupement de connexions dans les fournisseurs ADO.NET et présente l’avantage d’enregistrer un certain coût d’initialisation de l’instance de contexte.</span><span class="sxs-lookup"><span data-stu-id="8b309-113">This is conceptually similar to how connection pooling operates in ADO.NET providers and has the advantage of saving some of the cost of initialization of the context instance.</span></span>

<span data-ttu-id="8b309-114">Le `poolSize` paramètre de <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> définit le nombre maximal d’instances conservées par le pool.</span><span class="sxs-lookup"><span data-stu-id="8b309-114">The `poolSize` parameter of <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> sets the maximum number of instances retained by the pool.</span></span> <span data-ttu-id="8b309-115">Une fois que `poolSize` est dépassé, les nouvelles instances de contexte ne sont pas mises en cache et EF revient au comportement de non-regroupement de la création d’instances à la demande.</span><span class="sxs-lookup"><span data-stu-id="8b309-115">Once `poolSize` is exceeded, new context instances are not cached and  EF falls back to the non-pooling behavior of creating instances on demand.</span></span>

### <a name="limitations"></a><span data-ttu-id="8b309-116">Limites</span><span class="sxs-lookup"><span data-stu-id="8b309-116">Limitations</span></span>

<span data-ttu-id="8b309-117">Les applications doivent être profilées et testées pour montrer que l’initialisation du contexte est un coût significatif.</span><span class="sxs-lookup"><span data-stu-id="8b309-117">Apps should be profiled and tested to show that context initialization is a significant cost.</span></span>

<span data-ttu-id="8b309-118">`AddDbContextPool` présente quelques limitations sur ce qui peut être fait dans la `OnConfiguring` méthode du contexte.</span><span class="sxs-lookup"><span data-stu-id="8b309-118">`AddDbContextPool` has a few limitations on what can be done in the `OnConfiguring` method of the context.</span></span>

> [!WARNING]
> <span data-ttu-id="8b309-119">Évitez d’utiliser le regroupement de contexte dans les applications qui maintiennent l’État.</span><span class="sxs-lookup"><span data-stu-id="8b309-119">Avoid using context pooling in apps that maintain state.</span></span> <span data-ttu-id="8b309-120">Par exemple, les champs privés dans le contexte qui ne doivent pas être partagés entre les requêtes.</span><span class="sxs-lookup"><span data-stu-id="8b309-120">For example, private fields in the context that shouldn't be shared across requests.</span></span> <span data-ttu-id="8b309-121">EF Core réinitialise uniquement l’État qu’il reconnaît avant d’ajouter une instance de contexte au pool.</span><span class="sxs-lookup"><span data-stu-id="8b309-121">EF Core only resets the state that it is aware of before adding a context instance to the pool.</span></span>

<span data-ttu-id="8b309-122">Le regroupement de contexte fonctionne en réutilisant la même instance de contexte entre les requêtes.</span><span class="sxs-lookup"><span data-stu-id="8b309-122">Context pooling works by reusing the same context instance across requests.</span></span> <span data-ttu-id="8b309-123">Cela signifie qu’elle est enregistrée en tant que [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) en termes de l’instance elle-même afin de pouvoir être persistante.</span><span class="sxs-lookup"><span data-stu-id="8b309-123">This means that it's effectively registered as a [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) in terms of the instance itself so that it's able to persist.</span></span>

<span data-ttu-id="8b309-124">Le regroupement de contexte est destiné aux scénarios dans lesquels la configuration de contexte, qui comprend les services résolus, est fixée entre les demandes.</span><span class="sxs-lookup"><span data-stu-id="8b309-124">Context pooling is intended for scenarios where the context configuration, which includes services resolved, is fixed between requests.</span></span> <span data-ttu-id="8b309-125">Dans les cas où des services [délimités](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) sont requis ou si la configuration doit être modifiée, n’utilisez pas le regroupement.</span><span class="sxs-lookup"><span data-stu-id="8b309-125">For cases where [Scoped](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) services are required, or configuration needs to be changed, don't use pooling.</span></span> <span data-ttu-id="8b309-126">Le gain de performances par rapport au regroupement est généralement négligeable, sauf dans les scénarios hautement optimisés.</span><span class="sxs-lookup"><span data-stu-id="8b309-126">The performance gain from pooling is usually negligible except in highly optimized scenarios.</span></span>

## <a name="query-caching-and-parameterization"></a><span data-ttu-id="8b309-127">Mise en cache et paramétrage des requêtes</span><span class="sxs-lookup"><span data-stu-id="8b309-127">Query caching and parameterization</span></span>

<span data-ttu-id="8b309-128">Quand EF reçoit une arborescence de requêtes LINQ pour l’exécution, il doit d’abord « compiler » cette arborescence dans une requête SQL.</span><span class="sxs-lookup"><span data-stu-id="8b309-128">When EF receives a LINQ query tree for execution, it must first "compile" that tree into a SQL query.</span></span> <span data-ttu-id="8b309-129">Étant donné qu’il s’agit d’un processus lourd, EF met en cache les requêtes en fonction de la *forme* d’arborescence de requête : les requêtes avec la même structure réutilisent les sorties de compilation mises en cache en interne et peuvent ignorer la compilation répétée.</span><span class="sxs-lookup"><span data-stu-id="8b309-129">Because this is a heavy process, EF caches queries by the query tree *shape*: queries with the same structure reuse internally-cached compilation outputs, and can skip repeated compilation.</span></span> <span data-ttu-id="8b309-130">Les différentes requêtes peuvent toujours faire référence à des *valeurs* différentes, mais tant que ces valeurs sont paramétrées correctement, la structure est la même et la mise en cache fonctionne correctement.</span><span class="sxs-lookup"><span data-stu-id="8b309-130">The different queries may still reference different *values*, but as long as these values are properly parameterized, the structure is the same and caching will function properly.</span></span>

<span data-ttu-id="8b309-131">Considérez les deux requêtes suivantes :</span><span class="sxs-lookup"><span data-stu-id="8b309-131">Consider the following two queries:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithConstants)]

<span data-ttu-id="8b309-132">Étant donné que les arborescences d’expressions contiennent des constantes différentes, l’arborescence d’expression diffère et chacune de ces requêtes est compilée séparément par EF Core.</span><span class="sxs-lookup"><span data-stu-id="8b309-132">Since the expression trees contains different constants, the expression tree differs and each of these queries will be compiled separately by EF Core.</span></span> <span data-ttu-id="8b309-133">En outre, chaque requête produit une commande SQL légèrement différente :</span><span class="sxs-lookup"><span data-stu-id="8b309-133">In addition, each query produces a slightly different SQL command:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog1'

SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog2'
```

<span data-ttu-id="8b309-134">Étant donné que le SQL diffère, votre serveur de base de données devra probablement créer un plan de requête pour les deux requêtes, plutôt que de réutiliser le même plan.</span><span class="sxs-lookup"><span data-stu-id="8b309-134">Because the SQL differs, your database server will likely also need to produce a query plan for both queries, rather than reusing the same plan.</span></span>

<span data-ttu-id="8b309-135">Une petite modification de vos requêtes peut modifier considérablement les choses :</span><span class="sxs-lookup"><span data-stu-id="8b309-135">A small modification to your queries can change things considerably:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithParameterization)]

<span data-ttu-id="8b309-136">Étant donné que le nom du blog est maintenant *paramétré*, les deux requêtes ont la même forme d’arborescence et EF ne doit être compilé qu’une seule fois.</span><span class="sxs-lookup"><span data-stu-id="8b309-136">Since the blog name is now *parameterized*, both queries have the same tree shape, and EF only needs to be compiled once.</span></span> <span data-ttu-id="8b309-137">Le SQL produit est également paramétré, ce qui permet à la base de données de réutiliser le même plan de requête :</span><span class="sxs-lookup"><span data-stu-id="8b309-137">The SQL produced is also parameterized, allowing the database to reuse the same query plan:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = @__blogName_0
```

<span data-ttu-id="8b309-138">Notez qu’il n’est pas nécessaire de paramétrer chaque requête. il est tout à fait parfait d’avoir certaines requêtes avec des constantes, et en effet, les bases de données (et EF) peuvent parfois effectuer une certaine optimisation autour des constantes, ce qui n’est pas possible lorsque la requête est paramétrée.</span><span class="sxs-lookup"><span data-stu-id="8b309-138">Note that there is no need to parameterize each and every query: it's perfectly fine to have some queries with constants, and indeed, databases (and EF) can sometimes perform certain optimization around constants which aren't possible when the query is parameterized.</span></span> <span data-ttu-id="8b309-139">Consultez la section sur les [requêtes construites dynamiquement](#dynamically-constructed-queries) pour obtenir un exemple où le paramétrage approprié est essentiel.</span><span class="sxs-lookup"><span data-stu-id="8b309-139">See the section on [dynamically-constructed queries](#dynamically-constructed-queries) for an example where proper parameterization is crucial.</span></span>

> [!NOTE]
> <span data-ttu-id="8b309-140">Les [compteurs d’événements](xref:core/logging-events-diagnostics/event-counters) de EF Core signalent le taux d’accès au cache des requêtes.</span><span class="sxs-lookup"><span data-stu-id="8b309-140">EF Core's [event counters](xref:core/logging-events-diagnostics/event-counters) report the Query Cache Hit Rate.</span></span> <span data-ttu-id="8b309-141">Dans une application normale, ce compteur atteint 100% juste après le démarrage du programme, une fois que la plupart des requêtes ont été exécutées au moins une fois.</span><span class="sxs-lookup"><span data-stu-id="8b309-141">In a normal application, this counter reaches 100% soon after program startup, once most queries have executed at least once.</span></span> <span data-ttu-id="8b309-142">Si ce compteur reste stable sous 100%, cela indique que votre application peut effectuer une opération qui met un terme au cache des requêtes. il est donc judicieux de l’étudier.</span><span class="sxs-lookup"><span data-stu-id="8b309-142">If this counter remains stable below 100%, that is an indication that your application may be doing something which defeats the query cache - it's a good idea to investigate that.</span></span>

> [!NOTE]
> <span data-ttu-id="8b309-143">La façon dont la base de données gère les plans de requête de cache dépend de la base de données.</span><span class="sxs-lookup"><span data-stu-id="8b309-143">How the database manages caches query plans is database-dependent.</span></span> <span data-ttu-id="8b309-144">Par exemple, SQL Server gère implicitement un cache de plan de requête LRU, alors que PostgreSQL ne le fait pas (mais les instructions préparées peuvent produire un effet de fin très similaire).</span><span class="sxs-lookup"><span data-stu-id="8b309-144">For example, SQL Server implicitly maintains an LRU query plan cache, whereas PostgreSQL does not (but prepared statements can produce a very similar end effect).</span></span> <span data-ttu-id="8b309-145">Pour plus d’informations, consultez la documentation de votre base de données.</span><span class="sxs-lookup"><span data-stu-id="8b309-145">Consult your database documentation for more details.</span></span>

## <a name="dynamically-constructed-queries"></a><span data-ttu-id="8b309-146">Requêtes construites dynamiquement</span><span class="sxs-lookup"><span data-stu-id="8b309-146">Dynamically-constructed queries</span></span>

<span data-ttu-id="8b309-147">Dans certains cas, il est nécessaire de construire dynamiquement des requêtes LINQ au lieu de les spécifier dans le code source.</span><span class="sxs-lookup"><span data-stu-id="8b309-147">In some situations, it is necessary to dynamically construct LINQ queries rather than specifying them outright in source code.</span></span> <span data-ttu-id="8b309-148">Cela peut se produire, par exemple, dans un site Web qui reçoit des détails de requête arbitraires d’un client, avec des opérateurs de requête en cours d’achèvement (tri, filtrage, pagination...). En principe, si vous avez terminé correctement, les requêtes construites dynamiquement peuvent être aussi efficaces que les requêtes régulières (bien qu’il ne soit pas possible d’utiliser l’optimisation de requête compilée avec des requêtes dynamiques).</span><span class="sxs-lookup"><span data-stu-id="8b309-148">This can happen, for example, in a website which receives arbitrary query details from a client, with open-ended query operators (sorting, filtering, paging...). In principle, if done correctly, dynamically-constructed queries can be just as efficient as regular ones (although it's not possible to use the compiled query optimization with dynamic queries).</span></span> <span data-ttu-id="8b309-149">Toutefois, dans la pratique, il s’agit souvent de la source de problèmes de performances, car il est facile de produire accidentellement des arborescences d’expressions avec des formes qui diffèrent à chaque fois.</span><span class="sxs-lookup"><span data-stu-id="8b309-149">In practice, however, they are frequently the source of performance issues, since it's easy to accidentally produce expression trees with shapes that differ every time.</span></span>

<span data-ttu-id="8b309-150">L’exemple suivant utilise deux techniques pour construire dynamiquement une requête ; Nous ajoutons un `Where` opérateur à la requête uniquement si le paramètre donné n’a pas la valeur null.</span><span class="sxs-lookup"><span data-stu-id="8b309-150">The following example uses two techniques to dynamically construct a query; we add a `Where` operator to the query only if the given parameter is not null.</span></span> <span data-ttu-id="8b309-151">Notez qu’il ne s’agit pas d’un bon cas d’utilisation pour la construction dynamique d’une requête, mais que nous l’utilisons pour des raisons de simplicité :</span><span class="sxs-lookup"><span data-stu-id="8b309-151">Note that this isn't a good use case for dynamically constructing a query - but we're using it for simplicity:</span></span>

### <a name="with-constant"></a>[<span data-ttu-id="8b309-152">Avec constante</span><span class="sxs-lookup"><span data-stu-id="8b309-152">With constant</span></span>](#tab/with-constant)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithConstant&highlight=14-24)]

### <a name="with-parameter"></a>[<span data-ttu-id="8b309-153">Avec le paramètre</span><span class="sxs-lookup"><span data-stu-id="8b309-153">With parameter</span></span>](#tab/with-parameter)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithParameter&highlight=14)]

***

<span data-ttu-id="8b309-154">L’évaluation de ces deux techniques donne les résultats suivants :</span><span class="sxs-lookup"><span data-stu-id="8b309-154">Benchmarking these two techniques gives the following results:</span></span>

|        <span data-ttu-id="8b309-155">Méthode</span><span class="sxs-lookup"><span data-stu-id="8b309-155">Method</span></span> |       <span data-ttu-id="8b309-156">Moyenne</span><span class="sxs-lookup"><span data-stu-id="8b309-156">Mean</span></span> |    <span data-ttu-id="8b309-157">Erreur</span><span class="sxs-lookup"><span data-stu-id="8b309-157">Error</span></span> |    <span data-ttu-id="8b309-158">StdDev</span><span class="sxs-lookup"><span data-stu-id="8b309-158">StdDev</span></span> |   <span data-ttu-id="8b309-159">Génération 0</span><span class="sxs-lookup"><span data-stu-id="8b309-159">Gen 0</span></span> |  <span data-ttu-id="8b309-160">GEN 1</span><span class="sxs-lookup"><span data-stu-id="8b309-160">Gen 1</span></span> | <span data-ttu-id="8b309-161">Génération 2</span><span class="sxs-lookup"><span data-stu-id="8b309-161">Gen 2</span></span> | <span data-ttu-id="8b309-162">Allocated</span><span class="sxs-lookup"><span data-stu-id="8b309-162">Allocated</span></span> |
|-------------- |-----------:|---------:|----------:|--------:|-------:|------:|----------:|
|  <span data-ttu-id="8b309-163">WithConstant</span><span class="sxs-lookup"><span data-stu-id="8b309-163">WithConstant</span></span> | <span data-ttu-id="8b309-164">1 096,7 US</span><span class="sxs-lookup"><span data-stu-id="8b309-164">1,096.7 us</span></span> | <span data-ttu-id="8b309-165">12,54 US</span><span class="sxs-lookup"><span data-stu-id="8b309-165">12.54 us</span></span> |  <span data-ttu-id="8b309-166">11,12 US</span><span class="sxs-lookup"><span data-stu-id="8b309-166">11.12 us</span></span> | <span data-ttu-id="8b309-167">13,6719</span><span class="sxs-lookup"><span data-stu-id="8b309-167">13.6719</span></span> | <span data-ttu-id="8b309-168">1,9531</span><span class="sxs-lookup"><span data-stu-id="8b309-168">1.9531</span></span> |     - |  <span data-ttu-id="8b309-169">83,91 KO</span><span class="sxs-lookup"><span data-stu-id="8b309-169">83.91 KB</span></span> |
| <span data-ttu-id="8b309-170">WithParameter</span><span class="sxs-lookup"><span data-stu-id="8b309-170">WithParameter</span></span> |   <span data-ttu-id="8b309-171">570,8 US</span><span class="sxs-lookup"><span data-stu-id="8b309-171">570.8 us</span></span> | <span data-ttu-id="8b309-172">42,43 US</span><span class="sxs-lookup"><span data-stu-id="8b309-172">42.43 us</span></span> | <span data-ttu-id="8b309-173">124,43 US</span><span class="sxs-lookup"><span data-stu-id="8b309-173">124.43 us</span></span> |  <span data-ttu-id="8b309-174">5,8594</span><span class="sxs-lookup"><span data-stu-id="8b309-174">5.8594</span></span> |      - |     - |  <span data-ttu-id="8b309-175">37,16 KO</span><span class="sxs-lookup"><span data-stu-id="8b309-175">37.16 KB</span></span> |

<span data-ttu-id="8b309-176">Même si la différence des sous-millisecondes semble petite, gardez à l’esprit que la version constante pollue en permanence le cache et provoque la recompilation d’autres requêtes, en les ralentissant également.</span><span class="sxs-lookup"><span data-stu-id="8b309-176">Even if the sub-millisecond difference seems small, keep in mind that the constant version continuously pollutes the cache and causes other queries to be re-compiled, slowing them down as well.</span></span>

> [!NOTE]
> <span data-ttu-id="8b309-177">Évitez de créer des requêtes avec l’API d’arborescence d’expression, sauf si vous en avez vraiment besoin.</span><span class="sxs-lookup"><span data-stu-id="8b309-177">Avoid constructing queries with the expression tree API unless you really need to.</span></span> <span data-ttu-id="8b309-178">Hormis la complexité de l’API, il est très facile de provoquer par inadvertance de sérieux problèmes de performances lors de leur utilisation.</span><span class="sxs-lookup"><span data-stu-id="8b309-178">Aside from the API's complexity, it's very easy to inadvertently cause significant performance issues when using them.</span></span>
