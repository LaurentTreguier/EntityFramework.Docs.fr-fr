---
title: Présentation des performances-EF Core
description: Guide des performances pour l’utilisation efficace de Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/miscellaneous/performance/index
ms.openlocfilehash: 14400d81ea3c93e2ebf40e8e585a457abf31478f
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657811"
---
# <a name="introduction-to-performance"></a><span data-ttu-id="621fb-103">Présentation des performances</span><span class="sxs-lookup"><span data-stu-id="621fb-103">Introduction to Performance</span></span>

<span data-ttu-id="621fb-104">Les performances de la base de données sont un sujet vaste et complexe, couvrant une pile complète de composants : la base de données, la mise en réseau, le pilote de base de données et les couches d’accès aux données, telles que les EF Core.</span><span class="sxs-lookup"><span data-stu-id="621fb-104">Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core.</span></span> <span data-ttu-id="621fb-105">Bien que les couches de haut niveau et O/RMs, comme EF Core simplifier considérablement le développement d’applications et améliorer la maintenabilité, elles peuvent parfois être opaques, masquant des détails internes critiques, tels que le SQL en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="621fb-105">While high-level layers and O/RMs such as EF Core considerably simplify application development and improve maintainability, they can sometimes be opaque, hiding performance-critical internal details such as the SQL being executed.</span></span> <span data-ttu-id="621fb-106">Cette section tente de fournir une vue d’ensemble de la façon d’obtenir de bonnes performances avec EF Core, et d’éviter les pièges courants qui peuvent dégrader les performances de l’application.</span><span class="sxs-lookup"><span data-stu-id="621fb-106">This section attempts to provide an overview of how to achieve good performance with EF Core, and how to avoid common pitfalls which can degrade application performance.</span></span>

## <a name="identify-bottlenecks-and-measure-measure-measure"></a><span data-ttu-id="621fb-107">Identifier les goulots d’étranglement et mesurer, mesurer, mesurer</span><span class="sxs-lookup"><span data-stu-id="621fb-107">Identify bottlenecks and measure, measure, measure</span></span>

<span data-ttu-id="621fb-108">Comme toujours avec les performances, il est important de ne pas vous prépasser de l’optimisation sans les données qui présentent un problème. comme c’est le cas de la bonne Knuth Donald, « optimisation prématurée est la racine de tout le mal ».</span><span class="sxs-lookup"><span data-stu-id="621fb-108">As always with performance, it's important not to rush into optimization without data showing a problem; as the great Donald Knuth once said, "Premature optimization is the root of all evil".</span></span> <span data-ttu-id="621fb-109">La section [diagnostic des performances](xref:core/performance/performance-diagnosis) aborde les différentes façons de comprendre où votre application consacre du temps à la logique de la base de données et comment identifier les zones problématiques spécifiques.</span><span class="sxs-lookup"><span data-stu-id="621fb-109">The [performance diagnosis](xref:core/performance/performance-diagnosis) section discusses various ways to understand where your application is spending time in database logic, and how to pinpoint specific problematic areas.</span></span> <span data-ttu-id="621fb-110">Une fois qu’une requête lente a été identifiée, les solutions peuvent être prises en compte : votre base de données n’a-t-elle pas d’index ?</span><span class="sxs-lookup"><span data-stu-id="621fb-110">Once a slow query has been identified, solutions can be considered: is your database missing an index?</span></span> <span data-ttu-id="621fb-111">Devez-vous essayer d’autres modèles d’interrogation ?</span><span class="sxs-lookup"><span data-stu-id="621fb-111">Should you try out other querying patterns?</span></span>

<span data-ttu-id="621fb-112">Toujours évaluer votre code et vos alternatives possibles-la section diagnostic des performances contient un exemple de test avec BenchmarkDotNet, que vous pouvez utiliser comme modèle pour vos propres tests d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="621fb-112">Always benchmark your code and possible alternatives yourself - the performance diagnosis section contains a sample benchmark with BenchmarkDotNet, which you can use as a template for your own benchmarks.</span></span> <span data-ttu-id="621fb-113">Ne partez pas du principe que les bancs d’essai publics généraux s’appliquent à votre cas d’utilisation spécifique. un grand nombre de facteurs tels que la latence de la base de données, la complexité des requêtes et les quantités réelles des données dans vos tables peuvent avoir un impact important sur la solution la plus appropriée.</span><span class="sxs-lookup"><span data-stu-id="621fb-113">Don't assume that general, public benchmarks apply as-is to your specific use-case; a variety of factors such as database latency, query complexity and actual data amounts in your tables can have a profound effect on which solution is best.</span></span> <span data-ttu-id="621fb-114">Par exemple, de nombreux tests publics sont effectués dans des conditions de mise en réseau idéales, où la latence à la base de données est presque nulle et avec des requêtes extrêmement claires qui ne nécessitent pas de traitement (ou d’e/s de disque) côté base de données.</span><span class="sxs-lookup"><span data-stu-id="621fb-114">For example, many public benchmarks are carried out in ideal networking conditions, where latency to the database is almost zero, and with extremely light queries which hardly require any processing (or disk I/O) on the database side.</span></span> <span data-ttu-id="621fb-115">Bien qu’elles soient utiles pour comparer les surcharges d’exécution des différentes couches d’accès aux données, les différences qu’elles révèlent sont généralement négligeables dans une application réelle, où la base de données effectue le travail réel et la latence à la base de données est un facteur de performances significatif.</span><span class="sxs-lookup"><span data-stu-id="621fb-115">While these are valuable for comparing the runtime overheads of different data access layers, the differences they reveal usually prove to be negligible in a real-world application, where the database performs actual work and latency to the database is a significant perf factor.</span></span>

## <a name="aspects-of-data-access-performance"></a><span data-ttu-id="621fb-116">Aspects des performances d’accès aux données</span><span class="sxs-lookup"><span data-stu-id="621fb-116">Aspects of data access performance</span></span>

<span data-ttu-id="621fb-117">Les performances globales de l’accès aux données peuvent être décomposées dans les grandes catégories suivantes :</span><span class="sxs-lookup"><span data-stu-id="621fb-117">Overall data access performance can be broken down into the following broad categories:</span></span>

* <span data-ttu-id="621fb-118">**Performances de base de données pures**.</span><span class="sxs-lookup"><span data-stu-id="621fb-118">**Pure database performance**.</span></span> <span data-ttu-id="621fb-119">Avec la base de données relationnelle, EF traduit les requêtes LINQ de l’application en instructions SQL exécutées par la base de données ; ces instructions SQL elles-mêmes peuvent s’exécuter plus ou moins efficacement.</span><span class="sxs-lookup"><span data-stu-id="621fb-119">With relational database, EF translates the application's LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently.</span></span> <span data-ttu-id="621fb-120">L’index approprié dans le bon endroit peut faire la différence dans les performances de SQL, ou la réécriture de votre requête LINQ peut rendre EF générer une meilleure requête SQL.</span><span class="sxs-lookup"><span data-stu-id="621fb-120">The right index in the right place can make a world of difference in SQL performance, or rewriting your LINQ query may make EF generate a better SQL query.</span></span>
* <span data-ttu-id="621fb-121">**Transfert de données réseau**.</span><span class="sxs-lookup"><span data-stu-id="621fb-121">**Network data transfer**.</span></span> <span data-ttu-id="621fb-122">Comme pour n’importe quel système de mise en réseau, il est important de limiter la quantité de données entrantes et sortantes sur le câble.</span><span class="sxs-lookup"><span data-stu-id="621fb-122">As with any networking system, it's important to limit the amount of data going back and forth on the wire.</span></span> <span data-ttu-id="621fb-123">Cela vous permet de vous assurer que vous envoyez et chargez uniquement les données dont vous aurez besoin, mais également d’éviter l’effet « explosion cartésien » lors du chargement des entités associées.</span><span class="sxs-lookup"><span data-stu-id="621fb-123">This covers making sure that you only send and load data which you're actually going to need, but also avoiding the so-called "cartesian explosion" effect when loading related entities.</span></span>
* <span data-ttu-id="621fb-124">**Allers-retours réseau**.</span><span class="sxs-lookup"><span data-stu-id="621fb-124">**Network roundtrips**.</span></span> <span data-ttu-id="621fb-125">Au-delà de la quantité de données entrantes et sortantes, les boucles réseau, depuis le temps nécessaire à l’exécution d’une requête dans la base de données, peuvent être comprises entre les paquets de temps qui transitent entre votre application et votre base de données.</span><span class="sxs-lookup"><span data-stu-id="621fb-125">Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between your application and your database.</span></span> <span data-ttu-id="621fb-126">La surcharge de bouclage dépend principalement de votre environnement. plus votre serveur de base de données est éloigné, plus la latence est élevée et sont coûteuses chaque aller-retour.</span><span class="sxs-lookup"><span data-stu-id="621fb-126">Roundtrip overhead heavily depends on your environment; the further away your database server is, the high the latency and the costlier each roundtrip.</span></span> <span data-ttu-id="621fb-127">Avec l’avènement du Cloud, les applications se retrouvent plus loin dans la base de données et les applications « bavardes » qui effectuent un trop grand nombre d’allers-retours avec dégradation des performances.</span><span class="sxs-lookup"><span data-stu-id="621fb-127">With the advent of the cloud, applications increasingly find themselves further away from the database, and "chatty" applications which perform too many roundtrips experience degraded performance.</span></span> <span data-ttu-id="621fb-128">Par conséquent, il est important de comprendre exactement quand votre application contacte la base de données, le nombre d’allers-retours qu’elle effectue et si ce nombre peut être réduit.</span><span class="sxs-lookup"><span data-stu-id="621fb-128">Therefore, it's important to understand exactly when your application contacts the database, how many roundtrips it performs, and whether that number can be minimized them.</span></span>
* <span data-ttu-id="621fb-129">**Charge du runtime EF**.</span><span class="sxs-lookup"><span data-stu-id="621fb-129">**EF runtime overhead**.</span></span> <span data-ttu-id="621fb-130">Enfin, EF ajoute une surcharge de Runtime aux opérations de base de données : EF doit compiler vos requêtes à partir de LINQ to SQL (bien que cela ne soit normalement effectué qu’une seule fois), le suivi des modifications ajoute une surcharge (mais peut être désactivée), etc. Dans la pratique, la surcharge EF pour les applications réelles est susceptible d’être négligeable dans la plupart des cas, car la durée d’exécution des requêtes dans la base de données et la latence du réseau dominent la durée totale. mais il est important de comprendre ce que sont vos options et comment éviter certains pièges.</span><span class="sxs-lookup"><span data-stu-id="621fb-130">Finally, EF itself adds some runtime overhead to database operations: EF needs to compile your queries from LINQ to SQL (although that should normally be done only once), change tracking adds some overhead (but can be disabled), etc. In practice, the EF overhead for real-world applications is likely to be negligible in most cases, as query execution time in the database and network latency dominate the total time; but it's important to understand what your options are and how to avoid some pitfalls.</span></span>

## <a name="know-whats-happening-under-the-hood"></a><span data-ttu-id="621fb-131">Découvrez ce qui se passe en coulisses</span><span class="sxs-lookup"><span data-stu-id="621fb-131">Know what's happening under the hood</span></span>

<span data-ttu-id="621fb-132">EF permet aux développeurs de se concentrer sur la logique métier en générant SQL, en matérialisé les résultats et en effectuant d’autres tâches.</span><span class="sxs-lookup"><span data-stu-id="621fb-132">EF allows developers to concentrate on business logic by generating SQL, materializing results, and performing other tasks.</span></span> <span data-ttu-id="621fb-133">Comme n’importe quelle couche ou abstraction, elle a également tendance à masquer ce qui se passe en coulisse, comme les requêtes SQL réelles en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="621fb-133">Like any layer or abstraction, it also tends to hide what's happening under-the-hood, such as the actual SQL queries being executed.</span></span> <span data-ttu-id="621fb-134">Les performances ne sont pas nécessairement un aspect essentiel de chaque application, mais dans les applications où c’est le cas, il est vital que le développeur comprenne ce que EF fait pour eux : inspecter les requêtes SQL sortantes, suivre les allers-retours pour vérifier que le problème N + 1 ne se produit pas, etc.</span><span class="sxs-lookup"><span data-stu-id="621fb-134">Performance isn't necessarily a critical aspect of every application out there, but in applications where it is, it is vital that the developer understand what EF is doing for them: inspect outgoing SQL queries, follow roundtrips to make sure the N+1 problem isn't occurring, etc.</span></span>

## <a name="cache-outside-the-database"></a><span data-ttu-id="621fb-135">Mise en cache en dehors de la base de données</span><span class="sxs-lookup"><span data-stu-id="621fb-135">Cache outside the database</span></span>

<span data-ttu-id="621fb-136">Enfin, le moyen le plus efficace d’interagir avec une base de données, est de ne pas interagir avec lui.</span><span class="sxs-lookup"><span data-stu-id="621fb-136">Finally, the most efficient way to interact with a database, is to not interact with it at all.</span></span> <span data-ttu-id="621fb-137">En d’autres termes, si l’accès à la base de données s’affiche comme un goulot d’étranglement au niveau des performances dans votre application, il peut être utile de mettre en cache certains résultats en dehors de la base de données, afin de réduire les demandes.</span><span class="sxs-lookup"><span data-stu-id="621fb-137">In other words, if database access shows up as a performance bottleneck in your application, it may be worthwhile to cache certain results outside of the database, so as to minimize requests.</span></span> <span data-ttu-id="621fb-138">Bien que la mise en cache augmente la complexité, il s’agit d’une partie essentielle de toute application évolutive : bien que la couche application puisse être facilement mise à l’échelle en ajoutant des serveurs supplémentaires pour gérer une charge accrue, la mise à l’échelle de la couche base de données est généralement beaucoup plus compliquée.</span><span class="sxs-lookup"><span data-stu-id="621fb-138">Although caching adds complexity, it is an especially crucial part of any scalable application: while the application tier can be easy scaled by adding additional servers to handle increased load, scaling the database tier is usually far more complicated.</span></span>
