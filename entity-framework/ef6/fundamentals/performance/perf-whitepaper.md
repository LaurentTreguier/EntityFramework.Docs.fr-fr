---
title: Considérations relatives aux performances pour EF4, EF5 et EF6-EF6
description: Considérations relatives aux performances pour les Entity Framework 4, 5 et 6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
uid: ef6/fundamentals/performance/perf-whitepaper
ms.openlocfilehash: 9d70eab61caace02f59f3c555ef416c45d4f8f45
ms.sourcegitcommit: 7c3939504bb9da3f46bea3443638b808c04227c2
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/09/2020
ms.locfileid: "89616175"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a><span data-ttu-id="cb5e9-103">Considérations relatives aux performances pour EF 4, 5 et 6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-103">Performance considerations for EF 4, 5, and 6</span></span>
<span data-ttu-id="cb5e9-104">Par David Obando, Eric Dettinger et autres</span><span class="sxs-lookup"><span data-stu-id="cb5e9-104">By David Obando, Eric Dettinger and others</span></span>

<span data-ttu-id="cb5e9-105">Publication : 2012 avril</span><span class="sxs-lookup"><span data-stu-id="cb5e9-105">Published: April 2012</span></span>

<span data-ttu-id="cb5e9-106">Dernière mise à jour : mai 2014</span><span class="sxs-lookup"><span data-stu-id="cb5e9-106">Last updated: May 2014</span></span>

------------------------------------------------------------------------

## <a name="1-introduction"></a><span data-ttu-id="cb5e9-107">1. Introduction</span><span class="sxs-lookup"><span data-stu-id="cb5e9-107">1. Introduction</span></span>

<span data-ttu-id="cb5e9-108">Les infrastructures de mappage objet-relationnel sont un moyen pratique de fournir une abstraction pour l’accès aux données dans une application orientée objet.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-108">Object-Relational Mapping frameworks are a convenient way to provide an abstraction for data access in an object-oriented application.</span></span> <span data-ttu-id="cb5e9-109">Pour les applications .NET, l’O/RM recommandé de Microsoft est Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-109">For .NET applications, Microsoft's recommended O/RM is Entity Framework.</span></span> <span data-ttu-id="cb5e9-110">Malgré toute abstraction, les performances peuvent devenir un problème.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-110">With any abstraction though, performance can become a concern.</span></span>

<span data-ttu-id="cb5e9-111">Ce livre blanc a été rédigé pour illustrer les considérations relatives aux performances lors du développement d’applications à l’aide de Entity Framework, afin de donner aux développeurs une idée des algorithmes internes Entity Framework qui peuvent affecter les performances et de fournir des conseils pour l’investigation et l’amélioration des performances dans leurs applications qui utilisent Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-111">This whitepaper was written to show the performance considerations when developing applications using Entity Framework, to give developers an idea of the Entity Framework internal algorithms that can affect performance, and to provide tips for investigation and improving performance in their applications that use Entity Framework.</span></span> <span data-ttu-id="cb5e9-112">Il existe un certain nombre de bonnes rubriques sur les performances déjà disponibles sur le Web et nous avons également essayé de pointer vers ces ressources dans la mesure du possible.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-112">There are a number of good topics on performance already available on the web, and we've also tried pointing to these resources where possible.</span></span>

<span data-ttu-id="cb5e9-113">Les performances sont un sujet délicat.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-113">Performance is a tricky topic.</span></span> <span data-ttu-id="cb5e9-114">Ce livre blanc est destiné à vous aider à prendre des décisions relatives aux performances de vos applications qui utilisent Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-114">This whitepaper is intended as a resource to help you make performance related decisions for your applications that use Entity Framework.</span></span> <span data-ttu-id="cb5e9-115">Nous avons inclus des mesures de test pour illustrer les performances, mais ces mesures ne sont pas conçues comme indicateurs absolus des performances que vous verrez dans votre application.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-115">We have included some test metrics to demonstrate performance, but these metrics aren't intended as absolute indicators of the performance you will see in your application.</span></span>

<span data-ttu-id="cb5e9-116">Pour des raisons pratiques, ce document suppose Entity Framework 4 s’exécute sous .NET 4,0 et Entity Framework 5 et 6 sont exécutés sous .NET 4,5.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-116">For practical purposes, this document assumes Entity Framework 4 is run under .NET 4.0 and Entity Framework 5 and 6 are run under .NET 4.5.</span></span> <span data-ttu-id="cb5e9-117">La plupart des améliorations de performances apportées à Entity Framework 5 résident dans les composants de base fournis avec .NET 4,5.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-117">Many of the performance improvements made for Entity Framework 5 reside within the core components that ship with .NET 4.5.</span></span>

<span data-ttu-id="cb5e9-118">Entity Framework 6 est une version hors bande et ne dépend pas des composants Entity Framework fournis avec .NET.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-118">Entity Framework 6 is an out of band release and does not depend on the Entity Framework components that ship with .NET.</span></span> <span data-ttu-id="cb5e9-119">Entity Framework 6 fonctionnent à la fois sur .NET 4,0 et .NET 4,5, et peuvent offrir un gain de performances considérable à ceux qui n’ont pas été mis à niveau à partir de .NET 4,0, mais qui veulent les derniers Entity Framework bits dans leur application.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-119">Entity Framework 6 work on both .NET 4.0 and .NET 4.5, and can offer a big performance benefit to those who haven’t upgraded from .NET 4.0 but want the latest Entity Framework bits in their application.</span></span> <span data-ttu-id="cb5e9-120">Lorsque ce document mentionne Entity Framework 6, il fait référence à la dernière version disponible au moment de la rédaction de cet article : version 6.1.0.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-120">When this document mentions Entity Framework 6, it refers to the latest version available at the time of this writing: version 6.1.0.</span></span>

## <a name="2-cold-vs-warm-query-execution"></a><span data-ttu-id="cb5e9-121">2. exécution des requêtes à froid et à chaud</span><span class="sxs-lookup"><span data-stu-id="cb5e9-121">2. Cold vs. Warm Query Execution</span></span>

<span data-ttu-id="cb5e9-122">La première fois qu’une requête est effectuée sur un modèle donné, le Entity Framework fait beaucoup de travail en arrière-plan pour charger et valider le modèle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-122">The very first time any query is made against a given model, the Entity Framework does a lot of work behind the scenes to load and validate the model.</span></span> <span data-ttu-id="cb5e9-123">Nous faisons souvent référence à cette première requête sous la forme d’une requête « à froid ».</span><span class="sxs-lookup"><span data-stu-id="cb5e9-123">We frequently refer to this first query as a "cold" query.</span></span><span data-ttu-id="cb5e9-124">Les requêtes supplémentaires sur un modèle déjà chargé sont appelées requêtes « chaudes » et sont beaucoup plus rapides.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-124">  Further queries against an already loaded model are known as "warm" queries, and are much faster.</span></span>

<span data-ttu-id="cb5e9-125">Examinons de plus haut niveau le temps consacré à l’exécution d’une requête à l’aide de Entity Framework, et voyons où les choses s’améliorent dans Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-125">Let’s take a high-level view of where time is spent when executing a query using Entity Framework, and see where things are improving in Entity Framework 6.</span></span>

<span data-ttu-id="cb5e9-126">**Exécution de la première requête-requête à froid**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-126">**First Query Execution – cold query**</span></span>

| <span data-ttu-id="cb5e9-127">Écritures utilisateur du code</span><span class="sxs-lookup"><span data-stu-id="cb5e9-127">Code User Writes</span></span>                                                                                     | <span data-ttu-id="cb5e9-128">Action</span><span class="sxs-lookup"><span data-stu-id="cb5e9-128">Action</span></span>                    | <span data-ttu-id="cb5e9-129">Impact sur les performances de EF4</span><span class="sxs-lookup"><span data-stu-id="cb5e9-129">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="cb5e9-130">Impact sur les performances de EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-130">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="cb5e9-131">Impact sur les performances de EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-131">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="cb5e9-132">Création de contexte</span><span class="sxs-lookup"><span data-stu-id="cb5e9-132">Context creation</span></span>          | <span data-ttu-id="cb5e9-133">Moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-133">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="cb5e9-134">Moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-134">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="cb5e9-135">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-135">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="cb5e9-136">Création d’une expression de requête</span><span class="sxs-lookup"><span data-stu-id="cb5e9-136">Query expression creation</span></span> | <span data-ttu-id="cb5e9-137">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-137">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="cb5e9-138">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-138">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="cb5e9-139">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-139">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="cb5e9-140">Exécution de requêtes LINQ</span><span class="sxs-lookup"><span data-stu-id="cb5e9-140">LINQ query execution</span></span>      | <span data-ttu-id="cb5e9-141">-Chargement des métadonnées : élevé mais mis en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-141">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="cb5e9-142">-Génération de vues : potentiellement très élevée mais mise en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-142">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="cb5e9-143">-Évaluation des paramètres : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-143">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="cb5e9-144">-Traduction de requête : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-144">- Query translation: Medium</span></span> <br/> <span data-ttu-id="cb5e9-145">-Génération de matérialise : moyenne mais mise en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-145">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="cb5e9-146">-Exécution de la requête de base de données : potentiellement élevé</span><span class="sxs-lookup"><span data-stu-id="cb5e9-146">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="cb5e9-147">+ Connection. Open</span><span class="sxs-lookup"><span data-stu-id="cb5e9-147">+ Connection.Open</span></span> <br/> <span data-ttu-id="cb5e9-148">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="cb5e9-148">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="cb5e9-149">+ DataReader. Read</span><span class="sxs-lookup"><span data-stu-id="cb5e9-149">+ DataReader.Read</span></span> <br/> <span data-ttu-id="cb5e9-150">Matérialisation d’objets : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-150">Object materialization: Medium</span></span> <br/> <span data-ttu-id="cb5e9-151">-Recherche d’identité : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-151">- Identity lookup: Medium</span></span> | <span data-ttu-id="cb5e9-152">-Chargement des métadonnées : élevé mais mis en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-152">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="cb5e9-153">-Génération de vues : potentiellement très élevée mais mise en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-153">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="cb5e9-154">-Évaluation des paramètres : faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-154">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="cb5e9-155">-Traduction de requête : moyenne mais mise en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-155">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="cb5e9-156">-Génération de matérialise : moyenne mais mise en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-156">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="cb5e9-157">-Exécution des requêtes de base de données : potentiellement élevé (meilleures requêtes dans certaines situations)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-157">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="cb5e9-158">+ Connection. Open</span><span class="sxs-lookup"><span data-stu-id="cb5e9-158">+ Connection.Open</span></span> <br/> <span data-ttu-id="cb5e9-159">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="cb5e9-159">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="cb5e9-160">+ DataReader. Read</span><span class="sxs-lookup"><span data-stu-id="cb5e9-160">+ DataReader.Read</span></span> <br/> <span data-ttu-id="cb5e9-161">Matérialisation d’objets : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-161">Object materialization: Medium</span></span> <br/> <span data-ttu-id="cb5e9-162">-Recherche d’identité : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-162">- Identity lookup: Medium</span></span> | <span data-ttu-id="cb5e9-163">-Chargement des métadonnées : élevé mais mis en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-163">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="cb5e9-164">-Génération de vues : moyenne mais mise en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-164">- View generation: Medium but cached</span></span> <br/> <span data-ttu-id="cb5e9-165">-Évaluation des paramètres : faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-165">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="cb5e9-166">-Traduction de requête : moyenne mais mise en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-166">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="cb5e9-167">-Génération de matérialise : moyenne mais mise en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-167">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="cb5e9-168">-Exécution des requêtes de base de données : potentiellement élevé (meilleures requêtes dans certaines situations)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-168">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="cb5e9-169">+ Connection. Open</span><span class="sxs-lookup"><span data-stu-id="cb5e9-169">+ Connection.Open</span></span> <br/> <span data-ttu-id="cb5e9-170">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="cb5e9-170">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="cb5e9-171">+ DataReader. Read</span><span class="sxs-lookup"><span data-stu-id="cb5e9-171">+ DataReader.Read</span></span> <br/> <span data-ttu-id="cb5e9-172">Matérialisation d’objets : moyenne (plus rapide que EF5)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-172">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="cb5e9-173">-Recherche d’identité : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-173">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="cb5e9-174">Connection. Close</span><span class="sxs-lookup"><span data-stu-id="cb5e9-174">Connection.Close</span></span>          | <span data-ttu-id="cb5e9-175">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-175">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="cb5e9-176">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-176">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="cb5e9-177">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-177">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


<span data-ttu-id="cb5e9-178">**Exécution de la deuxième requête-requête à chaud**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-178">**Second Query Execution – warm query**</span></span>

| <span data-ttu-id="cb5e9-179">Écritures utilisateur du code</span><span class="sxs-lookup"><span data-stu-id="cb5e9-179">Code User Writes</span></span>                                                                                     | <span data-ttu-id="cb5e9-180">Action</span><span class="sxs-lookup"><span data-stu-id="cb5e9-180">Action</span></span>                    | <span data-ttu-id="cb5e9-181">Impact sur les performances de EF4</span><span class="sxs-lookup"><span data-stu-id="cb5e9-181">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="cb5e9-182">Impact sur les performances de EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-182">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="cb5e9-183">Impact sur les performances de EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-183">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="cb5e9-184">Création de contexte</span><span class="sxs-lookup"><span data-stu-id="cb5e9-184">Context creation</span></span>          | <span data-ttu-id="cb5e9-185">Moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-185">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="cb5e9-186">Moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-186">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="cb5e9-187">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-187">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="cb5e9-188">Création d’une expression de requête</span><span class="sxs-lookup"><span data-stu-id="cb5e9-188">Query expression creation</span></span> | <span data-ttu-id="cb5e9-189">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-189">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="cb5e9-190">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-190">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="cb5e9-191">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-191">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="cb5e9-192">Exécution de requêtes LINQ</span><span class="sxs-lookup"><span data-stu-id="cb5e9-192">LINQ query execution</span></span>      | <span data-ttu-id="cb5e9-193">-Recherche ~~du chargement~~ des métadonnées : ~~haute, mais mise en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-193">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-194">-Afficher la recherche de ~~génération~~ : ~~potentiellement très élevé mais mis en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-194">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-195">-Évaluation des paramètres : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-195">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="cb5e9-196">-Recherche de ~~traduction~~ de requête : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-196">- Query ~~translation~~ lookup: Medium</span></span> <br/> <span data-ttu-id="cb5e9-197">-Recherche de la ~~génération~~ de matérialise : ~~moyenne mais mise en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-197">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-198">-Exécution de la requête de base de données : potentiellement élevé</span><span class="sxs-lookup"><span data-stu-id="cb5e9-198">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="cb5e9-199">+ Connection. Open</span><span class="sxs-lookup"><span data-stu-id="cb5e9-199">+ Connection.Open</span></span> <br/> <span data-ttu-id="cb5e9-200">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="cb5e9-200">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="cb5e9-201">+ DataReader. Read</span><span class="sxs-lookup"><span data-stu-id="cb5e9-201">+ DataReader.Read</span></span> <br/> <span data-ttu-id="cb5e9-202">Matérialisation d’objets : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-202">Object materialization: Medium</span></span> <br/> <span data-ttu-id="cb5e9-203">-Recherche d’identité : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-203">- Identity lookup: Medium</span></span> | <span data-ttu-id="cb5e9-204">-Recherche ~~du chargement~~ des métadonnées : ~~haute, mais mise en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-204">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-205">-Afficher la recherche de ~~génération~~ : ~~potentiellement très élevé mais mis en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-205">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-206">-Évaluation des paramètres : faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-206">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="cb5e9-207">-Recherche de ~~traduction~~ de requête : ~~moyenne mais mise en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-207">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-208">-Recherche de la ~~génération~~ de matérialise : ~~moyenne mais mise en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-208">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-209">-Exécution des requêtes de base de données : potentiellement élevé (meilleures requêtes dans certaines situations)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-209">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="cb5e9-210">+ Connection. Open</span><span class="sxs-lookup"><span data-stu-id="cb5e9-210">+ Connection.Open</span></span> <br/> <span data-ttu-id="cb5e9-211">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="cb5e9-211">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="cb5e9-212">+ DataReader. Read</span><span class="sxs-lookup"><span data-stu-id="cb5e9-212">+ DataReader.Read</span></span> <br/> <span data-ttu-id="cb5e9-213">Matérialisation d’objets : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-213">Object materialization: Medium</span></span> <br/> <span data-ttu-id="cb5e9-214">-Recherche d’identité : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-214">- Identity lookup: Medium</span></span> | <span data-ttu-id="cb5e9-215">-Recherche ~~du chargement~~ des métadonnées : ~~haute, mais mise en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-215">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-216">-Afficher la recherche de ~~génération~~ : ~~moyenne mais mise en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-216">- View ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-217">-Évaluation des paramètres : faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-217">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="cb5e9-218">-Recherche de ~~traduction~~ de requête : ~~moyenne mais mise en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-218">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-219">-Recherche de la ~~génération~~ de matérialise : ~~moyenne mais mise en cache~~ faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-219">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="cb5e9-220">-Exécution des requêtes de base de données : potentiellement élevé (meilleures requêtes dans certaines situations)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-220">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="cb5e9-221">+ Connection. Open</span><span class="sxs-lookup"><span data-stu-id="cb5e9-221">+ Connection.Open</span></span> <br/> <span data-ttu-id="cb5e9-222">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="cb5e9-222">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="cb5e9-223">+ DataReader. Read</span><span class="sxs-lookup"><span data-stu-id="cb5e9-223">+ DataReader.Read</span></span> <br/> <span data-ttu-id="cb5e9-224">Matérialisation d’objets : moyenne (plus rapide que EF5)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-224">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="cb5e9-225">-Recherche d’identité : moyenne</span><span class="sxs-lookup"><span data-stu-id="cb5e9-225">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="cb5e9-226">Connection. Close</span><span class="sxs-lookup"><span data-stu-id="cb5e9-226">Connection.Close</span></span>          | <span data-ttu-id="cb5e9-227">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-227">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="cb5e9-228">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-228">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="cb5e9-229">Faible</span><span class="sxs-lookup"><span data-stu-id="cb5e9-229">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


<span data-ttu-id="cb5e9-230">Il existe plusieurs façons de réduire le coût de performance des requêtes à froid et à chaud, et nous examinerons ces éléments dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-230">There are several ways to reduce the performance cost of both cold and warm queries, and we'll take a look at these in the following section.</span></span> <span data-ttu-id="cb5e9-231">Plus précisément, nous examinerons la réduction du coût du chargement de modèle dans les requêtes à froid en utilisant des vues prégénérées, ce qui devrait aider à atténuer les problèmes de performances rencontrés lors de la génération de vues.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-231">Specifically, we'll look at reducing the cost of model loading in cold queries by using pre-generated views, which should help alleviate performance pains experienced during view generation.</span></span> <span data-ttu-id="cb5e9-232">Pour les requêtes à chaud, nous allons aborder la mise en cache des plans de requête, les requêtes de suivi et les différentes options d’exécution de requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-232">For warm queries, we'll cover query plan caching, no tracking queries, and different query execution options.</span></span>

### <a name="21-what-is-view-generation"></a><span data-ttu-id="cb5e9-233">2,1 qu’est-ce que la génération de vues ?</span><span class="sxs-lookup"><span data-stu-id="cb5e9-233">2.1 What is View Generation?</span></span>

<span data-ttu-id="cb5e9-234">Pour comprendre la génération de vues, nous devons d’abord comprendre ce que sont les « vues de mappage ».</span><span class="sxs-lookup"><span data-stu-id="cb5e9-234">In order to understand what view generation is, we must first understand what “Mapping Views” are.</span></span> <span data-ttu-id="cb5e9-235">Les vues de mappage sont des représentations exécutables des transformations spécifiées dans le mappage pour chaque jeu d’entités et Association.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-235">Mapping Views are executable representations of the transformations specified in the mapping for each entity set and association.</span></span> <span data-ttu-id="cb5e9-236">En interne, ces vues de mappage prennent la forme de CQTs (arborescences de requêtes canoniques).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-236">Internally, these mapping views take the shape of CQTs (canonical query trees).</span></span> <span data-ttu-id="cb5e9-237">Il existe deux types de vues de mappage :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-237">There are two types of mapping views:</span></span>

-   <span data-ttu-id="cb5e9-238">Vues des requêtes : elles représentent la transformation nécessaire pour passer du schéma de base de données au modèle conceptuel.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-238">Query views: these represent the transformation necessary to go from the database schema to the conceptual model.</span></span>
-   <span data-ttu-id="cb5e9-239">Vues de mise à jour : elles représentent la transformation nécessaire pour passer du modèle conceptuel au schéma de base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-239">Update views: these represent the transformation necessary to go from the conceptual model to the database schema.</span></span>

<span data-ttu-id="cb5e9-240">Gardez à l’esprit que le modèle conceptuel peut différer du schéma de base de données de différentes façons.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-240">Keep in mind that the conceptual model might differ from the database schema in various ways.</span></span> <span data-ttu-id="cb5e9-241">Par exemple, une seule table peut être utilisée pour stocker les données de deux types d’entités différents.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-241">For example, one single table might be used to store the data for two different entity types.</span></span> <span data-ttu-id="cb5e9-242">Les mappages d’héritage et non trivial jouent un rôle dans la complexité des vues de mappage.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-242">Inheritance and non-trivial mappings play a role in the complexity of the mapping views.</span></span>

<span data-ttu-id="cb5e9-243">Le processus de calcul de ces vues en fonction de la spécification du mappage est ce que nous appelons la génération de vues.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-243">The process of computing these views based on the specification of the mapping is what we call view generation.</span></span> <span data-ttu-id="cb5e9-244">La génération de vues peut être exécutée dynamiquement lorsqu’un modèle est chargé, ou au moment de la génération, à l’aide de « vues prégénérées »; ces derniers sont sérialisés sous la forme d’instructions Entity SQL dans un \# fichier C ou VB.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-244">View generation can either take place dynamically when a model is loaded, or at build time, by using "pre-generated views"; the latter are serialized in the form of Entity SQL statements to a C\# or VB file.</span></span>

<span data-ttu-id="cb5e9-245">Lorsque des vues sont générées, elles sont également validées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-245">When views are generated, they are also validated.</span></span> <span data-ttu-id="cb5e9-246">Du point de vue des performances, la grande majorité du coût de la génération de vues est la validation des vues, qui garantit que les connexions entre les entités ont un sens et qu’elles disposent de la cardinalité correcte pour toutes les opérations prises en charge.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-246">From a performance standpoint, the vast majority of the cost of view generation is actually the validation of the views which ensures that the connections between the entities make sense and have the correct cardinality for all the supported operations.</span></span>

<span data-ttu-id="cb5e9-247">Lorsqu’une requête sur un jeu d’entités est exécutée, la requête est associée à la vue de requête correspondante, et le résultat de cette composition est exécuté via le compilateur de plan pour créer la représentation de la requête que le magasin de stockage peut comprendre.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-247">When a query over an entity set is executed, the query is combined with the corresponding query view, and the result of this composition is run through the plan compiler to create the representation of the query that the backing store can understand.</span></span> <span data-ttu-id="cb5e9-248">Par SQL Server, le résultat final de cette compilation sera une instruction T-SQL SELECT.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-248">For SQL Server, the final result of this compilation will be a T-SQL SELECT statement.</span></span> <span data-ttu-id="cb5e9-249">La première fois qu’une mise à jour est effectuée sur un jeu d’entités, la vue de mise à jour est exécutée à l’aide d’un processus similaire pour la transformer en instructions DML pour la base de données cible.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-249">The first time an update over an entity set is performed, the update view is run through a similar process to transform it into DML statements for the target database.</span></span>

### <a name="22-factors-that-affect-view-generation-performance"></a><span data-ttu-id="cb5e9-250">2,2 facteurs qui affectent les performances de la génération de vues</span><span class="sxs-lookup"><span data-stu-id="cb5e9-250">2.2 Factors that affect View Generation performance</span></span>

<span data-ttu-id="cb5e9-251">Les performances de l’étape de génération d’affichage dépendent non seulement de la taille de votre modèle, mais également de la manière dont le modèle est interconnecté.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-251">The performance of view generation step not only depends on the size of your model but also on how interconnected the model is.</span></span> <span data-ttu-id="cb5e9-252">Si deux entités sont connectées via une chaîne d’héritage ou une association, elles sont dites connectées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-252">If two Entities are connected via an inheritance chain or an Association, they are said to be connected.</span></span> <span data-ttu-id="cb5e9-253">De même, si deux tables sont connectées via une clé étrangère, elles sont connectées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-253">Similarly if two tables are connected via a foreign key, they are connected.</span></span> <span data-ttu-id="cb5e9-254">À mesure que le nombre d’entités et de tables connectées dans vos schémas augmente, le coût de la génération d’affichage augmente.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-254">As the number of connected Entities and tables in your schemas increase, the view generation cost increases.</span></span>

<span data-ttu-id="cb5e9-255">L’algorithme que nous utilisons pour générer et valider des vues est exponentiel dans le pire des cas, bien que nous utilisons des optimisations pour améliorer cela.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-255">The algorithm that we use to generate and validate views is exponential in the worst case, though we do use some optimizations to improve this.</span></span> <span data-ttu-id="cb5e9-256">Les facteurs les plus importants qui semblent nuire aux performances sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-256">The biggest factors that seem to negatively affect performance are:</span></span>

-   <span data-ttu-id="cb5e9-257">Taille du modèle, en faisant référence au nombre d’entités et à la quantité d’associations entre ces entités.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-257">Model size, referring to the number of entities and the amount of associations between these entities.</span></span>
-   <span data-ttu-id="cb5e9-258">Complexité du modèle, en particulier l’héritage impliquant un grand nombre de types.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-258">Model complexity, specifically inheritance involving a large number of types.</span></span>
-   <span data-ttu-id="cb5e9-259">À l’aide d’associations indépendantes, plutôt que d’associations de clé étrangère.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-259">Using Independent Associations, instead of Foreign Key Associations.</span></span>

<span data-ttu-id="cb5e9-260">Pour les petits modèles simples, le coût peut être suffisamment petit pour ne pas se soucier de l’utilisation de vues prégénérées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-260">For small, simple models the cost may be small enough to not bother using pre-generated views.</span></span> <span data-ttu-id="cb5e9-261">À mesure que la taille et la complexité du modèle augmentent, plusieurs options sont disponibles pour réduire le coût de la génération et de la validation de la vue.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-261">As model size and complexity increase, there are several options available to reduce the cost of view generation and validation.</span></span>

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a><span data-ttu-id="cb5e9-262">2,3 utilisation de vues prégénérées pour réduire le temps de chargement du modèle</span><span class="sxs-lookup"><span data-stu-id="cb5e9-262">2.3 Using Pre-Generated Views to decrease model load time</span></span>

<span data-ttu-id="cb5e9-263">Pour plus d’informations sur l’utilisation des affichages prégénérés sur Entity Framework 6, consultez [affichages de mappage prégénérés](xref:ef6/fundamentals/performance/pre-generated-views)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-263">For detailed information on how to use pre-generated views on Entity Framework 6 visit [Pre-Generated Mapping Views](xref:ef6/fundamentals/performance/pre-generated-views)</span></span>

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a><span data-ttu-id="cb5e9-264">2.3.1 affichages prégénérés à l’aide de Entity Framework Power Tools Community Edition</span><span class="sxs-lookup"><span data-stu-id="cb5e9-264">2.3.1 Pre-Generated views using the Entity Framework Power Tools Community Edition</span></span>

<span data-ttu-id="cb5e9-265">Vous pouvez utiliser l' [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) pour générer des vues de modèles EDMX et code First en cliquant avec le bouton droit sur le fichier de classe de modèle et en utilisant le menu Entity Framework pour sélectionner « générer des vues ».</span><span class="sxs-lookup"><span data-stu-id="cb5e9-265">You can use the [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) to generate views of EDMX and Code First models by right-clicking the model class file and using the Entity Framework menu to select “Generate Views”.</span></span> <span data-ttu-id="cb5e9-266">L’édition Community d’Entity Framework Power Tools ne fonctionne que sur les contextes dérivés de DbContext.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-266">The Entity Framework Power Tools Community Edition work only on DbContext-derived contexts.</span></span>

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a><span data-ttu-id="cb5e9-267">2.3.2 Comment utiliser des vues prégénérées avec un modèle créé par EDMGen</span><span class="sxs-lookup"><span data-stu-id="cb5e9-267">2.3.2 How to use Pre-generated views with a model created by EDMGen</span></span>

<span data-ttu-id="cb5e9-268">EDMGen est un utilitaire fourni avec .NET et fonctionne avec Entity Framework 4 et 5, mais pas avec Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-268">EDMGen is a utility that ships with .NET and works with Entity Framework 4 and 5, but not with Entity Framework 6.</span></span> <span data-ttu-id="cb5e9-269">EDMGen vous permet de générer un fichier de modèle, la couche objet et les vues à partir de la ligne de commande.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-269">EDMGen allows you to generate a model file, the object layer and the views from the command line.</span></span> <span data-ttu-id="cb5e9-270">L’une des sorties est un fichier de vues dans le langage de votre choix, VB ou C \# .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-270">One of the outputs will be a Views file in your language of choice, VB or C\#.</span></span> <span data-ttu-id="cb5e9-271">Il s’agit d’un fichier de code contenant Entity SQL extraits de code pour chaque jeu d’entités.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-271">This is a code file containing Entity SQL snippets for each entity set.</span></span> <span data-ttu-id="cb5e9-272">Pour activer les vues prégénérées, il vous suffit d’inclure le fichier dans votre projet.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-272">To enable pre-generated views, you simply include the file in your project.</span></span>

<span data-ttu-id="cb5e9-273">Si vous apportez manuellement des modifications aux fichiers de schéma pour le modèle, vous devrez générer à nouveau le fichier de vues.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-273">If you manually make edits to the schema files for the model, you will need to re-generate the views file.</span></span> <span data-ttu-id="cb5e9-274">Pour ce faire, exécutez EDMGen avec l’indicateur **/mode : ViewGeneration** .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-274">You can do this by running EDMGen with the **/mode:ViewGeneration** flag.</span></span>

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a><span data-ttu-id="cb5e9-275">2.3.3 comment utiliser des vues prégénérées avec un fichier EDMX</span><span class="sxs-lookup"><span data-stu-id="cb5e9-275">2.3.3 How to use Pre-Generated Views with an EDMX file</span></span>

<span data-ttu-id="cb5e9-276">Vous pouvez également utiliser EDMGen pour générer des vues pour un fichier EDMX : la rubrique MSDN précédemment référencée explique comment ajouter un événement pré-build pour effectuer cette opération, mais cela est complexe et dans certains cas, il n’est pas possible.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-276">You can also use EDMGen to generate views for an EDMX file - the previously referenced MSDN topic describes how to add a pre-build event to do this - but this is complicated and there are some cases where it isn't possible.</span></span> <span data-ttu-id="cb5e9-277">Il est généralement plus facile d’utiliser un modèle T4 pour générer les vues lorsque votre modèle se trouve dans un fichier edmx.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-277">It's generally easier to use a T4 template to generate the views when your model is in an edmx file.</span></span>

<span data-ttu-id="cb5e9-278">Le blog de l’équipe ADO.NET contient un billet qui décrit comment utiliser un modèle T4 pour la génération de vues ( \<https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation> ).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-278">The ADO.NET team blog has a post that describes how to use a T4 template for view generation ( \<https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation>).</span></span> <span data-ttu-id="cb5e9-279">Ce billet comprend un modèle qui peut être téléchargé et ajouté à votre projet.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-279">This post includes a template that can be downloaded and added to your project.</span></span> <span data-ttu-id="cb5e9-280">Le modèle a été écrit pour la première version de Entity Framework. il n’est donc pas garanti qu’il fonctionne avec les dernières versions de Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-280">The template was written for the first version of Entity Framework, so they aren’t guaranteed to work with the latest versions of Entity Framework.</span></span> <span data-ttu-id="cb5e9-281">Toutefois, vous pouvez télécharger un ensemble plus à jour de modèles de génération d’affichage pour Entity Framework 4 et 5from la Galerie Visual Studio :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-281">However, you can download a more up-to-date set of view generation templates for Entity Framework 4 and 5from the Visual Studio Gallery:</span></span>

-   <span data-ttu-id="cb5e9-282">VB.NET : \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span><span class="sxs-lookup"><span data-stu-id="cb5e9-282">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span></span>
-   <span data-ttu-id="cb5e9-283">C \# : \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span><span class="sxs-lookup"><span data-stu-id="cb5e9-283">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span></span>

<span data-ttu-id="cb5e9-284">Si vous utilisez Entity Framework 6, vous pouvez obtenir les modèles T4 de génération de vues à partir de la Galerie Visual Studio à l’adresse \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-284">If you’re using Entity Framework 6 you can get the view generation T4 templates from the Visual Studio Gallery at \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span></span>

### <a name="24-reducing-the-cost-of-view-generation"></a><span data-ttu-id="cb5e9-285">2,4 réduction du coût de la génération de vues</span><span class="sxs-lookup"><span data-stu-id="cb5e9-285">2.4 Reducing the cost of view generation</span></span>

<span data-ttu-id="cb5e9-286">L’utilisation de vues prégénérées déplace le coût de la génération de vues du chargement du modèle (au moment de l’exécution) au moment de la conception.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-286">Using pre-generated views moves the cost of view generation from model loading (run time) to design time.</span></span> <span data-ttu-id="cb5e9-287">Bien que cela améliore les performances de démarrage lors de l’exécution, vous serez toujours confronté à la difficulté de la génération d’affichages pendant le développement.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-287">While this improves startup performance at runtime, you will still experience the pain of view generation while you are developing.</span></span> <span data-ttu-id="cb5e9-288">Il existe plusieurs astuces supplémentaires qui peuvent aider à réduire le coût de la génération de vues, à la fois au moment de la compilation et au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-288">There are several additional tricks that can help reduce the cost of view generation, both at compile time and run time.</span></span>

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a><span data-ttu-id="cb5e9-289">2.4.1 utilisation d’associations de clé étrangère pour réduire le coût de la génération de vues</span><span class="sxs-lookup"><span data-stu-id="cb5e9-289">2.4.1 Using Foreign Key Associations to reduce view generation cost</span></span>

<span data-ttu-id="cb5e9-290">Nous avons vu un certain nombre de cas dans lesquels le basculement des associations de modèles indépendants vers des associations de clé étrangère a considérablement amélioré le temps passé dans la génération de vues.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-290">We have seen a number of cases where switching the associations in the model from Independent Associations to Foreign Key Associations dramatically improved the time spent in view generation.</span></span>

<span data-ttu-id="cb5e9-291">Pour illustrer cette amélioration, nous avons généré deux versions du modèle Navision à l’aide d’EDMGen.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-291">To demonstrate this improvement, we generated two versions of the Navision model by using EDMGen.</span></span> <span data-ttu-id="cb5e9-292">*Remarque : consultez l’annexe C pour obtenir une description du modèle Navision.*</span><span class="sxs-lookup"><span data-stu-id="cb5e9-292">*Note: see appendix C for a description of the Navision model.*</span></span> <span data-ttu-id="cb5e9-293">Le modèle Navision est intéressant pour cet exercice en raison de son très grand nombre d’entités et de relations entre eux.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-293">The Navision model is interesting for this exercise due to its very large amount of entities and relationships between them.</span></span>

<span data-ttu-id="cb5e9-294">Une version de ce modèle très volumineux a été générée avec des associations de clés étrangères et l’autre a été générée avec des associations indépendantes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-294">One version of this very large model was generated with Foreign Keys Associations and the other was generated with Independent Associations.</span></span> <span data-ttu-id="cb5e9-295">Nous avons ensuite dépassé le temps nécessaire à la génération des vues pour chaque modèle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-295">We then timed how long it took to generate the views for each model.</span></span> <span data-ttu-id="cb5e9-296">Entity Framework 5 test a utilisé la méthode GenerateViews () de la classe EntityViewGenerator pour générer les vues, tandis que le test Entity Framework 6 a utilisé la méthode GenerateViews () à partir de la classe StorageMappingItemCollection.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-296">Entity Framework 5 test used the GenerateViews() method from class EntityViewGenerator to generate the views, while the Entity Framework 6 test used the GenerateViews() method from class StorageMappingItemCollection.</span></span> <span data-ttu-id="cb5e9-297">Ceci en raison de la restructuration du code qui s’est produite dans le Entity Framework 6 code base.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-297">This due to code restructuring that occurred in the Entity Framework 6 codebase.</span></span>

<span data-ttu-id="cb5e9-298">À l’aide de Entity Framework 5, la génération de vues pour le modèle avec des clés étrangères a duré 65 minutes sur un ordinateur de laboratoire.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-298">Using Entity Framework 5, view generation for the model with Foreign Keys took 65 minutes in a lab machine.</span></span> <span data-ttu-id="cb5e9-299">Il s’agit d’un nombre inconnu de la durée nécessaire pour générer les vues du modèle qui utilisaient des associations indépendantes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-299">It's unknown how long it would have taken to generate the views for the model that used independent associations.</span></span> <span data-ttu-id="cb5e9-300">Nous avons laissé le test en cours d’exécution pendant plus d’un mois avant le redémarrage de l’ordinateur dans notre laboratoire pour installer les mises à jour mensuelles.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-300">We left the test running for over a month before the machine was rebooted in our lab to install monthly updates.</span></span>

<span data-ttu-id="cb5e9-301">À l’aide de Entity Framework 6, la génération de la vue pour le modèle avec des clés étrangères a pris 28 secondes dans le même ordinateur Lab.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-301">Using Entity Framework 6, view generation for the model with Foreign Keys took 28 seconds in the same lab machine.</span></span> <span data-ttu-id="cb5e9-302">La génération d’affichage pour le modèle qui utilise des associations indépendantes a duré 58 secondes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-302">View generation for the model that uses Independent Associations took 58 seconds.</span></span> <span data-ttu-id="cb5e9-303">Les améliorations apportées à Entity Framework 6 sur son code de génération d’affichage signifient que de nombreux projets n’ont pas besoin de vues prégénérées pour obtenir des temps de démarrage plus rapides.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-303">The improvements done to Entity Framework 6 on its view generation code mean that many projects won’t need pre-generated views to obtain faster startup times.</span></span>

<span data-ttu-id="cb5e9-304">Il est important de noter que les affichages prégénérés dans Entity Framework 4 et 5 peuvent être réalisés avec EDMGen ou les outils d’Entity Framework Power Tools.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-304">It’s important to remark that pre-generating views in Entity Framework 4 and 5 can be done with EDMGen or the Entity Framework Power Tools.</span></span> <span data-ttu-id="cb5e9-305">Pour la génération de Entity Framework 6, la génération peut s’effectuer via les outils Entity Framework Power Tools ou par programme, comme décrit dans les [vues de mappage prégénérées](xref:ef6/fundamentals/performance/pre-generated-views).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-305">For Entity Framework 6 view generation can be done via the Entity Framework Power Tools or programmatically as described in [Pre-Generated Mapping Views](xref:ef6/fundamentals/performance/pre-generated-views).</span></span>

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a><span data-ttu-id="cb5e9-306">2.4.1.1 comment utiliser des clés étrangères plutôt que des associations indépendantes</span><span class="sxs-lookup"><span data-stu-id="cb5e9-306">2.4.1.1 How to use Foreign Keys instead of Independent Associations</span></span>

<span data-ttu-id="cb5e9-307">Lorsque vous utilisez EDMGen ou le Entity Designer dans Visual Studio, vous recevez clés étrangères par défaut, et il n’accepte qu’un seul indicateur de case à cocher ou de ligne de commande pour basculer entre clés étrangères et IAs.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-307">When using EDMGen or the Entity Designer in Visual Studio, you get FKs by default, and it only takes a single checkbox or command line flag to switch between FKs and IAs.</span></span>

<span data-ttu-id="cb5e9-308">Si vous avez un modèle de Code First volumineux, l’utilisation d’associations indépendantes aura le même effet sur la génération de la vue.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-308">If you have a large Code First model, using Independent Associations will have the same effect on view generation.</span></span> <span data-ttu-id="cb5e9-309">Vous pouvez éviter cet impact en incluant des propriétés de clé étrangère sur les classes pour vos objets dépendants, bien que certains développeurs considèrent cela comme un modèle d’objet polluant.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-309">You can avoid this impact by including Foreign Key properties on the classes for your dependent objects, though some developers will consider this to be polluting their object model.</span></span> <span data-ttu-id="cb5e9-310">Vous trouverez plus d’informations sur ce sujet dans \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-310">You can find more information on this subject in \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span></span>

| <span data-ttu-id="cb5e9-311">Quand vous utilisez</span><span class="sxs-lookup"><span data-stu-id="cb5e9-311">When using</span></span>      | <span data-ttu-id="cb5e9-312">Action</span><span class="sxs-lookup"><span data-stu-id="cb5e9-312">Do this</span></span>                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="cb5e9-313">Concepteur d'entités</span><span class="sxs-lookup"><span data-stu-id="cb5e9-313">Entity Designer</span></span> | <span data-ttu-id="cb5e9-314">Après avoir ajouté une association entre deux entités, vérifiez que vous disposez d’une contrainte référentielle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-314">After adding an association between two entities, make sure you have a referential constraint.</span></span> <span data-ttu-id="cb5e9-315">Les contraintes référentielles indiquent Entity Framework utiliser des clés étrangères plutôt que des associations indépendantes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-315">Referential constraints tell Entity Framework to use Foreign Keys instead of Independent Associations.</span></span> <span data-ttu-id="cb5e9-316">Pour plus d’informations \<https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework> , consultez.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-316">For additional details visit \<https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework>.</span></span> |
| <span data-ttu-id="cb5e9-317">EDMGen</span><span class="sxs-lookup"><span data-stu-id="cb5e9-317">EDMGen</span></span>          | <span data-ttu-id="cb5e9-318">Lorsque vous utilisez EDMGen pour générer vos fichiers à partir de la base de données, vos clés étrangères sont respectées et ajoutées au modèle en tant que tel.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-318">When using EDMGen to generate your files from the database, your Foreign Keys will be respected and added to the model as such.</span></span> <span data-ttu-id="cb5e9-319">Pour plus d’informations sur les différentes options exposées par l’outil EDMGen, consultez [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx) .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-319">For more information on the different options exposed by EDMGen visit [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span></span>                           |
| <span data-ttu-id="cb5e9-320">Code First</span><span class="sxs-lookup"><span data-stu-id="cb5e9-320">Code First</span></span>      | <span data-ttu-id="cb5e9-321">Pour plus d’informations sur l’inclusion de propriétés de clé étrangère sur les objets dépendants lors de l’utilisation de Code First, consultez la section « Convention de relation » de la rubrique [conventions de code First](xref:ef6/modeling/code-first/conventions/built-in) .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-321">See the "Relationship Convention" section of the [Code First Conventions](xref:ef6/modeling/code-first/conventions/built-in) topic for information on how to include foreign key properties on dependent objects when using Code First.</span></span>                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a><span data-ttu-id="cb5e9-322">2.4.2 déplacement de votre modèle vers un assembly distinct</span><span class="sxs-lookup"><span data-stu-id="cb5e9-322">2.4.2 Moving your model to a separate assembly</span></span>

<span data-ttu-id="cb5e9-323">Lorsque votre modèle est inclus directement dans le projet de votre application et que vous générez des vues par le biais d’un modèle d’événement pré-build ou T4, la génération et la validation de la vue sont effectuées chaque fois que le projet est régénéré, même si le modèle n’a pas été modifié.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-323">When your model is included directly in your application's project and you generate views through a pre-build event or a T4 template, view generation and validation will take place whenever the project is rebuilt, even if the model wasn't changed.</span></span> <span data-ttu-id="cb5e9-324">Si vous déplacez le modèle vers un assembly distinct et le référencez à partir du projet de votre application, vous pouvez apporter d’autres modifications à votre application sans avoir à régénérer le projet contenant le modèle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-324">If you move the model to a separate assembly and reference it from your application's project, you can make other changes to your application without needing to rebuild the project containing the model.</span></span>

<span data-ttu-id="cb5e9-325">*Remarque :*   lors du déplacement de votre modèle vers des assemblys distincts, n’oubliez pas de copier les chaînes de connexion du modèle dans le fichier de configuration de l’application du projet client.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-325">*Note:*  when moving your model to separate assemblies remember to copy the connection strings for the model into the application configuration file of the client project.</span></span>

#### <a name="243-disable-validation-of-an-edmx-based-model"></a><span data-ttu-id="cb5e9-326">2.4.3 désactiver la validation d’un modèle basé sur edmx</span><span class="sxs-lookup"><span data-stu-id="cb5e9-326">2.4.3 Disable validation of an edmx-based model</span></span>

<span data-ttu-id="cb5e9-327">Les modèles EDMX sont validés au moment de la compilation, même si le modèle n’est pas modifié.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-327">EDMX models are validated at compile time, even if the model is unchanged.</span></span> <span data-ttu-id="cb5e9-328">Si votre modèle a déjà été validé, vous pouvez supprimer la validation au moment de la compilation en affectant à la propriété « valider à la génération » la valeur false dans la fenêtre Propriétés.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-328">If your model has already been validated, you can suppress validation at compile time by setting the "Validate on Build" property to false in the properties window.</span></span> <span data-ttu-id="cb5e9-329">Lorsque vous modifiez votre mappage ou modèle, vous pouvez réactiver temporairement la validation pour vérifier vos modifications.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-329">When you change your mapping or model, you can temporarily re-enable validation to verify your changes.</span></span>

<span data-ttu-id="cb5e9-330">Notez que les améliorations des performances ont été apportées au Entity Framework Designer pour Entity Framework 6, et que le coût de la « validation sur Build » est bien plus faible que dans les versions précédentes du concepteur.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-330">Note that performance improvements were made to the Entity Framework Designer for Entity Framework 6, and the cost of the “Validate on Build” is much lower than in previous versions of the designer.</span></span>

## <a name="3-caching-in-the-entity-framework"></a><span data-ttu-id="cb5e9-331">3 Caching dans le Entity Framework</span><span class="sxs-lookup"><span data-stu-id="cb5e9-331">3 Caching in the Entity Framework</span></span>

<span data-ttu-id="cb5e9-332">Entity Framework présente les formes de mise en cache intégrées suivantes :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-332">Entity Framework has the following forms of caching built-in:</span></span>

1.  <span data-ttu-id="cb5e9-333">Mise en cache d’objets : le ObjectStateManager intégré à une instance ObjectContext garde le suivi en mémoire des objets qui ont été récupérés à l’aide de cette instance.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-333">Object caching – the ObjectStateManager built into an ObjectContext instance keeps track in memory of the objects that have been retrieved using that instance.</span></span> <span data-ttu-id="cb5e9-334">Cela est également appelé cache de premier niveau.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-334">This is also known as first-level cache.</span></span>
2.  <span data-ttu-id="cb5e9-335">Mise en cache du plan de requête-réutilisation de la commande de stockage générée lorsqu’une requête est exécutée plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-335">Query Plan Caching - reusing the generated store command when a query is executed more than once.</span></span>
3.  <span data-ttu-id="cb5e9-336">Mise en cache des métadonnées : partage des métadonnées pour un modèle sur différentes connexions au même modèle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-336">Metadata caching - sharing the metadata for a model across different connections to the same model.</span></span>

<span data-ttu-id="cb5e9-337">Outre les caches fournis par EF, un type spécial de fournisseur de données ADO.NET connu sous le nom de fournisseur d’encapsulation peut également être utilisé pour étendre Entity Framework avec un cache pour les résultats récupérés à partir de la base de données, également appelée mise en cache de second niveau.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-337">Besides the caches that EF provides out of the box, a special kind of ADO.NET data provider known as a wrapping provider can also be used to extend Entity Framework with a cache for the results retrieved from the database, also known as second-level caching.</span></span>

### <a name="31-object-caching"></a><span data-ttu-id="cb5e9-338">Mise en cache d’objets 3,1</span><span class="sxs-lookup"><span data-stu-id="cb5e9-338">3.1 Object Caching</span></span>

<span data-ttu-id="cb5e9-339">Par défaut, lorsqu’une entité est retournée dans les résultats d’une requête, juste avant que EF ne le matérialise, ObjectContext vérifie si une entité avec la même clé a déjà été chargée dans son ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-339">By default when an entity is returned in the results of a query, just before EF materializes it, the ObjectContext will check if an entity with the same key has already been loaded into its ObjectStateManager.</span></span> <span data-ttu-id="cb5e9-340">Si une entité avec les mêmes clés est déjà présente, EF l’inclut dans les résultats de la requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-340">If an entity with the same keys is already present EF will include it in the results of the query.</span></span> <span data-ttu-id="cb5e9-341">Bien que EF émette toujours la requête sur la base de données, ce comportement peut contourner la majeure partie du coût de la matérialisation de l’entité plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-341">Although EF will still issue the query against the database, this behavior can bypass much of the cost of materializing the entity multiple times.</span></span>

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a><span data-ttu-id="cb5e9-342">3.1.1 obtention d’entités à partir du cache d’objets à l’aide de DbContext Find</span><span class="sxs-lookup"><span data-stu-id="cb5e9-342">3.1.1 Getting entities from the object cache using DbContext Find</span></span>

<span data-ttu-id="cb5e9-343">Contrairement à une requête normale, la méthode Find dans DbSet (les API incluses pour la première fois dans EF 4,1) effectue une recherche dans la mémoire avant même d’émettre la requête sur la base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-343">Unlike a regular query, the Find method in DbSet (APIs included for the first time in EF 4.1) will perform a search in memory before even issuing the query against the database.</span></span> <span data-ttu-id="cb5e9-344">Il est important de noter que deux instances ObjectContext différentes auront deux instances ObjectStateManager différentes, ce qui signifie qu’elles ont des caches d’objets distincts.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-344">It’s important to note that two different ObjectContext instances will have two different ObjectStateManager instances, meaning that they have separate object caches.</span></span>

<span data-ttu-id="cb5e9-345">Find utilise la valeur de clé primaire pour tenter de trouver une entité suivie par le contexte.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-345">Find uses the primary key value to attempt to find an entity tracked by the context.</span></span> <span data-ttu-id="cb5e9-346">Si l’entité n’est pas dans le contexte, une requête est exécutée et évaluée par rapport à la base de données, et la valeur null est retournée si l’entité est introuvable dans le contexte ou dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-346">If the entity is not in the context then a query will be executed and evaluated against the database, and null is returned if the entity is not found in the context or in the database.</span></span> <span data-ttu-id="cb5e9-347">Notez que Find retourne également les entités qui ont été ajoutées au contexte mais qui n’ont pas encore été enregistrées dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-347">Note that Find also returns entities that have been added to the context but have not yet been saved to the database.</span></span>

<span data-ttu-id="cb5e9-348">Vous pouvez prendre en compte les performances lors de l’utilisation de la recherche.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-348">There is a performance consideration to be taken when using Find.</span></span> <span data-ttu-id="cb5e9-349">Par défaut, les appels à cette méthode déclenchent une validation du cache d’objets afin de détecter les modifications qui sont toujours en attente de validation dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-349">Invocations to this method by default will trigger a validation of the object cache in order to detect changes that are still pending commit to the database.</span></span> <span data-ttu-id="cb5e9-350">Ce processus peut être très onéreux s’il existe un très grand nombre d’objets dans le cache d’objets ou dans un graphique d’objets volumineux qui est ajouté au cache d’objets, mais il peut également être désactivé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-350">This process can be very expensive if there are a very large number of objects in the object cache or in a large object graph being added to the object cache, but it can also be disabled.</span></span> <span data-ttu-id="cb5e9-351">Dans certains cas, vous pouvez percevoir un ordre de grandeur de différence lors de l’appel de la méthode Find lorsque vous désactivez la détection automatique des modifications.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-351">In certain cases, you may perceive over an order of magnitude of difference in calling the Find method when you disable auto detect changes.</span></span> <span data-ttu-id="cb5e9-352">Pourtant, un deuxième ordre de grandeur est perçu lorsque l’objet est réellement dans le cache par rapport au moment où l’objet doit être récupéré de la base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-352">Yet a second order of magnitude is perceived when the object actually is in the cache versus when the object has to be retrieved from the database.</span></span> <span data-ttu-id="cb5e9-353">Voici un exemple de graphique avec des mesures effectuées à l’aide de quelques tests, exprimés en millisecondes, avec une charge de 5000 entités :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-353">Here is an example graph with measurements taken using some of our microbenchmarks, expressed in milliseconds, with a load of 5000 entities:</span></span>

<span data-ttu-id="cb5e9-354">![Échelle logarithmique .NET 4,5](~/ef6/media/net45logscale.png ".NET 4,5-échelle logarithmique")</span><span class="sxs-lookup"><span data-stu-id="cb5e9-354">![.NET 4.5 logarithmic scale](~/ef6/media/net45logscale.png ".NET 4.5 - logarithmic scale")</span></span>

<span data-ttu-id="cb5e9-355">Exemple de recherche avec détection automatique des modifications désactivées :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-355">Example of Find with auto-detect changes disabled:</span></span>

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

<span data-ttu-id="cb5e9-356">Les éléments à prendre en compte lors de l’utilisation de la méthode Find sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-356">What you have to consider when using the Find method is:</span></span>

1.  <span data-ttu-id="cb5e9-357">Si l’objet n’est pas dans le cache, les avantages de Find sont inversés, mais la syntaxe est toujours plus simple qu’une requête par clé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-357">If the object is not in the cache the benefits of Find are negated, but the syntax is still simpler than a query by key.</span></span>
2.  <span data-ttu-id="cb5e9-358">Si la détection automatique des modifications est activée, le coût de la méthode Find peut augmenter d’un ordre de grandeur, voire plus, en fonction de la complexité de votre modèle et de la quantité d’entités dans votre cache d’objets.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-358">If auto detect changes is enabled the cost of the Find method may increase by one order of magnitude, or even more depending on the complexity of your model and the amount of entities in your object cache.</span></span>

<span data-ttu-id="cb5e9-359">En outre, n’oubliez pas que la recherche ne retourne que l’entité que vous recherchez et qu’elle ne charge pas automatiquement les entités associées si elles ne se trouvent pas déjà dans le cache d’objets.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-359">Also, keep in mind that Find only returns the entity you are looking for and it does not automatically loads its associated entities if they are not already in the object cache.</span></span> <span data-ttu-id="cb5e9-360">Si vous devez récupérer les entités associées, vous pouvez utiliser une requête par clé avec un chargement hâtif.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-360">If you need to retrieve associated entities, you can use a query by key with eager loading.</span></span> <span data-ttu-id="cb5e9-361">Pour plus d’informations, consultez **8,1 chargement différé et chargement hâtif**.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-361">For more information see **8.1 Lazy Loading vs. Eager Loading**.</span></span>

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a><span data-ttu-id="cb5e9-362">3.1.2 problèmes de performances lorsque le cache d’objets a de nombreuses entités</span><span class="sxs-lookup"><span data-stu-id="cb5e9-362">3.1.2 Performance issues when the object cache has many entities</span></span>

<span data-ttu-id="cb5e9-363">Le cache d’objets permet d’augmenter la réactivité globale de Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-363">The object cache helps to increase the overall responsiveness of Entity Framework.</span></span> <span data-ttu-id="cb5e9-364">Toutefois, lorsque le cache d’objets a une très grande quantité d’entités chargées, il peut affecter certaines opérations, telles que ajouter, supprimer, Rechercher, entrée, SaveChanges et bien plus encore.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-364">However, when the object cache has a very large amount of entities loaded it may affect certain operations such as Add, Remove, Find, Entry, SaveChanges and more.</span></span> <span data-ttu-id="cb5e9-365">En particulier, les opérations qui déclenchent un appel à DetectChanges seront affectées par des caches d’objets très volumineux.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-365">In particular, operations that trigger a call to DetectChanges will be negatively affected by very large object caches.</span></span> <span data-ttu-id="cb5e9-366">DetectChanges synchronise le graphique d’objets avec le gestionnaire d’état d’objet et ses performances sont déterminées directement par la taille du graphique d’objets.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-366">DetectChanges synchronizes the object graph with the object state manager and its performance will determined directly by the size of the object graph.</span></span> <span data-ttu-id="cb5e9-367">Pour plus d’informations sur DetectChanges, consultez [suivi des modifications dans les entités POCO](https://msdn.microsoft.com/library/dd456848.aspx).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-367">For more information about DetectChanges, see [Tracking Changes in POCO Entities](https://msdn.microsoft.com/library/dd456848.aspx).</span></span>

<span data-ttu-id="cb5e9-368">Lorsque vous utilisez Entity Framework 6, les développeurs peuvent appeler AddRange et RemoveRange directement sur un DbSet, au lieu d’effectuer une itération sur une collection et d’appeler Add once par instance.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-368">When using Entity Framework 6, developers are able to call AddRange and RemoveRange directly on a DbSet, instead of iterating on a collection and calling Add once per instance.</span></span> <span data-ttu-id="cb5e9-369">L’avantage de l’utilisation des méthodes de plage est que le coût de DetectChanges n’est payé qu’une seule fois pour l’ensemble des entités, par opposition à une seule fois pour chaque entité ajoutée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-369">The advantage of using the range methods is that the cost of DetectChanges is only paid once for the entire set of entities as opposed to once per each added entity.</span></span>

### <a name="32-query-plan-caching"></a><span data-ttu-id="cb5e9-370">3,2 mise en cache du plan de requête</span><span class="sxs-lookup"><span data-stu-id="cb5e9-370">3.2 Query Plan Caching</span></span>

<span data-ttu-id="cb5e9-371">La première fois qu’une requête est exécutée, elle passe par le compilateur de plan interne pour traduire la requête conceptuelle dans la commande de stockage (par exemple, T-SQL qui est exécutée lors de l’exécution sur SQL Server).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-371">The first time a query is executed, it goes through the internal plan compiler to translate the conceptual query into the store command (for example, the T-SQL which is executed when run against SQL Server).</span></span><span data-ttu-id="cb5e9-372">Si la mise en cache du plan de requête est activée, la prochaine fois que la requête est exécutée, la commande de stockage est récupérée directement à partir du cache du plan de requête pour exécution, en ignorant le compilateur du plan.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-372">  If query plan caching is enabled, the next time the query is executed the store command is retrieved directly from the query plan cache for execution, bypassing the plan compiler.</span></span>

<span data-ttu-id="cb5e9-373">Le cache du plan de requête est partagé entre les instances ObjectContext au sein du même AppDomain.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-373">The query plan cache is shared across ObjectContext instances within the same AppDomain.</span></span> <span data-ttu-id="cb5e9-374">Vous n’avez pas besoin de conserver une instance ObjectContext pour tirer parti de la mise en cache du plan de requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-374">You don't need to hold onto an ObjectContext instance to benefit from query plan caching.</span></span>

#### <a name="321-some-notes-about-query-plan-caching"></a><span data-ttu-id="cb5e9-375">3.2.1 quelques remarques sur la mise en cache du plan de requête</span><span class="sxs-lookup"><span data-stu-id="cb5e9-375">3.2.1 Some notes about Query Plan Caching</span></span>

-   <span data-ttu-id="cb5e9-376">Le cache du plan de requête est partagé pour tous les types de requêtes : les objets Entity SQL, LINQ to Entities et CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-376">The query plan cache is shared for all query types: Entity SQL, LINQ to Entities, and CompiledQuery objects.</span></span>
-   <span data-ttu-id="cb5e9-377">Par défaut, la mise en cache du plan de requête est activée pour les requêtes Entity SQL, qu’elles soient exécutées via un EntityCommand ou via un ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-377">By default, query plan caching is enabled for Entity SQL queries, whether executed through an EntityCommand or through an ObjectQuery.</span></span> <span data-ttu-id="cb5e9-378">Elle est également activée par défaut pour les requêtes LINQ to Entities dans Entity Framework sur .NET 4,5 et dans Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-378">It is also enabled by default for LINQ to Entities queries in Entity Framework on .NET 4.5, and in Entity Framework 6</span></span>
    -   <span data-ttu-id="cb5e9-379">La mise en cache du plan de requête peut être désactivée en affectant à la propriété EnablePlanCaching (sur EntityCommand ou ObjectQuery) la valeur false.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-379">Query plan caching can be disabled by setting the EnablePlanCaching property (on EntityCommand or ObjectQuery) to false.</span></span> <span data-ttu-id="cb5e9-380">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-380">For example:</span></span>
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   <span data-ttu-id="cb5e9-381">Pour les requêtes paramétrables, la modification de la valeur du paramètre atteint toujours la requête mise en cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-381">For parameterized queries, changing the parameter's value will still hit the cached query.</span></span> <span data-ttu-id="cb5e9-382">Toutefois, la modification des facettes d’un paramètre (par exemple, la taille, la précision ou l’échelle) atteint une entrée différente dans le cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-382">But changing a parameter's facets (for example, size, precision, or scale) will hit a different entry in the cache.</span></span>
-   <span data-ttu-id="cb5e9-383">Lors de l’utilisation de Entity SQL, la chaîne de requête fait partie de la clé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-383">When using Entity SQL, the query string is part of the key.</span></span> <span data-ttu-id="cb5e9-384">La modification de la requête peut entraîner des entrées de cache différentes, même si les requêtes sont fonctionnellement équivalentes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-384">Changing the query at all will result in different cache entries, even if the queries are functionally equivalent.</span></span> <span data-ttu-id="cb5e9-385">Cela comprend les modifications apportées à la casse ou à l’espace blanc.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-385">This includes changes to casing or whitespace.</span></span>
-   <span data-ttu-id="cb5e9-386">Lors de l’utilisation de LINQ, la requête est traitée pour générer une partie de la clé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-386">When using LINQ, the query is processed to generate a part of the key.</span></span> <span data-ttu-id="cb5e9-387">La modification de l’expression LINQ générera donc une clé différente.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-387">Changing the LINQ expression will therefore generate a different key.</span></span>
-   <span data-ttu-id="cb5e9-388">D’autres limitations techniques peuvent s’appliquer ; Pour plus d’informations, consultez requêtes autocompilées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-388">Other technical limitations may apply; see Autocompiled Queries for more details.</span></span>

#### <a name="322-cache-eviction-algorithm"></a><span data-ttu-id="cb5e9-389">3.2.2-algorithme d’éviction du cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-389">3.2.2      Cache eviction algorithm</span></span>

<span data-ttu-id="cb5e9-390">Comprendre le fonctionnement de l’algorithme interne vous aide à déterminer quand activer ou désactiver la mise en cache du plan de requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-390">Understanding how the internal algorithm works will help you figure out when to enable or disable query plan caching.</span></span> <span data-ttu-id="cb5e9-391">L’algorithme de nettoyage est le suivant :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-391">The cleanup algorithm is as follows:</span></span>

1.  <span data-ttu-id="cb5e9-392">Une fois que le cache contient un nombre défini d’entrées (800), nous commençons un minuteur qui balaye régulièrement le cache (une fois par minute).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-392">Once the cache contains a set number of entries (800), we start a timer that periodically (once-per-minute) sweeps the cache.</span></span>
2.  <span data-ttu-id="cb5e9-393">Pendant les nettoyages du cache, les entrées sont supprimées du cache sur une base LFRU (le moins fréquemment utilisé récemment).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-393">During cache sweeps, entries are removed from the cache on a LFRU (Least frequently – recently used) basis.</span></span> <span data-ttu-id="cb5e9-394">Cet algorithme prend en compte le nombre d’accès et l’âge pour déterminer quelles entrées sont éjectées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-394">This algorithm takes both hit count and age into account when deciding which entries are ejected.</span></span>
3.  <span data-ttu-id="cb5e9-395">À la fin de chaque balayage du cache, le cache contient 800 entrées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-395">At the end of each cache sweep, the cache again contains 800 entries.</span></span>

<span data-ttu-id="cb5e9-396">Toutes les entrées de cache sont traitées de manière égale lors de la détermination des entrées à supprimer.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-396">All cache entries are treated equally when determining which entries to evict.</span></span> <span data-ttu-id="cb5e9-397">Cela signifie que la commande de stockage pour un CompiledQuery a le même risque d’éviction que la commande de stockage pour une requête de Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-397">This means the store command for a CompiledQuery has the same chance of eviction as the store command for an Entity SQL query.</span></span>

<span data-ttu-id="cb5e9-398">Notez que le minuteur d’éviction du cache est lancé lorsqu’il y a 800 entités dans le cache, mais que le cache n’est balayé que 60 secondes après le démarrage de ce minuteur.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-398">Note that the cache eviction timer is kicked in when there are 800 entities in the cache, but the cache is only swept 60 seconds after this timer is started.</span></span> <span data-ttu-id="cb5e9-399">Cela signifie que jusqu’à 60 secondes, votre cache peut croître pour être assez volumineux.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-399">That means that for up to 60 seconds your cache may grow to be quite large.</span></span>

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a><span data-ttu-id="cb5e9-400">3.2.3 métriques de test illustrant les performances de mise en cache du plan de requête</span><span class="sxs-lookup"><span data-stu-id="cb5e9-400">3.2.3       Test Metrics demonstrating query plan caching performance</span></span>

<span data-ttu-id="cb5e9-401">Pour illustrer l’effet de la mise en cache du plan de requête sur les performances de votre application, nous avons effectué un test sur lequel nous avons exécuté un certain nombre de requêtes Entity SQL sur le modèle Navision.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-401">To demonstrate the effect of query plan caching on your application's performance, we performed a test where we executed a number of Entity SQL queries against the Navision model.</span></span> <span data-ttu-id="cb5e9-402">Reportez-vous à l’annexe pour obtenir une description du modèle Navision et des types de requêtes qui ont été exécutés.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-402">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="cb5e9-403">Dans ce test, nous allons d’abord itérer au sein de la liste des requêtes et les exécuter une fois pour les ajouter au cache (si la mise en cache est activée).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-403">In this test, we first iterate through the list of queries and execute each one once to add them to the cache (if caching is enabled).</span></span> <span data-ttu-id="cb5e9-404">Cette étape n’est pas terminée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-404">This step is untimed.</span></span> <span data-ttu-id="cb5e9-405">Ensuite, nous mettons en veille le thread principal pendant plus de 60 secondes pour permettre le balayage du cache. Enfin, nous parcourons la liste une deuxième fois pour exécuter les requêtes mises en cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-405">Next, we sleep the main thread for over 60 seconds to allow cache sweeping to take place; finally, we iterate through the list a 2nd time to execute the cached queries.</span></span> <span data-ttu-id="cb5e9-406">En outre, le cache du plan de SQL Server est vidé avant l’exécution de chaque ensemble de requêtes, de sorte que les fois que nous obtenons précisément l’avantage donné par le cache du plan de requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-406">Additionally, the SQL Server plan cache is flushed before each set of queries is executed so that the times we obtain accurately reflect the benefit given by the query plan cache.</span></span>

##### <a name="3231-test-results"></a><span data-ttu-id="cb5e9-407">3.2.3.1 Résultats des tests</span><span class="sxs-lookup"><span data-stu-id="cb5e9-407">3.2.3.1       Test Results</span></span>

| <span data-ttu-id="cb5e9-408">Test</span><span class="sxs-lookup"><span data-stu-id="cb5e9-408">Test</span></span>                                                                   | <span data-ttu-id="cb5e9-409">EF5 aucun cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-409">EF5 no cache</span></span> | <span data-ttu-id="cb5e9-410">EF5 mis en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-410">EF5 cached</span></span> | <span data-ttu-id="cb5e9-411">EF6 aucun cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-411">EF6 no cache</span></span> | <span data-ttu-id="cb5e9-412">EF6 mis en cache</span><span class="sxs-lookup"><span data-stu-id="cb5e9-412">EF6 cached</span></span> |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| <span data-ttu-id="cb5e9-413">Énumération de toutes les requêtes 18723</span><span class="sxs-lookup"><span data-stu-id="cb5e9-413">Enumerating all 18723 queries</span></span>                                          | <span data-ttu-id="cb5e9-414">124</span><span class="sxs-lookup"><span data-stu-id="cb5e9-414">124</span></span>          | <span data-ttu-id="cb5e9-415">125,4</span><span class="sxs-lookup"><span data-stu-id="cb5e9-415">125.4</span></span>      | <span data-ttu-id="cb5e9-416">124,3</span><span class="sxs-lookup"><span data-stu-id="cb5e9-416">124.3</span></span>        | <span data-ttu-id="cb5e9-417">125,3</span><span class="sxs-lookup"><span data-stu-id="cb5e9-417">125.3</span></span>      |
| <span data-ttu-id="cb5e9-418">Éviter le balayage (uniquement les premières requêtes 800, quelle que soit la complexité)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-418">Avoiding sweep (just the first 800 queries, regardless of complexity)</span></span>  | <span data-ttu-id="cb5e9-419">41,7</span><span class="sxs-lookup"><span data-stu-id="cb5e9-419">41.7</span></span>         | <span data-ttu-id="cb5e9-420">5.5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-420">5.5</span></span>        | <span data-ttu-id="cb5e9-421">40,5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-421">40.5</span></span>         | <span data-ttu-id="cb5e9-422">5.4</span><span class="sxs-lookup"><span data-stu-id="cb5e9-422">5.4</span></span>        |
| <span data-ttu-id="cb5e9-423">Uniquement les requêtes AggregatingSubtotals (178 au total-qui évite le balayage)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-423">Just the AggregatingSubtotals queries (178 total - which avoids sweep)</span></span> | <span data-ttu-id="cb5e9-424">39,5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-424">39.5</span></span>         | <span data-ttu-id="cb5e9-425">4,5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-425">4.5</span></span>        | <span data-ttu-id="cb5e9-426">38,1</span><span class="sxs-lookup"><span data-stu-id="cb5e9-426">38.1</span></span>         | <span data-ttu-id="cb5e9-427">4,6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-427">4.6</span></span>        |

<span data-ttu-id="cb5e9-428">*Toutes les fois en secondes.*</span><span class="sxs-lookup"><span data-stu-id="cb5e9-428">*All times in seconds.*</span></span>

<span data-ttu-id="cb5e9-429">Moral : lors de l’exécution d’un grand nombre de requêtes distinctes (par exemple, des requêtes créées dynamiquement), la mise en cache n’est pas utile et le vidage résultant du cache peut conserver les requêtes qui tireraient le meilleur parti de la mise en cache de plan pour l’utiliser en fait.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-429">Moral - when executing lots of distinct queries (for example,  dynamically created queries), caching doesn't help and the resulting flushing of the cache can keep the queries that would benefit the most from plan caching from actually using it.</span></span>

<span data-ttu-id="cb5e9-430">Les requêtes AggregatingSubtotals sont les plus complexes des requêtes que nous avons testées avec.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-430">The AggregatingSubtotals queries are the most complex of the queries we tested with.</span></span> <span data-ttu-id="cb5e9-431">Comme prévu, plus la requête est complexe, plus l’avantage que vous verrez dans la mise en cache du plan de requête est avantageux.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-431">As expected, the more complex the query is, the more benefit you will see from query plan caching.</span></span>

<span data-ttu-id="cb5e9-432">Étant donné qu’un CompiledQuery est en réalité une requête LINQ avec son plan mis en cache, la comparaison entre un CompiledQuery et l’équivalent Entity SQL requête doit avoir des résultats similaires.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-432">Because a CompiledQuery is really a LINQ query with its plan cached, the comparison of a CompiledQuery versus the equivalent Entity SQL query should have similar results.</span></span> <span data-ttu-id="cb5e9-433">En fait, si une application possède un grand nombre de requêtes Entity SQL dynamiques, le remplissage du cache avec des requêtes entraînera également la « décompilation » de CompiledQueries lorsqu’elles seront vidées du cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-433">In fact, if an app has lots of dynamic Entity SQL queries, filling the cache with queries will also effectively cause CompiledQueries to “decompile” when they are flushed from the cache.</span></span> <span data-ttu-id="cb5e9-434">Dans ce scénario, les performances peuvent être améliorées en désactivant la mise en cache sur les requêtes dynamiques afin de hiérarchiser les CompiledQueries.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-434">In this scenario, performance may be improved by disabling caching on the dynamic queries to prioritize the CompiledQueries.</span></span> <span data-ttu-id="cb5e9-435">Mieux encore, bien sûr, il serait de réécrire l’application pour utiliser des requêtes paramétrables au lieu de requêtes dynamiques.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-435">Better yet, of course, would be to rewrite the app to use parameterized queries instead of dynamic queries.</span></span>

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a><span data-ttu-id="cb5e9-436">3,3 utilisation de CompiledQuery pour améliorer les performances avec des requêtes LINQ</span><span class="sxs-lookup"><span data-stu-id="cb5e9-436">3.3 Using CompiledQuery to improve performance with LINQ queries</span></span>

<span data-ttu-id="cb5e9-437">Nos tests indiquent que l’utilisation de CompiledQuery peut apporter un avantage de 7% sur les requêtes LINQ autocompilées. Cela signifie que vous allez consacrer 7% moins de temps à exécuter du code à partir de la pile Entity Framework ; Cela ne signifie pas que votre application sera 7% plus rapide.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-437">Our tests indicate that using CompiledQuery can bring a benefit of 7% over autocompiled LINQ queries; this means that you’ll spend 7% less time executing code from the Entity Framework stack; it does not mean your application will be 7% faster.</span></span> <span data-ttu-id="cb5e9-438">En règle générale, le coût de l’écriture et de la gestion des objets CompiledQuery dans EF 5,0 peut ne pas poser de problème par rapport aux avantages.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-438">Generally speaking, the cost of writing and maintaining CompiledQuery objects in EF 5.0 may not be worth the trouble when compared to the benefits.</span></span> <span data-ttu-id="cb5e9-439">Votre kilométrage peut varier. vous devez donc faire preuve de cette possibilité si votre projet nécessite une transmission de type push supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-439">Your mileage may vary, so exercise this option if your project requires the extra push.</span></span> <span data-ttu-id="cb5e9-440">Notez que les CompiledQueries sont uniquement compatibles avec les modèles dérivés de ObjectContext et ne sont pas compatibles avec les modèles dérivés de DbContext.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-440">Note that CompiledQueries are only compatible with ObjectContext-derived models, and not compatible with DbContext-derived models.</span></span>

<span data-ttu-id="cb5e9-441">Pour plus d’informations sur la création et l’appel d’un CompiledQuery, consultez [requêtes compilées (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-441">For more information on creating and invoking a CompiledQuery, see [Compiled Queries (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span></span>

<span data-ttu-id="cb5e9-442">Il y a deux points à prendre en compte lors de l’utilisation d’un CompiledQuery, à savoir la nécessité d’utiliser des instances statiques et les problèmes qu’ils ont avec la composabilité.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-442">There are two considerations you have to take when using a CompiledQuery, namely the requirement to use static instances and the problems they have with composability.</span></span> <span data-ttu-id="cb5e9-443">Vous trouverez ci-dessous une explication détaillée de ces deux considérations.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-443">Here follows an in-depth explanation of these two considerations.</span></span>

#### <a name="331-use-static-compiledquery-instances"></a><span data-ttu-id="cb5e9-444">3.3.1 utiliser des instances CompiledQuery statiques</span><span class="sxs-lookup"><span data-stu-id="cb5e9-444">3.3.1       Use static CompiledQuery instances</span></span>

<span data-ttu-id="cb5e9-445">Dans la mesure où la compilation d’une requête LINQ est un processus long, nous ne voulons pas la faire chaque fois que nous devons extraire des données de la base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-445">Since compiling a LINQ query is a time-consuming process, we don’t want to do it every time we need to fetch data from the database.</span></span> <span data-ttu-id="cb5e9-446">Les instances CompiledQuery vous permettent de compiler une seule fois et de les exécuter plusieurs fois, mais vous devez faire attention et demander à réutiliser la même instance de CompiledQuery à chaque fois au lieu de la compiler à nouveau.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-446">CompiledQuery instances allow you to compile once and run multiple times, but you have to be careful and procure to re-use the same CompiledQuery instance every time instead of compiling it over and over again.</span></span> <span data-ttu-id="cb5e9-447">L’utilisation de membres statiques pour stocker les instances CompiledQuery devient nécessaire ; dans le cas contraire, vous ne verrez aucun avantage.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-447">The use of static members to store the CompiledQuery instances becomes necessary; otherwise you won’t see any benefit.</span></span>

<span data-ttu-id="cb5e9-448">Par exemple, supposons que votre page possède le corps de méthode suivant pour gérer l’affichage des produits pour la catégorie sélectionnée :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-448">For example, suppose your page has the following method body to handle displaying the products for the selected category:</span></span>

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

<span data-ttu-id="cb5e9-449">Dans ce cas, vous allez créer une nouvelle instance CompiledQuery à la volée chaque fois que la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-449">In this case, you will create a new CompiledQuery instance on the fly every time the method is called.</span></span> <span data-ttu-id="cb5e9-450">Au lieu de voir les avantages en matière de performances en récupérant la commande de stockage dans le cache du plan de requête, le CompiledQuery passera par le compilateur de plan chaque fois qu’une nouvelle instance sera créée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-450">Instead of seeing performance benefits by retrieving the store command from the query plan cache, the CompiledQuery will go through the plan compiler every time a new instance is created.</span></span> <span data-ttu-id="cb5e9-451">En fait, vous allez polluer votre cache de plan de requête avec une nouvelle entrée CompiledQuery chaque fois que la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-451">In fact, you will be polluting your query plan cache with a new CompiledQuery entry every time the method is called.</span></span>

<span data-ttu-id="cb5e9-452">Au lieu de cela, vous souhaitez créer une instance statique de la requête compilée, de sorte que vous appelez la même requête compilée chaque fois que la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-452">Instead, you want to create a static instance of the compiled query, so you are invoking the same compiled query every time the method is called.</span></span> <span data-ttu-id="cb5e9-453">Pour ce faire, vous pouvez ajouter l’instance CompiledQuery en tant que membre du contexte de l’objet.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-453">One way to so this is by adding the CompiledQuery instance as a member of your object context.</span></span><span data-ttu-id="cb5e9-454">Vous pouvez ensuite faire un petit nettoyage en accédant au CompiledQuery par le biais d’une méthode d’assistance :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-454">  You can then make things a little cleaner by accessing the CompiledQuery through a helper method:</span></span>

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

<span data-ttu-id="cb5e9-455">Cette méthode d’assistance serait appelée comme suit :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-455">This helper method would be invoked as follows:</span></span>

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a><span data-ttu-id="cb5e9-456">3.3.2 composer sur un CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="cb5e9-456">3.3.2       Composing over a CompiledQuery</span></span>

<span data-ttu-id="cb5e9-457">La possibilité de composer une requête LINQ est très utile. pour ce faire, il vous suffit d’appeler une méthode après l’objet IQueryable, par exemple *Skip ()* ou *Count ()*.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-457">The ability to compose over any LINQ query is extremely useful; to do this, you simply invoke a method after the IQueryable such as *Skip()* or *Count()*.</span></span> <span data-ttu-id="cb5e9-458">Toutefois, cela retourne essentiellement un nouvel objet IQueryable.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-458">However, doing so essentially returns a new IQueryable object.</span></span> <span data-ttu-id="cb5e9-459">Bien qu’il n’y ait rien à vous empêcher techniquement de composer sur un CompiledQuery, cela entraînera la génération d’un nouvel objet IQueryable qui nécessitera à nouveau de passer par le compilateur de plan.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-459">While there’s nothing to stop you technically from composing over a CompiledQuery, doing so will cause the generation of a new IQueryable object that requires passing through the plan compiler again.</span></span>

<span data-ttu-id="cb5e9-460">Certains composants utilisent des objets IQueryable composés pour activer les fonctionnalités avancées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-460">Some components will make use of composed IQueryable objects to enable advanced functionality.</span></span> <span data-ttu-id="cb5e9-461">Par exemple, ASP. Le GridView de NET peut être lié aux données d’un objet IQueryable via la propriété SelectMethod.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-461">For example, ASP.NET’s GridView can be data-bound to an IQueryable object via the SelectMethod property.</span></span> <span data-ttu-id="cb5e9-462">Le GridView se compose alors de cet objet IQueryable pour permettre le tri et la pagination sur le modèle de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-462">The GridView will then compose over this IQueryable object to allow sorting and paging over the data model.</span></span> <span data-ttu-id="cb5e9-463">Comme vous pouvez le voir, l’utilisation d’un CompiledQuery pour le GridView n’atteint pas la requête compilée, mais génère une nouvelle requête autocompilée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-463">As you can see, using a CompiledQuery for the GridView would not hit the compiled query but would generate a new autocompiled query.</span></span>

<span data-ttu-id="cb5e9-464">Dans ce cas, il est possible d’ajouter des filtres progressifs à une requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-464">One place where you may run into this is when adding progressive filters to a query.</span></span> <span data-ttu-id="cb5e9-465">Par exemple, supposons que vous disposiez d’une page clients avec plusieurs listes déroulantes pour les filtres facultatifs (par exemple, pays et OrdersCount).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-465">For example, suppose you had a Customers page with several drop-down lists for optional filters (for example, Country and OrdersCount).</span></span> <span data-ttu-id="cb5e9-466">Vous pouvez composer ces filtres sur les résultats IQueryable d’un CompiledQuery, mais cela entraînera le passage de la nouvelle requête par le compilateur de plan chaque fois que vous l’exécutez.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-466">You can compose these filters over the IQueryable results of a CompiledQuery, but doing so will result in the new query going through the plan compiler every time you execute it.</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="cb5e9-467">Pour éviter cette nouvelle compilation, vous pouvez réécrire le CompiledQuery pour prendre en compte les filtres possibles :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-467">To avoid this re-compilation, you can rewrite the CompiledQuery to take the possible filters into account:</span></span>

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

<span data-ttu-id="cb5e9-468">Qui serait appelé dans l’interface utilisateur comme :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-468">Which would be invoked in the UI like:</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="cb5e9-469">Un compromis ici est que la commande de magasin générée disposera toujours des filtres avec les vérifications de valeur null, mais celles-ci doivent être assez simples pour que le serveur de base de données les optimise :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-469">A tradeoff here is the generated store command will always have the filters with the null checks, but these should be fairly simple for the database server to optimize:</span></span>

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a><span data-ttu-id="cb5e9-470">3,4 mise en cache des métadonnées</span><span class="sxs-lookup"><span data-stu-id="cb5e9-470">3.4 Metadata caching</span></span>

<span data-ttu-id="cb5e9-471">Le Entity Framework prend également en charge la mise en cache des métadonnées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-471">The Entity Framework also supports Metadata caching.</span></span> <span data-ttu-id="cb5e9-472">Il s’agit essentiellement d’une mise en cache des informations de type et des informations de mappage de type à base de données entre différentes connexions au même modèle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-472">This is essentially caching of type information and type-to-database mapping information across different connections to the same model.</span></span> <span data-ttu-id="cb5e9-473">Le cache des métadonnées est unique par AppDomain.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-473">The Metadata cache is unique per AppDomain.</span></span>

#### <a name="341-metadata-caching-algorithm"></a><span data-ttu-id="cb5e9-474">3.4.1-algorithme de mise en cache des métadonnées</span><span class="sxs-lookup"><span data-stu-id="cb5e9-474">3.4.1 Metadata Caching algorithm</span></span>

1.  <span data-ttu-id="cb5e9-475">Les informations de métadonnées d’un modèle sont stockées dans un ItemCollection pour chaque EntityConnection.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-475">Metadata information for a model is stored in an ItemCollection for each EntityConnection.</span></span>
    -   <span data-ttu-id="cb5e9-476">En guise de note, il existe différents objets ItemCollection pour différentes parties du modèle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-476">As a side note, there are different ItemCollection objects for different parts of the model.</span></span> <span data-ttu-id="cb5e9-477">Par exemple, StoreItemCollections contient les informations sur le modèle de base de données ; ObjectItemCollection contient des informations sur le modèle de données ; EdmItemCollection contient des informations sur le modèle conceptuel.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-477">For example, StoreItemCollections contains the information about the database model; ObjectItemCollection contains information about the data model; EdmItemCollection contains information about the conceptual model.</span></span>

2.  <span data-ttu-id="cb5e9-478">Si deux connexions utilisent la même chaîne de connexion, elles partagent la même instance de ItemCollection.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-478">If two connections use the same connection string, they will share the same ItemCollection instance.</span></span>
3.  <span data-ttu-id="cb5e9-479">Fonctionnellement équivalente mais les chaînes de connexion différentes textuellement peuvent entraîner des caches de métadonnées différents.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-479">Functionally equivalent but textually different connection strings may result in different metadata caches.</span></span> <span data-ttu-id="cb5e9-480">Comme nous jetons des chaînes de connexion, il suffit de modifier l’ordre des jetons pour créer des métadonnées partagées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-480">We do tokenize connection strings, so simply changing the order of the tokens should result in shared metadata.</span></span> <span data-ttu-id="cb5e9-481">Toutefois, deux chaînes de connexion apparemment fonctionnellement identiques peuvent ne pas être évaluées comme identiques après la création de jetons.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-481">But two connection strings that seem functionally the same may not be evaluated as identical after tokenization.</span></span>
4.  <span data-ttu-id="cb5e9-482">L’utilisation de ItemCollection est régulièrement vérifiée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-482">The ItemCollection is periodically checked for use.</span></span> <span data-ttu-id="cb5e9-483">S’il est déterminé qu’un espace de travail n’a pas été accédé récemment, il est marqué pour nettoyage lors du prochain balayage du cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-483">If it is determined that a workspace has not been accessed recently, it will be marked for cleanup on the next cache sweep.</span></span>
5.  <span data-ttu-id="cb5e9-484">Le simple fait de créer un EntityConnection entraîne la création d’un cache de métadonnées (bien que les collections d’éléments qu’il contient ne soient pas initialisées tant que la connexion n’est pas ouverte).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-484">Merely creating an EntityConnection will cause a metadata cache to be created (though the item collections in it will not be initialized until the connection is opened).</span></span> <span data-ttu-id="cb5e9-485">Cet espace de travail reste en mémoire jusqu’à ce que l’algorithme de mise en cache détermine qu’il n’est pas « en cours d’utilisation ».</span><span class="sxs-lookup"><span data-stu-id="cb5e9-485">This workspace will remain in-memory until the caching algorithm determines it is not “in use”.</span></span>

<span data-ttu-id="cb5e9-486">L’équipe de conseil clientèle a écrit un billet de blog qui décrit la conservation d’une référence à un ItemCollection afin d’éviter la « désapprobation » lors de l’utilisation de modèles de grande taille : \<https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-486">The Customer Advisory Team has written a blog post that describes holding a reference to an ItemCollection in order to avoid "deprecation" when using large models: \<https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services>.</span></span>

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a><span data-ttu-id="cb5e9-487">3.4.2 la relation entre la mise en cache des métadonnées et la mise en cache du plan de requête</span><span class="sxs-lookup"><span data-stu-id="cb5e9-487">3.4.2 The relationship between Metadata Caching and Query Plan Caching</span></span>

<span data-ttu-id="cb5e9-488">L’instance du cache du plan de requête se trouve dans l’ItemCollection des types de magasins de MetadataWorkspace.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-488">The query plan cache instance lives in the MetadataWorkspace's ItemCollection of store types.</span></span> <span data-ttu-id="cb5e9-489">Cela signifie que les commandes de stockage mises en cache sont utilisées pour les requêtes sur tout contexte instancié à l’aide d’un MetadataWorkspace donné.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-489">This means that cached store commands will be used for queries against any context instantiated using a given MetadataWorkspace.</span></span> <span data-ttu-id="cb5e9-490">Cela signifie également que si vous avez deux chaînes de connexion qui sont légèrement différentes et ne correspondent pas après la création de jetons, vous aurez des instances de cache de plan de requête différentes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-490">It also means that if you have two connections strings that are slightly different and don't match after tokenizing, you will have different query plan cache instances.</span></span>

### <a name="35-results-caching"></a><span data-ttu-id="cb5e9-491">3,5 mise en cache des résultats</span><span class="sxs-lookup"><span data-stu-id="cb5e9-491">3.5 Results caching</span></span>

<span data-ttu-id="cb5e9-492">Avec la mise en cache des résultats (également appelée « mise en cache de second niveau »), vous conservez les résultats des requêtes dans un cache local.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-492">With results caching (also known as "second-level caching"), you keep the results of queries in a local cache.</span></span> <span data-ttu-id="cb5e9-493">Lors de l’émission d’une requête, vous voyez d’abord si les résultats sont disponibles localement avant d’effectuer une requête sur le magasin.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-493">When issuing a query, you first see if the results are available locally before you query against the store.</span></span> <span data-ttu-id="cb5e9-494">Si la mise en cache des résultats n’est pas directement prise en charge par Entity Framework, il est possible d’ajouter un cache de second niveau à l’aide d’un fournisseur d’encapsulation.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-494">While results caching isn't directly supported by Entity Framework, it's possible to add a second level cache by using a wrapping provider.</span></span> <span data-ttu-id="cb5e9-495">Un exemple de fournisseur d’encapsulation avec un cache de second niveau est le [cache de second niveau de Alachisoft Entity Framework basé sur NCache](https://www.alachisoft.com/ncache/entity-framework.html).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-495">An example wrapping provider with a second-level cache is Alachisoft's [Entity Framework Second Level Cache based on NCache](https://www.alachisoft.com/ncache/entity-framework.html).</span></span>

<span data-ttu-id="cb5e9-496">Cette implémentation de la mise en cache de second niveau est une fonctionnalité injectée qui a lieu une fois que l’expression LINQ a été évaluée (et funcletized) et que le plan d’exécution de la requête est calculé ou récupéré à partir du cache de premier niveau.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-496">This implementation of second-level caching is an injected functionality that takes place after the LINQ expression has been evaluated (and funcletized) and the query execution plan is computed or retrieved from the first-level cache.</span></span> <span data-ttu-id="cb5e9-497">Le cache de second niveau stocke alors uniquement les résultats bruts de la base de données, de sorte que le pipeline de matérialisation est toujours exécuté par la suite.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-497">The second-level cache will then store only the raw database results, so the materialization pipeline still executes afterwards.</span></span>

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a><span data-ttu-id="cb5e9-498">3.5.1 Références supplémentaires pour la mise en cache des résultats avec le fournisseur d’encapsulation</span><span class="sxs-lookup"><span data-stu-id="cb5e9-498">3.5.1 Additional references for results caching with the wrapping provider</span></span>

-   <span data-ttu-id="cb5e9-499">Julie Lerman a écrit un article « mise en cache de second niveau dans Entity Framework et Windows Azure » qui inclut la mise à jour de l’exemple de fournisseur d’encapsulation pour utiliser la mise en cache de Windows Server AppFabric : [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-499">Julie Lerman has written a "Second-Level Caching in Entity Framework and Windows Azure" MSDN article that includes how to update the sample wrapping provider to use Windows Server AppFabric caching: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span></span>
-   <span data-ttu-id="cb5e9-500">Si vous utilisez Entity Framework 5, le blog de l’équipe dispose d’une publication qui décrit comment faire en sorte que les tâches s’exécutent avec le fournisseur de mise en cache pour Entity Framework 5 : \<https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-500">If you are working with Entity Framework 5, the team blog has a post that describes how to get things running with the caching provider for Entity Framework 5: \<https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider>.</span></span> <span data-ttu-id="cb5e9-501">Il comprend également un modèle T4 pour vous aider à automatiser l’ajout de la mise en cache de 2e niveau à votre projet.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-501">It also includes a T4 template to help automate adding the 2nd-level caching to your project.</span></span>

## <a name="4-autocompiled-queries"></a><span data-ttu-id="cb5e9-502">4 requêtes autocompilées</span><span class="sxs-lookup"><span data-stu-id="cb5e9-502">4 Autocompiled Queries</span></span>

<span data-ttu-id="cb5e9-503">Lorsqu’une requête est émise sur une base de données à l’aide d’Entity Framework, elle doit passer par une série d’étapes avant de matérialiser les résultats ; une de ces étapes est la compilation des requêtes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-503">When a query is issued against a database using Entity Framework, it must go through a series of steps before actually materializing the results; one such step is Query Compilation.</span></span> <span data-ttu-id="cb5e9-504">Entity SQL requêtes étaient connues pour avoir de bonnes performances, car elles sont automatiquement mises en cache. par conséquent, la deuxième ou la troisième fois que vous exécutez la même requête, elle peut ignorer le compilateur de plan et utiliser le plan mis en cache à la place.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-504">Entity SQL queries were known to have good performance as they are automatically cached, so the second or third time you execute the same query it can skip the plan compiler and use the cached plan instead.</span></span>

<span data-ttu-id="cb5e9-505">Entity Framework 5 a également introduit la mise en cache automatique pour les requêtes LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-505">Entity Framework 5 introduced automatic caching for LINQ to Entities queries as well.</span></span> <span data-ttu-id="cb5e9-506">Dans les éditions précédentes de Entity Framework la création d’un CompiledQuery pour accélérer vos performances était une pratique courante, car cela permet de mettre en cache votre requête LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-506">In past editions of Entity Framework creating a CompiledQuery to speed your performance was a common practice, as this would make your LINQ to Entities query cacheable.</span></span> <span data-ttu-id="cb5e9-507">Étant donné que la mise en cache s’effectue automatiquement sans l’utilisation d’un CompiledQuery, nous appelons cette fonctionnalité « requêtes autocompilées ».</span><span class="sxs-lookup"><span data-stu-id="cb5e9-507">Since caching is now done automatically without the use of a CompiledQuery, we call this feature “autocompiled queries”.</span></span> <span data-ttu-id="cb5e9-508">Pour plus d’informations sur le cache du plan de requête et ses mécanismes, consultez mise en cache des plans de requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-508">For more information about the query plan cache and its mechanics, see Query Plan Caching.</span></span>

<span data-ttu-id="cb5e9-509">Entity Framework détecte quand une requête doit être recompilée, et le fait lorsque la requête est appelée même si elle a été compilée auparavant.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-509">Entity Framework detects when a query requires to be recompiled, and does so when the query is invoked even if it had been compiled before.</span></span> <span data-ttu-id="cb5e9-510">Les conditions courantes qui provoquent la recompilation de la requête sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-510">Common conditions that cause the query to be recompiled are:</span></span>

-   <span data-ttu-id="cb5e9-511">Modification du MergeOption associé à votre requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-511">Changing the MergeOption associated to your query.</span></span> <span data-ttu-id="cb5e9-512">La requête mise en cache ne sera pas utilisée, à la place, le compilateur de plan s’exécutera à nouveau et le plan nouvellement créé est mis en cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-512">The cached query will not be used, instead the plan compiler will run again and the newly created plan gets cached.</span></span>
-   <span data-ttu-id="cb5e9-513">Modification de la valeur de ContextOptions. UseCSharpNullComparisonBehavior.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-513">Changing the value of ContextOptions.UseCSharpNullComparisonBehavior.</span></span> <span data-ttu-id="cb5e9-514">Vous avez le même effet que la modification de MergeOption.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-514">You get the same effect as changing the MergeOption.</span></span>

<span data-ttu-id="cb5e9-515">D’autres conditions peuvent empêcher votre requête d’utiliser le cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-515">Other conditions can prevent your query from using the cache.</span></span> <span data-ttu-id="cb5e9-516">Voici des exemples courants :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-516">Common examples are:</span></span>

-   <span data-ttu-id="cb5e9-517">Utilisation de IEnumerable &lt; T &gt; . Contains &lt; &gt; (valeur T).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-517">Using IEnumerable&lt;T&gt;.Contains&lt;&gt;(T value).</span></span>
-   <span data-ttu-id="cb5e9-518">Utilisation de fonctions qui produisent des requêtes avec des constantes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-518">Using functions that produce queries with constants.</span></span>
-   <span data-ttu-id="cb5e9-519">Utilisation des propriétés d’un objet non mappé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-519">Using the properties of a non-mapped object.</span></span>
-   <span data-ttu-id="cb5e9-520">Liaison de votre requête à une autre requête qui nécessite d’être recompilée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-520">Linking your query to another query that requires to be recompiled.</span></span>

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a><span data-ttu-id="cb5e9-521">4,1 avec IEnumerable &lt; T &gt; . Contient &lt; t &gt; (valeur t)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-521">4.1 Using IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value)</span></span>

<span data-ttu-id="cb5e9-522">Entity Framework ne met pas en cache les requêtes qui appellent IEnumerable &lt; T &gt; . Contient &lt; t &gt; (valeur t) par rapport à une collection en mémoire, étant donné que les valeurs de la collection sont considérées comme volatiles.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-522">Entity Framework does not cache queries that invoke IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) against an in-memory collection, since the values of the collection are considered volatile.</span></span> <span data-ttu-id="cb5e9-523">L’exemple de requête suivant ne sera pas mis en cache et sera donc toujours traité par le compilateur de plan :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-523">The following example query will not be cached, so it will always be processed by the plan compiler:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="cb5e9-524">Notez que la taille de l’IEnumerable par rapport à laquelle est exécutée détermine la vitesse de compilation de votre requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-524">Note that the size of the IEnumerable against which Contains is executed determines how fast or how slow your query is compiled.</span></span> <span data-ttu-id="cb5e9-525">Les performances peuvent être considérablement affectées lors de l’utilisation de collections volumineuses, telles que celle illustrée dans l’exemple ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-525">Performance can suffer significantly when using large collections such as the one shown in the example above.</span></span>

<span data-ttu-id="cb5e9-526">Entity Framework 6 contient des optimisations de la façon dont IEnumerable &lt; T &gt; . Contains &lt; &gt; (valeur t) fonctionne lorsque les requêtes sont exécutées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-526">Entity Framework 6 contains optimizations to the way IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) works when queries are executed.</span></span> <span data-ttu-id="cb5e9-527">Le code SQL généré est beaucoup plus rapide à produire et plus lisible, et dans la plupart des cas, il s’exécute également plus rapidement sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-527">The SQL code that is generated is much faster to produce and more readable, and in most cases it also executes faster in the server.</span></span>

### <a name="42-using-functions-that-produce-queries-with-constants"></a><span data-ttu-id="cb5e9-528">4,2 utilisation de fonctions qui produisent des requêtes avec des constantes</span><span class="sxs-lookup"><span data-stu-id="cb5e9-528">4.2 Using functions that produce queries with constants</span></span>

<span data-ttu-id="cb5e9-529">Les opérateurs LINQ Skip (), Take (), Contains () et DefautIfEmpty () ne génèrent pas de requêtes SQL avec des paramètres, mais placent les valeurs qui leur sont passées en tant que constantes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-529">The Skip(), Take(), Contains() and DefautIfEmpty() LINQ operators do not produce SQL queries with parameters but instead put the values passed to them as constants.</span></span> <span data-ttu-id="cb5e9-530">Pour cette raison, les requêtes qui peuvent sinon être identiques finissent par polluer le cache du plan de requête, à la fois sur la pile EF et sur le serveur de base de données, et ne sont pas réutilisées, sauf si les mêmes constantes sont utilisées lors de l’exécution d’une requête ultérieure.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-530">Because of this, queries that might otherwise be identical end up polluting the query plan cache, both on the EF stack and on the database server, and do not get reutilized unless the same constants are used in a subsequent query execution.</span></span> <span data-ttu-id="cb5e9-531">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-531">For example:</span></span>

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="cb5e9-532">Dans cet exemple, chaque fois que cette requête est exécutée avec une valeur différente pour ID, la requête est compilée dans un nouveau plan.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-532">In this example, each time this query is executed with a different value for id the query will be compiled into a new plan.</span></span>

<span data-ttu-id="cb5e9-533">En particulier, soyez attentif à l’utilisation de Skip et Take lors de la pagination.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-533">In particular pay attention to the use of Skip and Take when doing paging.</span></span> <span data-ttu-id="cb5e9-534">Dans EF6, ces méthodes ont une surcharge lambda qui rend effectivement le plan de requête mis en cache réutilisable, car EF peut capturer les variables passées à ces méthodes et les traduire en SQLparameters.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-534">In EF6 these methods have a lambda overload that effectively makes the cached query plan reusable because EF can capture variables passed to these methods and translate them to SQLparameters.</span></span> <span data-ttu-id="cb5e9-535">Cela permet également de conserver le nettoyeur de cache, car dans le cas contraire, chaque requête avec une constante différente pour Skip et Take obtient sa propre entrée de cache de plan de requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-535">This also helps keep the cache cleaner since otherwise each query with a different constant for Skip and Take would get its own query plan cache entry.</span></span>

<span data-ttu-id="cb5e9-536">Considérez le code suivant, qui est non optimal, mais qui est uniquement destiné à illustrer cette classe de requêtes :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-536">Consider the following code, which is suboptimal but is only meant to exemplify this class of queries:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="cb5e9-537">Une version plus rapide de ce même code implique l’appel de SKIP avec une expression lambda :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-537">A faster version of this same code would involve calling Skip with a lambda:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="cb5e9-538">Le second extrait de code peut s’exécuter jusqu’à 11% plus rapidement, car le même plan de requête est utilisé chaque fois que la requête est exécutée, ce qui permet d’économiser du temps processeur et d’éviter de polluer le cache des requêtes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-538">The second snippet may run up to 11% faster because the same query plan is used every time the query is run, which saves CPU time and avoids polluting the query cache.</span></span> <span data-ttu-id="cb5e9-539">En outre, étant donné que le paramètre à ignorer se trouve dans une fermeture, le code peut également ressembler à ceci :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-539">Furthermore, because the parameter to Skip is in a closure the code might as well look like this now:</span></span>

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a><span data-ttu-id="cb5e9-540">4,3 utilisation des propriétés d’un objet non mappé</span><span class="sxs-lookup"><span data-stu-id="cb5e9-540">4.3 Using the properties of a non-mapped object</span></span>

<span data-ttu-id="cb5e9-541">Quand une requête utilise les propriétés d’un type d’objet non mappé comme paramètre, la requête n’est pas mise en cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-541">When a query uses the properties of a non-mapped object type as a parameter then the query will not get cached.</span></span> <span data-ttu-id="cb5e9-542">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-542">For example:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

<span data-ttu-id="cb5e9-543">Dans cet exemple, supposons que la classe NonMappedType ne fait pas partie du modèle d’entité.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-543">In this example, assume that class NonMappedType is not part of the Entity model.</span></span> <span data-ttu-id="cb5e9-544">Cette requête peut facilement être modifiée pour ne pas utiliser un type non mappé et utiliser à la place une variable locale comme paramètre de la requête :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-544">This query can easily be changed to not use a non-mapped type and instead use a local variable as the parameter to the query:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="cb5e9-545">Dans ce cas, la requête peut être mise en cache et tirer parti du cache du plan de requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-545">In this case, the query will be able to get cached and will benefit from the query plan cache.</span></span>

### <a name="44-linking-to-queries-that-require-recompiling"></a><span data-ttu-id="cb5e9-546">4,4 liaison à des requêtes qui nécessitent une recompilation</span><span class="sxs-lookup"><span data-stu-id="cb5e9-546">4.4 Linking to queries that require recompiling</span></span>

<span data-ttu-id="cb5e9-547">En suivant le même exemple que ci-dessus, si vous avez une deuxième requête qui s’appuie sur une requête qui doit être recompilée, la totalité de votre seconde requête sera également recompilée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-547">Following the same example as above, if you have a second query that relies on a query that needs to be recompiled, your entire second query will also be recompiled.</span></span> <span data-ttu-id="cb5e9-548">Voici un exemple illustrant ce scénario :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-548">Here’s an example to illustrate this scenario:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

<span data-ttu-id="cb5e9-549">L’exemple est générique, mais il illustre la façon dont la liaison à firstQuery entraîne l’impossibilité pour secondQuery de se mettre en cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-549">The example is generic, but it illustrates how linking to firstQuery is causing secondQuery to be unable to get cached.</span></span> <span data-ttu-id="cb5e9-550">Si firstQuery n’était pas une requête nécessitant une recompilation, secondQuery aurait été mis en cache.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-550">If firstQuery had not been a query that requires recompiling, then secondQuery would have been cached.</span></span>

## <a name="5-notracking-queries"></a><span data-ttu-id="cb5e9-551">5 requêtes de non-suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-551">5 NoTracking Queries</span></span>

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a><span data-ttu-id="cb5e9-552">5,1 désactivation du suivi des modifications pour réduire la surcharge de gestion de l’État</span><span class="sxs-lookup"><span data-stu-id="cb5e9-552">5.1 Disabling change tracking to reduce state management overhead</span></span>

<span data-ttu-id="cb5e9-553">Si vous êtes dans un scénario en lecture seule et que vous souhaitez éviter la surcharge liée au chargement des objets dans le ObjectStateManager, vous pouvez émettre des requêtes « aucune suivi ».</span><span class="sxs-lookup"><span data-stu-id="cb5e9-553">If you are in a read-only scenario and want to avoid the overhead of loading the objects into the ObjectStateManager, you can issue "No Tracking" queries.</span></span><span data-ttu-id="cb5e9-554">Le suivi des modifications peut être désactivé au niveau de la requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-554">  Change tracking can be disabled at the query level.</span></span>

<span data-ttu-id="cb5e9-555">Notez, toutefois, que si vous désactivez le suivi des modifications, vous désactivez efficacement le cache d’objets.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-555">Note though that by disabling change tracking you are effectively turning off the object cache.</span></span> <span data-ttu-id="cb5e9-556">Lorsque vous interrogez une entité, nous ne pouvons pas ignorer la matérialisation en extrayant les résultats de requête matérialisés précédemment à partir de ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-556">When you query for an entity, we can't skip materialization by pulling the previously-materialized query results from the ObjectStateManager.</span></span> <span data-ttu-id="cb5e9-557">Si vous interrogez à plusieurs reprises les mêmes entités sur le même contexte, vous pouvez en fait voir un avantage en matière de performances de l’activation du suivi des modifications.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-557">If you are repeatedly querying for the same entities on the same context, you might actually see a performance benefit from enabling change tracking.</span></span>

<span data-ttu-id="cb5e9-558">Lors de l’interrogation à l’aide d’ObjectContext, les instances ObjectQuery et ObjectSet se souviennent d’un MergeOption une fois qu’il est défini, et les requêtes qui y sont composées héritent du MergeOption effectif de la requête parente.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-558">When querying using ObjectContext, ObjectQuery and ObjectSet instances will remember a MergeOption once it is set, and queries that are composed on them will inherit the effective MergeOption of the parent query.</span></span> <span data-ttu-id="cb5e9-559">Lors de l’utilisation de DbContext, le suivi peut être désactivé en appelant le modificateur AsNoTracking () sur DbSet.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-559">When using DbContext, tracking can be disabled by calling the AsNoTracking() modifier on the DbSet.</span></span>

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a><span data-ttu-id="cb5e9-560">5.1.1 désactivation du suivi des modifications pour une requête lors de l’utilisation de DbContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-560">5.1.1 Disabling change tracking for a query when using DbContext</span></span>

<span data-ttu-id="cb5e9-561">Vous pouvez basculer le mode d’une requête pour qu’elle soit très suivie en chaîné un appel à la méthode AsNoTracking () dans la requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-561">You can switch the mode of a query to NoTracking by chaining a call to the AsNoTracking() method in the query.</span></span> <span data-ttu-id="cb5e9-562">Contrairement à ObjectQuery, les classes DbSet et DbQuery de l’API DbContext n’ont pas de propriété mutable pour MergeOption.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-562">Unlike ObjectQuery, the DbSet and DbQuery classes in the DbContext API don’t have a mutable property for the MergeOption.</span></span>

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a><span data-ttu-id="cb5e9-563">5.1.2 désactivation du suivi des modifications au niveau de la requête à l’aide d’ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-563">5.1.2 Disabling change tracking at the query level using ObjectContext</span></span>

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a><span data-ttu-id="cb5e9-564">5.1.3 désactivation du suivi des modifications pour un ensemble d’entités complet à l’aide d’ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-564">5.1.3 Disabling change tracking for an entire entity set using ObjectContext</span></span>

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a><span data-ttu-id="cb5e9-565">5,2 métriques de test illustrant l’avantage en matière de performances des requêtes NoTracking</span><span class="sxs-lookup"><span data-stu-id="cb5e9-565">5.2 Test Metrics demonstrating the performance benefit of NoTracking queries</span></span>

<span data-ttu-id="cb5e9-566">Dans ce test, nous examinons le coût du remplissage de la ObjectStateManager en comparant le suivi à la non-suivi des requêtes pour le modèle Navision.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-566">In this test we look at the cost of filling the ObjectStateManager by comparing Tracking to NoTracking queries for the Navision model.</span></span> <span data-ttu-id="cb5e9-567">Reportez-vous à l’annexe pour obtenir une description du modèle Navision et des types de requêtes qui ont été exécutés.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-567">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="cb5e9-568">Dans ce test, nous parcourons la liste des requêtes et les exécutons une fois.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-568">In this test, we iterate through the list of queries and execute each one once.</span></span> <span data-ttu-id="cb5e9-569">Nous avons exécuté deux variantes du test, une fois avec les requêtes NoTracking et une fois avec l’option de fusion par défaut « AppendOnly ».</span><span class="sxs-lookup"><span data-stu-id="cb5e9-569">We ran two variations of the test, once with NoTracking queries and once with the default merge option of "AppendOnly".</span></span> <span data-ttu-id="cb5e9-570">Nous avons exécuté chaque variante 3 fois et prenons la valeur moyenne des exécutions.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-570">We ran each variation 3 times and take the mean value of the runs.</span></span> <span data-ttu-id="cb5e9-571">Entre les tests, nous effacons le cache des requêtes sur le SQL Server et réduisons la base de données tempdb en exécutant les commandes suivantes :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-571">Between the tests we clear the query cache on the SQL Server and shrink the tempdb by running the following commands:</span></span>

1.  <span data-ttu-id="cb5e9-572">DBCC DROPCLEANBUFFERS</span><span class="sxs-lookup"><span data-stu-id="cb5e9-572">DBCC DROPCLEANBUFFERS</span></span>
2.  <span data-ttu-id="cb5e9-573">DBCC FREEPROCCACHE</span><span class="sxs-lookup"><span data-stu-id="cb5e9-573">DBCC FREEPROCCACHE</span></span>
3.  <span data-ttu-id="cb5e9-574">DBCC SHRINKDATABASE (tempdb, 0)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-574">DBCC SHRINKDATABASE (tempdb, 0)</span></span>

<span data-ttu-id="cb5e9-575">Résultats des tests, median sur 3 s’exécute :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-575">Test Results, median over 3 runs:</span></span>

|                        | <span data-ttu-id="cb5e9-576">AUCUN SUIVI-PLAGE DE TRAVAIL</span><span class="sxs-lookup"><span data-stu-id="cb5e9-576">NO TRACKING – WORKING SET</span></span> | <span data-ttu-id="cb5e9-577">AUCUN SUIVI – HEURE</span><span class="sxs-lookup"><span data-stu-id="cb5e9-577">NO TRACKING – TIME</span></span> | <span data-ttu-id="cb5e9-578">AJOUTER UNIQUEMENT-PLAGE DE TRAVAIL</span><span class="sxs-lookup"><span data-stu-id="cb5e9-578">APPEND ONLY – WORKING SET</span></span> | <span data-ttu-id="cb5e9-579">AJOUTER UNIQUEMENT – HEURE</span><span class="sxs-lookup"><span data-stu-id="cb5e9-579">APPEND ONLY – TIME</span></span> |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| <span data-ttu-id="cb5e9-580">**Entity Framework 5**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-580">**Entity Framework 5**</span></span> | <span data-ttu-id="cb5e9-581">460361728</span><span class="sxs-lookup"><span data-stu-id="cb5e9-581">460361728</span></span>                 | <span data-ttu-id="cb5e9-582">1163536 ms</span><span class="sxs-lookup"><span data-stu-id="cb5e9-582">1163536 ms</span></span>         | <span data-ttu-id="cb5e9-583">596545536</span><span class="sxs-lookup"><span data-stu-id="cb5e9-583">596545536</span></span>                 | <span data-ttu-id="cb5e9-584">1273042 ms</span><span class="sxs-lookup"><span data-stu-id="cb5e9-584">1273042 ms</span></span>         |
| <span data-ttu-id="cb5e9-585">**Entity Framework 6**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-585">**Entity Framework 6**</span></span> | <span data-ttu-id="cb5e9-586">647127040</span><span class="sxs-lookup"><span data-stu-id="cb5e9-586">647127040</span></span>                 | <span data-ttu-id="cb5e9-587">190228 ms</span><span class="sxs-lookup"><span data-stu-id="cb5e9-587">190228 ms</span></span>          | <span data-ttu-id="cb5e9-588">832798720</span><span class="sxs-lookup"><span data-stu-id="cb5e9-588">832798720</span></span>                 | <span data-ttu-id="cb5e9-589">195521 ms</span><span class="sxs-lookup"><span data-stu-id="cb5e9-589">195521 ms</span></span>          |

<span data-ttu-id="cb5e9-590">Entity Framework 5 aura un faible encombrement mémoire à la fin de l’exécution que Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-590">Entity Framework 5 will have a smaller memory footprint at the end of the run than Entity Framework 6 does.</span></span> <span data-ttu-id="cb5e9-591">La mémoire supplémentaire consommée par Entity Framework 6 est le résultat de structures de mémoire et de code supplémentaires qui activent de nouvelles fonctionnalités et de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-591">The additional memory consumed by Entity Framework 6 is the result of additional memory structures and code that enable new features and better performance.</span></span>

<span data-ttu-id="cb5e9-592">Il y a également une différence évidente en matière d’encombrement mémoire lors de l’utilisation de ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-592">There’s also a clear difference in memory footprint when using the ObjectStateManager.</span></span> <span data-ttu-id="cb5e9-593">Entity Framework 5 a augmenté son empreinte de 30% pendant le suivi de toutes les entités que nous avons matérialisées à partir de la base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-593">Entity Framework 5 increased its footprint by 30% when keeping track of all the entities we materialized from the database.</span></span> <span data-ttu-id="cb5e9-594">Entity Framework 6 a augmenté son empreinte de 28%.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-594">Entity Framework 6 increased its footprint by 28% when doing so.</span></span>

<span data-ttu-id="cb5e9-595">En termes de temps, Entity Framework 6 s’exécute Entity Framework 5 dans ce test par une marge importante.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-595">In terms of time, Entity Framework 6 outperforms Entity Framework 5 in this test by a large margin.</span></span> <span data-ttu-id="cb5e9-596">Entity Framework 6 a terminé le test en environ 16% du temps consommé par Entity Framework 5.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-596">Entity Framework 6 completed the test in roughly 16% of the time consumed by Entity Framework 5.</span></span> <span data-ttu-id="cb5e9-597">En outre, Entity Framework 5 prend plus de 9% de temps pour s’exécuter lorsque le ObjectStateManager est utilisé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-597">Additionally, Entity Framework 5 takes 9% more time to complete when the ObjectStateManager is being used.</span></span> <span data-ttu-id="cb5e9-598">En comparaison, Entity Framework 6 utilise 3% de temps supplémentaire lors de l’utilisation de ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-598">In comparison, Entity Framework 6 is using 3% more time when using the ObjectStateManager.</span></span>

## <a name="6-query-execution-options"></a><span data-ttu-id="cb5e9-599">6 options d’exécution de requête</span><span class="sxs-lookup"><span data-stu-id="cb5e9-599">6 Query Execution Options</span></span>

<span data-ttu-id="cb5e9-600">Entity Framework propose différentes façons d’interroger.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-600">Entity Framework offers several different ways to query.</span></span> <span data-ttu-id="cb5e9-601">Nous allons examiner les options suivantes, comparer les avantages et les inconvénients de chacun et examiner leurs caractéristiques de performances :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-601">We'll take a look at the following options, compare the pros and cons of each, and examine their performance characteristics:</span></span>

-   <span data-ttu-id="cb5e9-602">LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-602">LINQ to Entities.</span></span>
-   <span data-ttu-id="cb5e9-603">Aucune LINQ to Entities de suivi.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-603">No Tracking LINQ to Entities.</span></span>
-   <span data-ttu-id="cb5e9-604">Entity SQL sur un ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-604">Entity SQL over an ObjectQuery.</span></span>
-   <span data-ttu-id="cb5e9-605">Entity SQL sur un EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-605">Entity SQL over an EntityCommand.</span></span>
-   <span data-ttu-id="cb5e9-606">ExecuteStoreQuery.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-606">ExecuteStoreQuery.</span></span>
-   <span data-ttu-id="cb5e9-607">SqlQuery.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-607">SqlQuery.</span></span>
-   <span data-ttu-id="cb5e9-608">CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-608">CompiledQuery.</span></span>

### <a name="61-linq-to-entities-queries"></a><span data-ttu-id="cb5e9-609">6,1 requêtes de LINQ to Entities</span><span class="sxs-lookup"><span data-stu-id="cb5e9-609">6.1       LINQ to Entities queries</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="cb5e9-610">**Avantages**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-610">**Pros**</span></span>

-   <span data-ttu-id="cb5e9-611">Adapté aux opérations CUD.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-611">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="cb5e9-612">Objets entièrement matérialisés.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-612">Fully materialized objects.</span></span>
-   <span data-ttu-id="cb5e9-613">Plus simple à écrire avec la syntaxe intégrée dans le langage de programmation.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-613">Simplest to write with syntax built into the programming language.</span></span>
-   <span data-ttu-id="cb5e9-614">Bonnes performances.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-614">Good performance.</span></span>

<span data-ttu-id="cb5e9-615">**Inconvénients**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-615">**Cons**</span></span>

-   <span data-ttu-id="cb5e9-616">Certaines restrictions techniques, telles que :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-616">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="cb5e9-617">Les modèles utilisant DefaultIfEmpty pour les requêtes de jointure externe génèrent des requêtes plus complexes que les instructions de jointure externe simples dans Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-617">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="cb5e9-618">Vous ne pouvez toujours pas utiliser LIKE avec les critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-618">You still can’t use LIKE with general pattern matching.</span></span>

### <a name="62-no-tracking-linq-to-entities-queries"></a><span data-ttu-id="cb5e9-619">6,2 aucune requête de LINQ to Entities de suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-619">6.2       No Tracking LINQ to Entities queries</span></span>

<span data-ttu-id="cb5e9-620">Lorsque le contexte dérive de ObjectContext :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-620">When the context derives ObjectContext:</span></span>

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="cb5e9-621">Lorsque le contexte dérive DbContext :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-621">When the context derives DbContext:</span></span>

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="cb5e9-622">**Avantages**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-622">**Pros**</span></span>

-   <span data-ttu-id="cb5e9-623">Performances améliorées par rapport aux requêtes LINQ normales.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-623">Improved performance over regular LINQ queries.</span></span>
-   <span data-ttu-id="cb5e9-624">Objets entièrement matérialisés.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-624">Fully materialized objects.</span></span>
-   <span data-ttu-id="cb5e9-625">Plus simple à écrire avec la syntaxe intégrée dans le langage de programmation.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-625">Simplest to write with syntax built into the programming language.</span></span>

<span data-ttu-id="cb5e9-626">**Inconvénients**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-626">**Cons**</span></span>

-   <span data-ttu-id="cb5e9-627">Non adapté aux opérations CUD.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-627">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="cb5e9-628">Certaines restrictions techniques, telles que :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-628">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="cb5e9-629">Les modèles utilisant DefaultIfEmpty pour les requêtes de jointure externe génèrent des requêtes plus complexes que les instructions de jointure externe simples dans Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-629">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="cb5e9-630">Vous ne pouvez toujours pas utiliser LIKE avec les critères spéciaux.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-630">You still can’t use LIKE with general pattern matching.</span></span>

<span data-ttu-id="cb5e9-631">Notez que les requêtes qui projetent les propriétés scalaires ne sont pas suivies, même si le NoTracking n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-631">Note that queries that project scalar properties are not tracked even if the NoTracking is not specified.</span></span> <span data-ttu-id="cb5e9-632">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-632">For example:</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

<span data-ttu-id="cb5e9-633">Cette requête particulière ne spécifie pas explicitement la non-suivi, mais dans la mesure où elle ne matérialisét pas un type connu du gestionnaire d’état d’objet, le résultat matérialisé n’est pas suivi.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-633">This particular query doesn’t explicitly specify being NoTracking, but since it’s not materializing a type that’s known to the object state manager then the materialized result is not tracked.</span></span>

### <a name="63-entity-sql-over-an-objectquery"></a><span data-ttu-id="cb5e9-634">6,3 Entity SQL sur un ObjectQuery</span><span class="sxs-lookup"><span data-stu-id="cb5e9-634">6.3       Entity SQL over an ObjectQuery</span></span>

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

<span data-ttu-id="cb5e9-635">**Avantages**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-635">**Pros**</span></span>

-   <span data-ttu-id="cb5e9-636">Adapté aux opérations CUD.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-636">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="cb5e9-637">Objets entièrement matérialisés.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-637">Fully materialized objects.</span></span>
-   <span data-ttu-id="cb5e9-638">Prend en charge la mise en cache du plan de requête.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-638">Supports query plan caching.</span></span>

<span data-ttu-id="cb5e9-639">**Inconvénients**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-639">**Cons**</span></span>

-   <span data-ttu-id="cb5e9-640">Implique des chaînes de requête textuelles qui sont plus sujettes aux erreurs des utilisateurs que les constructions de requête intégrées au langage.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-640">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>

### <a name="64-entity-sql-over-an-entity-command"></a><span data-ttu-id="cb5e9-641">6,4 Entity SQL sur une commande d’entité</span><span class="sxs-lookup"><span data-stu-id="cb5e9-641">6.4       Entity SQL over an Entity Command</span></span>

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

<span data-ttu-id="cb5e9-642">**Avantages**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-642">**Pros**</span></span>

-   <span data-ttu-id="cb5e9-643">Prend en charge la mise en cache du plan de requête dans .NET 4,0 (la mise en cache du plan est prise en charge par tous les autres types de requêtes dans .NET 4,5).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-643">Supports query plan caching in .NET 4.0 (plan caching is supported by all other query types in .NET 4.5).</span></span>

<span data-ttu-id="cb5e9-644">**Inconvénients**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-644">**Cons**</span></span>

-   <span data-ttu-id="cb5e9-645">Implique des chaînes de requête textuelles qui sont plus sujettes aux erreurs des utilisateurs que les constructions de requête intégrées au langage.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-645">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>
-   <span data-ttu-id="cb5e9-646">Non adapté aux opérations CUD.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-646">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="cb5e9-647">Les résultats ne sont pas matérialisés automatiquement et doivent être lus à partir du lecteur de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-647">Results are not automatically materialized, and must be read from the data reader.</span></span>

### <a name="65-sqlquery-and-executestorequery"></a><span data-ttu-id="cb5e9-648">6,5 SqlQuery et ExecuteStoreQuery</span><span class="sxs-lookup"><span data-stu-id="cb5e9-648">6.5       SqlQuery and ExecuteStoreQuery</span></span>

<span data-ttu-id="cb5e9-649">SqlQuery sur la base de données :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-649">SqlQuery on Database:</span></span>

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

<span data-ttu-id="cb5e9-650">SqlQuery sur DbSet :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-650">SqlQuery on DbSet:</span></span>

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

<span data-ttu-id="cb5e9-651">ExecyteStoreQuery:</span><span class="sxs-lookup"><span data-stu-id="cb5e9-651">ExecyteStoreQuery:</span></span>

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

<span data-ttu-id="cb5e9-652">**Avantages**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-652">**Pros**</span></span>

-   <span data-ttu-id="cb5e9-653">Performances généralement plus rapides dans la mesure où le compilateur de plan est contourné.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-653">Generally fastest performance since plan compiler is bypassed.</span></span>
-   <span data-ttu-id="cb5e9-654">Objets entièrement matérialisés.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-654">Fully materialized objects.</span></span>
-   <span data-ttu-id="cb5e9-655">Adapté aux opérations CUD en cas d’utilisation à partir du DbSet.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-655">Suitable for CUD operations when used from the DbSet.</span></span>

<span data-ttu-id="cb5e9-656">**Inconvénients**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-656">**Cons**</span></span>

-   <span data-ttu-id="cb5e9-657">La requête est textuelle et sujette aux erreurs.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-657">Query is textual and error prone.</span></span>
-   <span data-ttu-id="cb5e9-658">La requête est liée à un serveur principal spécifique à l’aide de la sémantique de magasin au lieu de la sémantique conceptuelle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-658">Query is tied to a specific backend by using store semantics instead of conceptual semantics.</span></span>
-   <span data-ttu-id="cb5e9-659">Lorsque l’héritage est présent, la requête handcrafted doit tenir compte des conditions de mappage pour le type demandé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-659">When inheritance is present, handcrafted query needs to account for mapping conditions for the type requested.</span></span>

### <a name="66-compiledquery"></a><span data-ttu-id="cb5e9-660">6,6 CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="cb5e9-660">6.6       CompiledQuery</span></span>

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

<span data-ttu-id="cb5e9-661">**Avantages**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-661">**Pros**</span></span>

-   <span data-ttu-id="cb5e9-662">Offre une amélioration des performances pouvant atteindre 7% par rapport aux requêtes LINQ ordinaires.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-662">Provides up to a 7% performance improvement over regular LINQ queries.</span></span>
-   <span data-ttu-id="cb5e9-663">Objets entièrement matérialisés.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-663">Fully materialized objects.</span></span>
-   <span data-ttu-id="cb5e9-664">Adapté aux opérations CUD.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-664">Suitable for CUD operations.</span></span>

<span data-ttu-id="cb5e9-665">**Inconvénients**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-665">**Cons**</span></span>

-   <span data-ttu-id="cb5e9-666">Complexité accrue et programmation plus lourde.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-666">Increased complexity and programming overhead.</span></span>
-   <span data-ttu-id="cb5e9-667">L’amélioration des performances est perdue lors de la composition d’une requête compilée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-667">The performance improvement is lost when composing on top of a compiled query.</span></span>
-   <span data-ttu-id="cb5e9-668">Certaines requêtes LINQ ne peuvent pas être écrites en tant que CompiledQuery, par exemple, des projections de types anonymes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-668">Some LINQ queries can't be written as a CompiledQuery - for example, projections of anonymous types.</span></span>

### <a name="67-performance-comparison-of-different-query-options"></a><span data-ttu-id="cb5e9-669">6,7 Comparaison des performances des différentes options de requête</span><span class="sxs-lookup"><span data-stu-id="cb5e9-669">6.7       Performance Comparison of different query options</span></span>

<span data-ttu-id="cb5e9-670">Les microtests simples où la création de contexte n’a pas été chronométrée ont été placés dans le test.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-670">Simple microbenchmarks where the context creation was not timed were put to the test.</span></span> <span data-ttu-id="cb5e9-671">Nous avons mesuré l’interrogation 5000 fois pour un ensemble d’entités non mises en cache dans un environnement contrôlé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-671">We measured querying 5000 times for a set of non-cached entities in a controlled environment.</span></span> <span data-ttu-id="cb5e9-672">Ces valeurs doivent être prises en compte : elles ne reflètent pas les chiffres réels produits par une application, mais elles constituent une mesure très précise de la différence de performances lorsque des options d’interrogation différentes sont comparées entre les pommes et les pommes, à l’exception du coût de création d’un nouveau contexte.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-672">These numbers are to be taken with a warning: they do not reflect actual numbers produced by an application, but instead they are a very accurate measurement of how much of a performance difference there is when different querying options are compared apples-to-apples, excluding the cost of creating a new context.</span></span>

| <span data-ttu-id="cb5e9-673">EF</span><span class="sxs-lookup"><span data-stu-id="cb5e9-673">EF</span></span>  | <span data-ttu-id="cb5e9-674">Test</span><span class="sxs-lookup"><span data-stu-id="cb5e9-674">Test</span></span>                                 | <span data-ttu-id="cb5e9-675">Temps (MS)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-675">Time (ms)</span></span> | <span data-ttu-id="cb5e9-676">Mémoire</span><span class="sxs-lookup"><span data-stu-id="cb5e9-676">Memory</span></span>   |
|:----|:-------------------------------------|:----------|:---------|
| <span data-ttu-id="cb5e9-677">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-677">EF5</span></span> | <span data-ttu-id="cb5e9-678">ESQL ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-678">ObjectContext ESQL</span></span>                   | <span data-ttu-id="cb5e9-679">2414</span><span class="sxs-lookup"><span data-stu-id="cb5e9-679">2414</span></span>      | <span data-ttu-id="cb5e9-680">38801408</span><span class="sxs-lookup"><span data-stu-id="cb5e9-680">38801408</span></span> |
| <span data-ttu-id="cb5e9-681">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-681">EF5</span></span> | <span data-ttu-id="cb5e9-682">Requête LINQ ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-682">ObjectContext Linq Query</span></span>             | <span data-ttu-id="cb5e9-683">2692</span><span class="sxs-lookup"><span data-stu-id="cb5e9-683">2692</span></span>      | <span data-ttu-id="cb5e9-684">38277120</span><span class="sxs-lookup"><span data-stu-id="cb5e9-684">38277120</span></span> |
| <span data-ttu-id="cb5e9-685">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-685">EF5</span></span> | <span data-ttu-id="cb5e9-686">Interrogation LINQ de DbContext non suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-686">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="cb5e9-687">2818</span><span class="sxs-lookup"><span data-stu-id="cb5e9-687">2818</span></span>      | <span data-ttu-id="cb5e9-688">41840640</span><span class="sxs-lookup"><span data-stu-id="cb5e9-688">41840640</span></span> |
| <span data-ttu-id="cb5e9-689">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-689">EF5</span></span> | <span data-ttu-id="cb5e9-690">Requête LINQ DbContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-690">DbContext Linq Query</span></span>                 | <span data-ttu-id="cb5e9-691">2930</span><span class="sxs-lookup"><span data-stu-id="cb5e9-691">2930</span></span>      | <span data-ttu-id="cb5e9-692">41771008</span><span class="sxs-lookup"><span data-stu-id="cb5e9-692">41771008</span></span> |
| <span data-ttu-id="cb5e9-693">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-693">EF5</span></span> | <span data-ttu-id="cb5e9-694">ObjectContext requête LINQ aucun suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-694">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="cb5e9-695">3013</span><span class="sxs-lookup"><span data-stu-id="cb5e9-695">3013</span></span>      | <span data-ttu-id="cb5e9-696">38412288</span><span class="sxs-lookup"><span data-stu-id="cb5e9-696">38412288</span></span> |
|     |                                      |           |          |
| <span data-ttu-id="cb5e9-697">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-697">EF6</span></span> | <span data-ttu-id="cb5e9-698">ESQL ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-698">ObjectContext ESQL</span></span>                   | <span data-ttu-id="cb5e9-699">2059</span><span class="sxs-lookup"><span data-stu-id="cb5e9-699">2059</span></span>      | <span data-ttu-id="cb5e9-700">46039040</span><span class="sxs-lookup"><span data-stu-id="cb5e9-700">46039040</span></span> |
| <span data-ttu-id="cb5e9-701">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-701">EF6</span></span> | <span data-ttu-id="cb5e9-702">Requête LINQ ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-702">ObjectContext Linq Query</span></span>             | <span data-ttu-id="cb5e9-703">3074</span><span class="sxs-lookup"><span data-stu-id="cb5e9-703">3074</span></span>      | <span data-ttu-id="cb5e9-704">45248512</span><span class="sxs-lookup"><span data-stu-id="cb5e9-704">45248512</span></span> |
| <span data-ttu-id="cb5e9-705">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-705">EF6</span></span> | <span data-ttu-id="cb5e9-706">Interrogation LINQ de DbContext non suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-706">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="cb5e9-707">3125</span><span class="sxs-lookup"><span data-stu-id="cb5e9-707">3125</span></span>      | <span data-ttu-id="cb5e9-708">47575040</span><span class="sxs-lookup"><span data-stu-id="cb5e9-708">47575040</span></span> |
| <span data-ttu-id="cb5e9-709">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-709">EF6</span></span> | <span data-ttu-id="cb5e9-710">Requête LINQ DbContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-710">DbContext Linq Query</span></span>                 | <span data-ttu-id="cb5e9-711">3420</span><span class="sxs-lookup"><span data-stu-id="cb5e9-711">3420</span></span>      | <span data-ttu-id="cb5e9-712">47652864</span><span class="sxs-lookup"><span data-stu-id="cb5e9-712">47652864</span></span> |
| <span data-ttu-id="cb5e9-713">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-713">EF6</span></span> | <span data-ttu-id="cb5e9-714">ObjectContext requête LINQ aucun suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-714">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="cb5e9-715">3593</span><span class="sxs-lookup"><span data-stu-id="cb5e9-715">3593</span></span>      | <span data-ttu-id="cb5e9-716">45260800</span><span class="sxs-lookup"><span data-stu-id="cb5e9-716">45260800</span></span> |

![EF5 micro tests, 5000 itérations à chaud](~/ef6/media/ef5micro5000warm.png)

![EF6 micro tests, 5000 itérations à chaud](~/ef6/media/ef6micro5000warm.png)

<span data-ttu-id="cb5e9-719">Les microtests sont très sensibles aux modifications mineures apportées au code.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-719">Microbenchmarks are very sensitive to small changes in the code.</span></span> <span data-ttu-id="cb5e9-720">Dans ce cas, la différence entre les coûts de Entity Framework 5 et Entity Framework 6 est due à l’ajout d’une [interception](xref:ef6/fundamentals/logging-and-interception) et à des [améliorations transactionnelles](xref:ef6/saving/transactions).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-720">In this case, the difference between the costs of Entity Framework 5 and Entity Framework 6 are due to the addition of [interception](xref:ef6/fundamentals/logging-and-interception) and [transactional improvements](xref:ef6/saving/transactions).</span></span> <span data-ttu-id="cb5e9-721">Toutefois, ces microtests sont une vision amplifiée d’un très petit fragment de ce que Entity Framework fait.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-721">These microbenchmarks numbers, however, are an amplified vision into a very small fragment of what Entity Framework does.</span></span> <span data-ttu-id="cb5e9-722">Les scénarios réels de requêtes à chaud ne doivent pas voir une régression des performances lors de la mise à niveau de Entity Framework 5 vers Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-722">Real-world scenarios of warm queries should not see a performance regression when upgrading from Entity Framework 5 to Entity Framework 6.</span></span>

<span data-ttu-id="cb5e9-723">Pour comparer les performances réelles des différentes options de requête, nous avons créé 5 variantes de test distinctes où nous utilisons une option de requête différente pour sélectionner tous les produits dont le nom de catégorie est « boissons ».</span><span class="sxs-lookup"><span data-stu-id="cb5e9-723">To compare the real-world performance of the different query options, we created 5 separate test variations where we use a different query option to select all products whose category name is "Beverages".</span></span> <span data-ttu-id="cb5e9-724">Chaque itération comprend le coût de la création du contexte et le coût de la matérialisation de toutes les entités retournées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-724">Each iteration includes the cost of creating the context, and the cost of materializing all returned entities.</span></span> <span data-ttu-id="cb5e9-725">10 itérations sont exécutées de façon ininterrompue avant d’effectuer la somme de 1000 itérations chronométrées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-725">10 iterations are run untimed before taking the sum of 1000 timed iterations.</span></span> <span data-ttu-id="cb5e9-726">Les résultats affichés sont l’exécution médiane effectuée à partir de 5 exécutions de chaque test.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-726">The results shown are the median run taken from 5 runs of each test.</span></span> <span data-ttu-id="cb5e9-727">Pour plus d’informations, consultez l’annexe B, qui comprend le code du test.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-727">For more information, see Appendix B which includes the code for the test.</span></span>

| <span data-ttu-id="cb5e9-728">EF</span><span class="sxs-lookup"><span data-stu-id="cb5e9-728">EF</span></span>  | <span data-ttu-id="cb5e9-729">Test</span><span class="sxs-lookup"><span data-stu-id="cb5e9-729">Test</span></span>                                        | <span data-ttu-id="cb5e9-730">Temps (MS)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-730">Time (ms)</span></span> | <span data-ttu-id="cb5e9-731">Mémoire</span><span class="sxs-lookup"><span data-stu-id="cb5e9-731">Memory</span></span>   |
|:----|:--------------------------------------------|:----------|:---------|
| <span data-ttu-id="cb5e9-732">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-732">EF5</span></span> | <span data-ttu-id="cb5e9-733">Commande d’entité ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-733">ObjectContext Entity Command</span></span>                | <span data-ttu-id="cb5e9-734">621</span><span class="sxs-lookup"><span data-stu-id="cb5e9-734">621</span></span>       | <span data-ttu-id="cb5e9-735">39350272</span><span class="sxs-lookup"><span data-stu-id="cb5e9-735">39350272</span></span> |
| <span data-ttu-id="cb5e9-736">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-736">EF5</span></span> | <span data-ttu-id="cb5e9-737">Requête SQL DbContext sur la base de données</span><span class="sxs-lookup"><span data-stu-id="cb5e9-737">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="cb5e9-738">825</span><span class="sxs-lookup"><span data-stu-id="cb5e9-738">825</span></span>       | <span data-ttu-id="cb5e9-739">37519360</span><span class="sxs-lookup"><span data-stu-id="cb5e9-739">37519360</span></span> |
| <span data-ttu-id="cb5e9-740">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-740">EF5</span></span> | <span data-ttu-id="cb5e9-741">Requête du magasin ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-741">ObjectContext Store Query</span></span>                   | <span data-ttu-id="cb5e9-742">878</span><span class="sxs-lookup"><span data-stu-id="cb5e9-742">878</span></span>       | <span data-ttu-id="cb5e9-743">39460864</span><span class="sxs-lookup"><span data-stu-id="cb5e9-743">39460864</span></span> |
| <span data-ttu-id="cb5e9-744">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-744">EF5</span></span> | <span data-ttu-id="cb5e9-745">ObjectContext requête LINQ aucun suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-745">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="cb5e9-746">969</span><span class="sxs-lookup"><span data-stu-id="cb5e9-746">969</span></span>       | <span data-ttu-id="cb5e9-747">38293504</span><span class="sxs-lookup"><span data-stu-id="cb5e9-747">38293504</span></span> |
| <span data-ttu-id="cb5e9-748">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-748">EF5</span></span> | <span data-ttu-id="cb5e9-749">ObjectContext Entity SQL à l’aide d’une requête d’objet</span><span class="sxs-lookup"><span data-stu-id="cb5e9-749">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="cb5e9-750">1089</span><span class="sxs-lookup"><span data-stu-id="cb5e9-750">1089</span></span>      | <span data-ttu-id="cb5e9-751">38981632</span><span class="sxs-lookup"><span data-stu-id="cb5e9-751">38981632</span></span> |
| <span data-ttu-id="cb5e9-752">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-752">EF5</span></span> | <span data-ttu-id="cb5e9-753">Requête compilée ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-753">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="cb5e9-754">1099</span><span class="sxs-lookup"><span data-stu-id="cb5e9-754">1099</span></span>      | <span data-ttu-id="cb5e9-755">38682624</span><span class="sxs-lookup"><span data-stu-id="cb5e9-755">38682624</span></span> |
| <span data-ttu-id="cb5e9-756">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-756">EF5</span></span> | <span data-ttu-id="cb5e9-757">Requête LINQ ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-757">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="cb5e9-758">1152</span><span class="sxs-lookup"><span data-stu-id="cb5e9-758">1152</span></span>      | <span data-ttu-id="cb5e9-759">38178816</span><span class="sxs-lookup"><span data-stu-id="cb5e9-759">38178816</span></span> |
| <span data-ttu-id="cb5e9-760">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-760">EF5</span></span> | <span data-ttu-id="cb5e9-761">Interrogation LINQ de DbContext non suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-761">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="cb5e9-762">1208</span><span class="sxs-lookup"><span data-stu-id="cb5e9-762">1208</span></span>      | <span data-ttu-id="cb5e9-763">41803776</span><span class="sxs-lookup"><span data-stu-id="cb5e9-763">41803776</span></span> |
| <span data-ttu-id="cb5e9-764">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-764">EF5</span></span> | <span data-ttu-id="cb5e9-765">Requête SQL DbContext sur DbSet</span><span class="sxs-lookup"><span data-stu-id="cb5e9-765">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="cb5e9-766">1414</span><span class="sxs-lookup"><span data-stu-id="cb5e9-766">1414</span></span>      | <span data-ttu-id="cb5e9-767">37982208</span><span class="sxs-lookup"><span data-stu-id="cb5e9-767">37982208</span></span> |
| <span data-ttu-id="cb5e9-768">EF5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-768">EF5</span></span> | <span data-ttu-id="cb5e9-769">Requête LINQ DbContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-769">DbContext Linq Query</span></span>                        | <span data-ttu-id="cb5e9-770">1574</span><span class="sxs-lookup"><span data-stu-id="cb5e9-770">1574</span></span>      | <span data-ttu-id="cb5e9-771">41738240</span><span class="sxs-lookup"><span data-stu-id="cb5e9-771">41738240</span></span> |
|     |                                             |           |          |
| <span data-ttu-id="cb5e9-772">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-772">EF6</span></span> | <span data-ttu-id="cb5e9-773">Commande d’entité ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-773">ObjectContext Entity Command</span></span>                | <span data-ttu-id="cb5e9-774">480</span><span class="sxs-lookup"><span data-stu-id="cb5e9-774">480</span></span>       | <span data-ttu-id="cb5e9-775">47247360</span><span class="sxs-lookup"><span data-stu-id="cb5e9-775">47247360</span></span> |
| <span data-ttu-id="cb5e9-776">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-776">EF6</span></span> | <span data-ttu-id="cb5e9-777">Requête du magasin ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-777">ObjectContext Store Query</span></span>                   | <span data-ttu-id="cb5e9-778">493</span><span class="sxs-lookup"><span data-stu-id="cb5e9-778">493</span></span>       | <span data-ttu-id="cb5e9-779">46739456</span><span class="sxs-lookup"><span data-stu-id="cb5e9-779">46739456</span></span> |
| <span data-ttu-id="cb5e9-780">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-780">EF6</span></span> | <span data-ttu-id="cb5e9-781">Requête SQL DbContext sur la base de données</span><span class="sxs-lookup"><span data-stu-id="cb5e9-781">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="cb5e9-782">614</span><span class="sxs-lookup"><span data-stu-id="cb5e9-782">614</span></span>       | <span data-ttu-id="cb5e9-783">41607168</span><span class="sxs-lookup"><span data-stu-id="cb5e9-783">41607168</span></span> |
| <span data-ttu-id="cb5e9-784">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-784">EF6</span></span> | <span data-ttu-id="cb5e9-785">ObjectContext requête LINQ aucun suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-785">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="cb5e9-786">684</span><span class="sxs-lookup"><span data-stu-id="cb5e9-786">684</span></span>       | <span data-ttu-id="cb5e9-787">46333952</span><span class="sxs-lookup"><span data-stu-id="cb5e9-787">46333952</span></span> |
| <span data-ttu-id="cb5e9-788">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-788">EF6</span></span> | <span data-ttu-id="cb5e9-789">ObjectContext Entity SQL à l’aide d’une requête d’objet</span><span class="sxs-lookup"><span data-stu-id="cb5e9-789">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="cb5e9-790">767</span><span class="sxs-lookup"><span data-stu-id="cb5e9-790">767</span></span>       | <span data-ttu-id="cb5e9-791">48865280</span><span class="sxs-lookup"><span data-stu-id="cb5e9-791">48865280</span></span> |
| <span data-ttu-id="cb5e9-792">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-792">EF6</span></span> | <span data-ttu-id="cb5e9-793">Requête compilée ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-793">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="cb5e9-794">788</span><span class="sxs-lookup"><span data-stu-id="cb5e9-794">788</span></span>       | <span data-ttu-id="cb5e9-795">48467968</span><span class="sxs-lookup"><span data-stu-id="cb5e9-795">48467968</span></span> |
| <span data-ttu-id="cb5e9-796">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-796">EF6</span></span> | <span data-ttu-id="cb5e9-797">Interrogation LINQ de DbContext non suivi</span><span class="sxs-lookup"><span data-stu-id="cb5e9-797">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="cb5e9-798">878</span><span class="sxs-lookup"><span data-stu-id="cb5e9-798">878</span></span>       | <span data-ttu-id="cb5e9-799">47554560</span><span class="sxs-lookup"><span data-stu-id="cb5e9-799">47554560</span></span> |
| <span data-ttu-id="cb5e9-800">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-800">EF6</span></span> | <span data-ttu-id="cb5e9-801">Requête LINQ ObjectContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-801">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="cb5e9-802">953</span><span class="sxs-lookup"><span data-stu-id="cb5e9-802">953</span></span>       | <span data-ttu-id="cb5e9-803">47632384</span><span class="sxs-lookup"><span data-stu-id="cb5e9-803">47632384</span></span> |
| <span data-ttu-id="cb5e9-804">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-804">EF6</span></span> | <span data-ttu-id="cb5e9-805">Requête SQL DbContext sur DbSet</span><span class="sxs-lookup"><span data-stu-id="cb5e9-805">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="cb5e9-806">1023</span><span class="sxs-lookup"><span data-stu-id="cb5e9-806">1023</span></span>      | <span data-ttu-id="cb5e9-807">41992192</span><span class="sxs-lookup"><span data-stu-id="cb5e9-807">41992192</span></span> |
| <span data-ttu-id="cb5e9-808">EF6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-808">EF6</span></span> | <span data-ttu-id="cb5e9-809">Requête LINQ DbContext</span><span class="sxs-lookup"><span data-stu-id="cb5e9-809">DbContext Linq Query</span></span>                        | <span data-ttu-id="cb5e9-810">1290</span><span class="sxs-lookup"><span data-stu-id="cb5e9-810">1290</span></span>      | <span data-ttu-id="cb5e9-811">47529984</span><span class="sxs-lookup"><span data-stu-id="cb5e9-811">47529984</span></span> |


![EF5 des itérations de requête à chaud 1000](~/ef6/media/ef5warmquery1000.png)

![EF6 des itérations de requête à chaud 1000](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> <span data-ttu-id="cb5e9-814">À des fins d’exhaustivité, nous avons inclus une variation où nous exécutons une requête Entity SQL sur un EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-814">For completeness, we included a variation where we execute an Entity SQL query on an EntityCommand.</span></span> <span data-ttu-id="cb5e9-815">Toutefois, étant donné que les résultats ne sont pas matérialisés pour ces requêtes, la comparaison n’est pas nécessairement de pommes à pommes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-815">However, because results are not materialized for such queries, the comparison isn't necessarily apples-to-apples.</span></span> <span data-ttu-id="cb5e9-816">Le test comprend une approximation de la matérialisation pour essayer de rendre la comparaison plus équitable.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-816">The test includes a close approximation to materializing to try making the comparison fairer.</span></span>

<span data-ttu-id="cb5e9-817">Dans ce cas de bout en bout, Entity Framework 6 est Entity Framework 5 en raison des améliorations de performances apportées sur plusieurs parties de la pile, y compris une initialisation beaucoup plus légère et des recherches MetadataCollection T plus rapides &lt; &gt; .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-817">In this end-to-end case, Entity Framework 6 outperforms Entity Framework 5 due to performance improvements made on several parts of the stack, including a much lighter DbContext initialization and faster MetadataCollection&lt;T&gt; lookups.</span></span>

## <a name="7-design-time-performance-considerations"></a><span data-ttu-id="cb5e9-818">7 Considérations relatives aux performances au moment de la conception</span><span class="sxs-lookup"><span data-stu-id="cb5e9-818">7 Design time performance considerations</span></span>

### <a name="71-inheritance-strategies"></a><span data-ttu-id="cb5e9-819">7,1 stratégies d’héritage</span><span class="sxs-lookup"><span data-stu-id="cb5e9-819">7.1       Inheritance Strategies</span></span>

<span data-ttu-id="cb5e9-820">Une autre considération en matière de performances lors de l’utilisation de Entity Framework est la stratégie d’héritage que vous utilisez.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-820">Another performance consideration when using Entity Framework is the inheritance strategy you use.</span></span> <span data-ttu-id="cb5e9-821">Entity Framework prend en charge 3 types de base d’héritage et leurs combinaisons :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-821">Entity Framework supports 3 basic types of inheritance and their combinations:</span></span>

-   <span data-ttu-id="cb5e9-822">Table par hiérarchie (TPH) : où chaque ensemble d’héritage est mappé à une table avec une colonne de discriminateur pour indiquer quel type particulier dans la hiérarchie est représenté dans la ligne.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-822">Table per Hierarchy (TPH) – where each inheritance set maps to a table with a discriminator column to indicate which particular type in the hierarchy is being represented in the row.</span></span>
-   <span data-ttu-id="cb5e9-823">Table par type (TPT) : où chaque type a sa propre table dans la base de données ; les tables enfants définissent uniquement les colonnes que la table parente ne contient pas.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-823">Table per Type (TPT) – where each type has its own table in the database; the child tables only define the columns that the parent table doesn’t contain.</span></span>
-   <span data-ttu-id="cb5e9-824">Table par classe (TPC) : chaque type possède sa propre table complète dans la base de données ; les tables enfants définissent tous leurs champs, y compris ceux définis dans les types parents.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-824">Table per Class (TPC) – where each type has its own full table in the database; the child tables define all their fields, including those defined in parent types.</span></span>

<span data-ttu-id="cb5e9-825">Si votre modèle utilise l’héritage TPT, les requêtes générées seront plus complexes que celles générées avec les autres stratégies d’héritage, ce qui peut entraîner des durées d’exécution plus longues sur le magasin.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-825">If your model uses TPT inheritance, the queries which are generated will be more complex than those that are generated with the other inheritance strategies, which may result on longer execution times on the store.</span></span><span data-ttu-id="cb5e9-826">Elle prend généralement plus de temps pour générer des requêtes sur un modèle TPT et pour matérialiser les objets résultants.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-826">  It will generally take longer to generate queries over a TPT model, and to materialize the resulting objects.</span></span>

<span data-ttu-id="cb5e9-827">Consultez «Considérations relatives aux performances lors de l’utilisation de TPT (table par type) dans Entity Framework le billet de blog MSDN : \<https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-827">See the "Performance Considerations when using TPT (Table per Type) Inheritance in the Entity Framework" MSDN blog post: \<https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework>.</span></span>

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a><span data-ttu-id="cb5e9-828">7.1.1 éviter les TPT dans les applications Model First ou Code First</span><span class="sxs-lookup"><span data-stu-id="cb5e9-828">7.1.1       Avoiding TPT in Model First or Code First applications</span></span>

<span data-ttu-id="cb5e9-829">Lorsque vous créez un modèle sur une base de données existante qui a un schéma TPT, vous ne disposez pas de nombreuses options.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-829">When you create a model over an existing database that has a TPT schema, you don't have many options.</span></span> <span data-ttu-id="cb5e9-830">Toutefois, lors de la création d’une application à l’aide de Model First ou Code First, vous devez éviter l’héritage TPT pour les problèmes de performances.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-830">But when creating an application using Model First or Code First, you should avoid TPT inheritance for performance concerns.</span></span>

<span data-ttu-id="cb5e9-831">Lorsque vous utilisez Model First dans l’Assistant Entity Designer, vous obtiendrez TPT pour tout héritage dans votre modèle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-831">When you use Model First in the Entity Designer Wizard, you will get TPT for any inheritance in your model.</span></span> <span data-ttu-id="cb5e9-832">Si vous souhaitez basculer vers une stratégie d’héritage TPH avec Model First, vous pouvez utiliser l’option « Entity Designer génération de la base de données Power Pack » disponible à partir de la Galerie Visual Studio ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/> ).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-832">If you want to switch to a TPH inheritance strategy with Model First, you can use the "Entity Designer Database Generation Power Pack" available from the Visual Studio Gallery ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span></span>

<span data-ttu-id="cb5e9-833">Lorsque vous utilisez Code First pour configurer le mappage d’un modèle avec héritage, EF utilise TPH par défaut. par conséquent, toutes les entités de la hiérarchie d’héritage sont mappées à la même table.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-833">When using Code First to configure the mapping of a model with inheritance, EF will use TPH by default, therefore all entities in the inheritance hierarchy will be mapped to the same table.</span></span> <span data-ttu-id="cb5e9-834">Pour plus d’informations, consultez la section « mappage avec l’API Fluent » de l’article « Code First dans Entity Framework 4.1 » dans le magazine MSDN ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx) ).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-834">See the "Mapping with the Fluent API" section of the "Code First in Entity Framework4.1" article in MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) for more details.</span></span>

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a><span data-ttu-id="cb5e9-835">7,2 mise à niveau à partir de EF4 pour améliorer l’heure de génération du modèle</span><span class="sxs-lookup"><span data-stu-id="cb5e9-835">7.2       Upgrading from EF4 to improve model generation time</span></span>

<span data-ttu-id="cb5e9-836">Une amélioration spécifique à l’SQL Server de l’algorithme qui génère la couche de magasin (SSDL) du modèle est disponible dans Entity Framework 5 et 6, et en tant que mise à jour de Entity Framework 4 Lorsque Visual Studio 2010 SP1 est installé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-836">A SQL Server-specific improvement to the algorithm that generates the store-layer (SSDL) of the model is available in Entity Framework 5 and 6, and as an update to Entity Framework 4 when Visual Studio 2010 SP1 is installed.</span></span> <span data-ttu-id="cb5e9-837">Les résultats des tests suivants illustrent l’amélioration lors de la génération d’un modèle très volumineux, dans ce cas le modèle Navision.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-837">The following test results demonstrate the improvement when generating a very big model, in this case the Navision model.</span></span> <span data-ttu-id="cb5e9-838">Pour plus d’informations à ce sujet, consultez l’annexe C.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-838">See Appendix C for more details about it.</span></span>

<span data-ttu-id="cb5e9-839">Le modèle contient les jeux d’entités 1005 et les ensembles d’associations 4227.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-839">The model contains 1005 entity sets and 4227 association sets.</span></span>

| <span data-ttu-id="cb5e9-840">Configuration</span><span class="sxs-lookup"><span data-stu-id="cb5e9-840">Configuration</span></span>                              | <span data-ttu-id="cb5e9-841">Répartition du temps consommé</span><span class="sxs-lookup"><span data-stu-id="cb5e9-841">Breakdown of time consumed</span></span>                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="cb5e9-842">Visual Studio 2010, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="cb5e9-842">Visual Studio 2010, Entity Framework 4</span></span>     | <span data-ttu-id="cb5e9-843">Génération SSDL : 2 h 27 min.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-843">SSDL Generation: 2 hr 27 min</span></span> <br/> <span data-ttu-id="cb5e9-844">Génération de mappage : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-844">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-845">Génération CSDL : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-845">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-846">Génération ObjectLayer : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-846">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-847">Génération de vues : 2 h 14 min.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-847">View Generation: 2 h 14 min</span></span> |
| <span data-ttu-id="cb5e9-848">Visual Studio 2010 SP1, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="cb5e9-848">Visual Studio 2010 SP1, Entity Framework 4</span></span> | <span data-ttu-id="cb5e9-849">Génération SSDL : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-849">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-850">Génération de mappage : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-850">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-851">Génération CSDL : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-851">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-852">Génération ObjectLayer : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-852">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-853">Génération de vues : 1 heure 53 min.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-853">View Generation: 1 hr 53 min</span></span>   |
| <span data-ttu-id="cb5e9-854">Visual Studio 2013, Entity Framework 5</span><span class="sxs-lookup"><span data-stu-id="cb5e9-854">Visual Studio 2013, Entity Framework 5</span></span>     | <span data-ttu-id="cb5e9-855">Génération SSDL : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-855">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-856">Génération de mappage : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-856">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-857">Génération CSDL : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-857">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-858">Génération ObjectLayer : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-858">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-859">Génération de vues : 65 minutes</span><span class="sxs-lookup"><span data-stu-id="cb5e9-859">View Generation: 65 minutes</span></span>    |
| <span data-ttu-id="cb5e9-860">Visual Studio 2013, Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-860">Visual Studio 2013, Entity Framework 6</span></span>     | <span data-ttu-id="cb5e9-861">Génération SSDL : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-861">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-862">Génération de mappage : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-862">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-863">Génération CSDL : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-863">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-864">Génération ObjectLayer : 1 seconde</span><span class="sxs-lookup"><span data-stu-id="cb5e9-864">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="cb5e9-865">Génération de vues : 28 secondes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-865">View Generation: 28 seconds.</span></span>   |


<span data-ttu-id="cb5e9-866">Il est à noter que lors de la génération du langage SSDL, la charge est presque entièrement dépensée sur le SQL Server, tandis que l’ordinateur de développement client attend que les résultats soient renvoyés par le serveur.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-866">It's worth noting that when generating the SSDL, the load is almost entirely spent on the SQL Server, while the client development machine is waiting idle for results to come back from the server.</span></span> <span data-ttu-id="cb5e9-867">Les administrateurs de bases de l’intérêt devraient particulièrement apprécier cette amélioration.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-867">DBAs should particularly appreciate this improvement.</span></span> <span data-ttu-id="cb5e9-868">Il est également intéressant de noter que l’ensemble du coût de génération de modèle a lieu dans la génération de vues.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-868">It's also worth noting that essentially the entire cost of model generation takes place in View Generation now.</span></span>

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a><span data-ttu-id="cb5e9-869">7,3 fractionnement des modèles volumineux avec Database First et Model First</span><span class="sxs-lookup"><span data-stu-id="cb5e9-869">7.3       Splitting Large Models with Database First and Model First</span></span>

<span data-ttu-id="cb5e9-870">À mesure que la taille du modèle augmente, l’aire du concepteur devient encombrée et difficile à utiliser.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-870">As model size increases, the designer surface becomes cluttered and difficult to use.</span></span> <span data-ttu-id="cb5e9-871">Nous considérons généralement un modèle avec plus de 300 entités comme trop volumineux pour utiliser efficacement le concepteur.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-871">We typically consider a model with more than 300 entities to be too large to effectively use the designer.</span></span> <span data-ttu-id="cb5e9-872">Le billet de blog suivant décrit plusieurs options de fractionnement des modèles volumineux : \<https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-872">The following blog post describes several options for splitting large models: \<https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2>.</span></span>

<span data-ttu-id="cb5e9-873">La publication a été écrite pour la première version de Entity Framework, mais les étapes s’appliquent toujours.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-873">The post was written for the first version of Entity Framework, but the steps still apply.</span></span>

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a><span data-ttu-id="cb5e9-874">7,4 Considérations sur les performances avec le contrôle de source de données d’entité</span><span class="sxs-lookup"><span data-stu-id="cb5e9-874">7.4       Performance considerations with the Entity Data Source Control</span></span>

<span data-ttu-id="cb5e9-875">Nous avons vu des cas dans des tests de performances et de contrainte multithread où les performances d’une application Web utilisant le contrôle EntityDataSource se détériorent considérablement.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-875">We've seen cases in multi-threaded performance and stress tests where the performance of a web application using the EntityDataSource Control deteriorates significantly.</span></span> <span data-ttu-id="cb5e9-876">La cause sous-jacente est que le EntityDataSource appelle MetadataWorkspace. LoadFromAssembly à plusieurs reprises sur les assemblys référencés par l’application Web pour découvrir les types à utiliser comme entités.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-876">The underlying cause is that the EntityDataSource repeatedly calls MetadataWorkspace.LoadFromAssembly on the assemblies referenced by the Web application to discover the types to be used as entities.</span></span>

<span data-ttu-id="cb5e9-877">La solution consiste à définir le ContextTypeName de EntityDataSource sur le nom de type de votre classe ObjectContext dérivée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-877">The solution is to set the ContextTypeName of the EntityDataSource to the type name of your derived ObjectContext class.</span></span> <span data-ttu-id="cb5e9-878">Cela désactive le mécanisme qui analyse tous les assemblys référencés pour les types d’entité.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-878">This turns off the mechanism that scans all referenced assemblies for entity types.</span></span>

<span data-ttu-id="cb5e9-879">La définition du champ ContextTypeName empêche également un problème fonctionnel où le EntityDataSource dans .NET 4,0 lève une ReflectionTypeLoadException lorsqu’il ne peut pas charger un type à partir d’un assembly par le biais de la réflexion.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-879">Setting the ContextTypeName field also prevents a functional problem where the EntityDataSource in .NET 4.0 throws a ReflectionTypeLoadException when it can't load a type from an assembly via reflection.</span></span> <span data-ttu-id="cb5e9-880">Ce problème a été résolu dans .NET 4,5.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-880">This issue has been fixed in .NET 4.5.</span></span>

### <a name="75-poco-entities-and-change-tracking-proxies"></a><span data-ttu-id="cb5e9-881">7,5 entités POCO et proxys de suivi des modifications</span><span class="sxs-lookup"><span data-stu-id="cb5e9-881">7.5       POCO entities and change tracking proxies</span></span>

<span data-ttu-id="cb5e9-882">Entity Framework vous permet d’utiliser des classes de données personnalisées avec votre modèle de données sans modifier les classes de données elles-mêmes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-882">Entity Framework enables you to use custom data classes together with your data model without making any modifications to the data classes themselves.</span></span> <span data-ttu-id="cb5e9-883">Cela signifie que vous pouvez utiliser des objets CLR « classiques » (ou POCO), tels que les objets de domaine existants, avec votre modèle de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-883">This means that you can use "plain-old" CLR objects (POCO), such as existing domain objects, with your data model.</span></span> <span data-ttu-id="cb5e9-884">Ces classes de données POCO (également appelées objets ignorant la persistance), qui sont mappées à des entités définies dans un modèle de données, prennent en charge la plupart des mêmes comportements de requête, d’insertion, de mise à jour et de suppression que les types d’entités générés par les outils de Entity Data Model.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-884">These POCO data classes (also known as persistence-ignorant objects), which are mapped to entities that are defined in a data model, support most of the same query, insert, update, and delete behaviors as entity types that are generated by the Entity Data Model tools.</span></span>

<span data-ttu-id="cb5e9-885">Entity Framework pouvez également créer des classes proxy dérivées de vos types POCO, qui sont utilisées lorsque vous souhaitez activer des fonctionnalités telles que le chargement différé et le suivi automatique des modifications sur les entités POCO.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-885">Entity Framework can also create proxy classes derived from your POCO types, which are used when you want to enable features such as lazy loading and automatic change tracking on POCO entities.</span></span> <span data-ttu-id="cb5e9-886">Vos classes POCO doivent répondre à certaines exigences pour permettre à Entity Framework d’utiliser des proxies, comme décrit ici : [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx) .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-886">Your POCO classes must meet certain requirements to allow Entity Framework to use proxies, as described here: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span></span>

<span data-ttu-id="cb5e9-887">Les proxys de suivi des chances notifient le gestionnaire d’état d’objet chaque fois que l’une des propriétés de vos entités a une valeur modifiée, de sorte que Entity Framework connaît tout le temps de l’état réel de vos entités.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-887">Chance tracking proxies will notify the object state manager each time any of the properties of your entities has its value changed, so Entity Framework knows the actual state of your entities all the time.</span></span> <span data-ttu-id="cb5e9-888">Pour ce faire, ajoutez des événements de notification au corps des méthodes setter de vos propriétés et faites en sorte que le gestionnaire d’état d’objet traite de tels événements.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-888">This is done by adding notification events to the body of the setter methods of your properties, and having the object state manager processing such events.</span></span> <span data-ttu-id="cb5e9-889">Notez que la création d’une entité de proxy est généralement plus coûteuse que la création d’une entité POCO non-proxy en raison de l’ensemble d’événements supplémentaires créé par Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-889">Note that creating a proxy entity will typically be more expensive than creating a non-proxy POCO entity due to the added set of events created by Entity Framework.</span></span>

<span data-ttu-id="cb5e9-890">Lorsqu’une entité POCO n’a pas de proxy de suivi des modifications, des modifications sont détectées en comparant le contenu de vos entités à une copie d’un état enregistré précédent.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-890">When a POCO entity does not have a change tracking proxy, changes are found by comparing the contents of your entities against a copy of a previous saved state.</span></span> <span data-ttu-id="cb5e9-891">Cette comparaison profonde devient un processus long lorsque vous avez de nombreuses entités dans votre contexte, ou lorsque vos entités ont une très grande quantité de propriétés, même si aucune d’elles n’a changé depuis la dernière comparaison.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-891">This deep comparison will become a lengthy process when you have many entities in your context, or when your entities have a very large amount of properties, even if none of them changed since the last comparison took place.</span></span>

<span data-ttu-id="cb5e9-892">En Résumé : vous payez une baisse des performances lors de la création du proxy de suivi des modifications, mais le suivi des modifications vous permet d’accélérer le processus de détection des modifications lorsque vos entités ont de nombreuses propriétés ou lorsque vous avez de nombreuses entités dans votre modèle.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-892">In summary: you’ll pay a performance hit when creating the change tracking proxy, but change tracking will help you speed up the change detection process when your entities have many properties or when you have many entities in your model.</span></span> <span data-ttu-id="cb5e9-893">Pour les entités avec un petit nombre de propriétés où la quantité d’entités n’augmente pas trop, l’utilisation de proxys de suivi des modifications n’est pas très avantageuse.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-893">For entities with a small number of properties where the amount of entities doesn’t grow too much, having change tracking proxies may not be of much benefit.</span></span>

## <a name="8-loading-related-entities"></a><span data-ttu-id="cb5e9-894">8 chargement des entités associées</span><span class="sxs-lookup"><span data-stu-id="cb5e9-894">8 Loading Related Entities</span></span>

### <a name="81-lazy-loading-vs-eager-loading"></a><span data-ttu-id="cb5e9-895">8,1 chargement différé et chargement hâtif</span><span class="sxs-lookup"><span data-stu-id="cb5e9-895">8.1 Lazy Loading vs. Eager Loading</span></span>

<span data-ttu-id="cb5e9-896">Entity Framework offre différentes manières de charger les entités associées à votre entité cible.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-896">Entity Framework offers several different ways to load the entities that are related to your target entity.</span></span> <span data-ttu-id="cb5e9-897">Par exemple, lorsque vous recherchez des produits, les commandes associées sont chargées dans le gestionnaire d’état d’objet de différentes façons.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-897">For example, when you query for Products, there are different ways that the related Orders will be loaded into the Object State Manager.</span></span> <span data-ttu-id="cb5e9-898">Du point de vue des performances, la plus grande question à prendre en compte lors du chargement des entités associées est l’utilisation du chargement différé ou du chargement hâtif.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-898">From a performance standpoint, the biggest question to consider when loading related entities will be whether to use Lazy Loading or Eager Loading.</span></span>

<span data-ttu-id="cb5e9-899">Lorsque vous utilisez le chargement hâtif, les entités associées sont chargées en même temps que votre jeu d’entités cible.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-899">When using Eager Loading, the related entities are loaded along with your target entity set.</span></span> <span data-ttu-id="cb5e9-900">Vous utilisez une instruction include dans votre requête pour indiquer les entités associées que vous souhaitez importer.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-900">You use an Include statement in your query to indicate which related entities you want to bring in.</span></span>

<span data-ttu-id="cb5e9-901">Lorsque vous utilisez le chargement différé, votre requête initiale ne s’insère que dans le jeu d’entités cible.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-901">When using Lazy Loading, your initial query only brings in the target entity set.</span></span> <span data-ttu-id="cb5e9-902">Toutefois, chaque fois que vous accédez à une propriété de navigation, une autre requête est émise sur le magasin pour charger l’entité associée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-902">But whenever you access a navigation property, another query is issued against the store to load the related entity.</span></span>

<span data-ttu-id="cb5e9-903">Une fois qu’une entité a été chargée, toutes les autres requêtes de l’entité la chargent directement à partir du gestionnaire d’état d’objet, que vous utilisiez le chargement différé ou le chargement hâtif.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-903">Once an entity has been loaded, any further queries for the entity will load it directly from the Object State Manager, whether you are using lazy loading or eager loading.</span></span>

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a><span data-ttu-id="cb5e9-904">8,2 Comment choisir entre le chargement différé et le chargement hâtif</span><span class="sxs-lookup"><span data-stu-id="cb5e9-904">8.2 How to choose between Lazy Loading and Eager Loading</span></span>

<span data-ttu-id="cb5e9-905">L’important est que vous compreniez la différence entre le chargement différé et le chargement hâtif afin que vous puissiez faire le bon choix pour votre application.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-905">The important thing is that you understand the difference between Lazy Loading and Eager Loading so that you can make the correct choice for your application.</span></span> <span data-ttu-id="cb5e9-906">Cela vous aidera à évaluer le compromis entre plusieurs demandes sur la base de données par rapport à une requête unique qui peut contenir une charge utile importante.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-906">This will help you evaluate the tradeoff between multiple requests against the database versus a single request that may contain a large payload.</span></span> <span data-ttu-id="cb5e9-907">Il peut être utile d’utiliser le chargement hâtif dans certaines parties de votre application et le chargement différé dans d’autres parties.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-907">It may be appropriate to use eager loading in some parts of your application and lazy loading in other parts.</span></span>

<span data-ttu-id="cb5e9-908">À titre d’exemple, supposons que vous souhaitiez interroger les clients qui vivent au Royaume-Uni et le nombre de commandes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-908">As an example of what's happening under the hood, suppose you want to query for the customers who live in the UK and their order count.</span></span>

<span data-ttu-id="cb5e9-909">**Utilisation du chargement hâtif**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-909">**Using Eager Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="cb5e9-910">**Utilisation du chargement différé**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-910">**Using Lazy Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="cb5e9-911">Lorsque vous utilisez le chargement hâtif, vous émettez une seule requête qui retourne tous les clients et toutes les commandes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-911">When using eager loading, you'll issue a single query that returns all customers and all orders.</span></span> <span data-ttu-id="cb5e9-912">La commande du Windows Store ressemble à ceci :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-912">The store command looks like:</span></span>

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

<span data-ttu-id="cb5e9-913">Lorsque vous utilisez le chargement différé, vous émettez initialement la requête suivante :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-913">When using lazy loading, you'll issue the following query initially:</span></span>

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

<span data-ttu-id="cb5e9-914">Et chaque fois que vous accédez à la propriété de navigation Orders d’un client, une autre requête semblable à la suivante est émise sur le magasin :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-914">And each time you access the Orders navigation property of a customer another query like the following is issued against the store:</span></span>

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

<span data-ttu-id="cb5e9-915">Pour plus d’informations, consultez [chargement d’objets connexes](https://msdn.microsoft.com/library/bb896272.aspx).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-915">For more information, see the [Loading Related Objects](https://msdn.microsoft.com/library/bb896272.aspx).</span></span>

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a><span data-ttu-id="cb5e9-916">8.2.1 chargement différé et aide-mémoire de chargement hâtif</span><span class="sxs-lookup"><span data-stu-id="cb5e9-916">8.2.1 Lazy Loading versus Eager Loading cheat sheet</span></span>

<span data-ttu-id="cb5e9-917">Il n’existe aucun moyen de choisir un chargement hâtif et un chargement paresseux, à la fois.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-917">There’s no such thing as a one-size-fits-all to choosing eager loading versus lazy loading.</span></span> <span data-ttu-id="cb5e9-918">Essayez tout d’abord de comprendre les différences entre les deux stratégies pour pouvoir prendre une décision bien éclairée. Envisagez également si votre code s’adapte à l’un des scénarios suivants :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-918">Try first to understand the differences between both strategies so you can do a well informed decision; also, consider if your code fits to any of the following scenarios:</span></span>

| <span data-ttu-id="cb5e9-919">Scénario</span><span class="sxs-lookup"><span data-stu-id="cb5e9-919">Scenario</span></span>                                                                    | <span data-ttu-id="cb5e9-920">Notre suggestion</span><span class="sxs-lookup"><span data-stu-id="cb5e9-920">Our Suggestion</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="cb5e9-921">Avez-vous besoin d’accéder à de nombreuses propriétés de navigation à partir des entités extraites ?</span><span class="sxs-lookup"><span data-stu-id="cb5e9-921">Do you need to access many navigation properties from the fetched entities?</span></span> | <span data-ttu-id="cb5e9-922">**Non** -les deux options vont probablement.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-922">**No** - Both options will probably do.</span></span> <span data-ttu-id="cb5e9-923">Toutefois, si la charge de travail que votre requête est en cours d’exécution n’est pas trop importante, vous risquez d’obtenir des avantages en matière de performances en utilisant le chargement hâtif, car cela nécessite moins de boucles réseau pour matérialiser vos objets.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-923">However, if the payload your query is bringing is not too big, you may experience performance benefits by using Eager loading as it’ll require less network round trips to materialize your objects.</span></span> <br/> <br/> <span data-ttu-id="cb5e9-924">**Oui** : Si vous devez accéder à de nombreuses propriétés de navigation à partir des entités, vous pouvez le faire à l’aide de plusieurs instructions Include dans votre requête avec un chargement hâtif.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-924">**Yes** -  If you need to access many navigation properties from the entities, you’d do that by using multiple include statements in your query with Eager loading.</span></span> <span data-ttu-id="cb5e9-925">Plus vous incluez d’entités, plus la charge utile que votre requête renverra est importante.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-925">The more entities you include, the bigger the payload your query will return.</span></span> <span data-ttu-id="cb5e9-926">Une fois que vous avez inclus trois entités ou plus dans votre requête, envisagez de basculer vers le chargement différé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-926">Once you include three or more entities into your query, consider switching to Lazy loading.</span></span> |
| <span data-ttu-id="cb5e9-927">Savez-vous exactement quelles données seront nécessaires au moment de l’exécution ?</span><span class="sxs-lookup"><span data-stu-id="cb5e9-927">Do you know exactly what data will be needed at run time?</span></span>                   | <span data-ttu-id="cb5e9-928">**Le chargement** en différé est mieux adapté à vos besoins.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-928">**No** - Lazy loading will be better for you.</span></span> <span data-ttu-id="cb5e9-929">Dans le cas contraire, vous risquez de vous retrouver dans l’interrogation des données dont vous n’aurez pas besoin.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-929">Otherwise, you may end up querying for data that you will not need.</span></span> <br/> <br/> <span data-ttu-id="cb5e9-930">**Oui** -le chargement hâtif est probablement la meilleure solution. Cela permet de charger plus rapidement les jeux complets.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-930">**Yes** - Eager loading is probably your best bet; it will help loading entire sets faster.</span></span> <span data-ttu-id="cb5e9-931">Si votre requête nécessite la récupération d’une très grande quantité de données et que cette opération devient trop lente, essayez plutôt le chargement différé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-931">If your query requires fetching a very large amount of data, and this becomes too slow, then try Lazy loading instead.</span></span>                                                                                                                                                                                                                                                       |
| <span data-ttu-id="cb5e9-932">Votre code s’exécute-t-il loin de votre base de données ?</span><span class="sxs-lookup"><span data-stu-id="cb5e9-932">Is your code executing far from your database?</span></span> <span data-ttu-id="cb5e9-933">(latence accrue du réseau)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-933">(increased network latency)</span></span>  | <span data-ttu-id="cb5e9-934">**Non** -lorsque la latence du réseau n’est pas un problème, l’utilisation du chargement différé peut simplifier votre code.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-934">**No** - When the network latency is not an issue, using Lazy loading may simplify your code.</span></span> <span data-ttu-id="cb5e9-935">N’oubliez pas que la topologie de votre application peut changer. par conséquent, n’accordez pas de proximité à la base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-935">Remember that the topology of your application may change, so don’t take database proximity for granted.</span></span> <br/> <br/> <span data-ttu-id="cb5e9-936">**Oui** -lorsque le réseau est un problème, vous seul pouvez décider de ce qui convient le mieux à votre scénario.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-936">**Yes** - When the network is a problem, only you can decide what fits better for your scenario.</span></span> <span data-ttu-id="cb5e9-937">En général, le chargement hâtif est meilleur car il nécessite moins de boucles.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-937">Typically Eager loading will be better because it requires fewer round trips.</span></span>                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a><span data-ttu-id="cb5e9-938">8.2.2 problèmes de performances avec plusieurs includes</span><span class="sxs-lookup"><span data-stu-id="cb5e9-938">8.2.2       Performance concerns with multiple Includes</span></span>

<span data-ttu-id="cb5e9-939">Lorsque nous entendons des questions sur les performances qui impliquent des problèmes de temps de réponse du serveur, la source du problème est souvent une requête avec plusieurs instructions include.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-939">When we hear performance questions that involve server response time problems, the source of the issue is frequently queries with multiple Include statements.</span></span> <span data-ttu-id="cb5e9-940">Bien que l’inclusion d’entités associées dans une requête soit puissante, il est important de comprendre ce qui se passe en coulisses.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-940">While including related entities in a query is powerful, it's important to understand what's happening under the covers.</span></span>

<span data-ttu-id="cb5e9-941">L’exécution d’une requête contenant plusieurs instructions Include dans le compilateur de plan interne pour générer la commande de stockage prend un temps relativement long.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-941">It takes a relatively long time for a query with multiple Include statements in it to go through our internal plan compiler to produce the store command.</span></span> <span data-ttu-id="cb5e9-942">La majeure partie de ce temps est consacrée à la tentative d’optimisation de la requête résultante.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-942">The majority of this time is spent trying to optimize the resulting query.</span></span> <span data-ttu-id="cb5e9-943">La commande Store générée contient une jointure ou une Union externe pour chaque include, en fonction de votre mappage.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-943">The generated store command will contain an Outer Join or Union for each Include, depending on your mapping.</span></span> <span data-ttu-id="cb5e9-944">Les requêtes de ce type importent des graphiques connectés volumineux à partir de votre base de données dans une seule charge utile, ce qui acerbate tous les problèmes de bande passante, en particulier lorsqu’il y a beaucoup de redondance dans la charge utile (par exemple, lorsque plusieurs niveaux de include sont utilisés pour parcourir les associations dans la direction un-à-plusieurs).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-944">Queries like this will bring in large connected graphs from your database in a single payload, which will acerbate any bandwidth issues, especially when there is a lot of redundancy in the payload (for example, when multiple levels of Include are used to traverse associations in the one-to-many direction).</span></span>

<span data-ttu-id="cb5e9-945">Vous pouvez vérifier les cas où vos requêtes renvoient des charges utiles excessivement volumineuses en accédant à la valeur TSQL sous-jacente pour la requête à l’aide de ToTraceString et en exécutant la commande Store dans SQL Server Management Studio pour afficher la taille de la charge utile.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-945">You can check for cases where your queries are returning excessively large payloads by accessing the underlying TSQL for the query by using ToTraceString and executing the store command in SQL Server Management Studio to see the payload size.</span></span> <span data-ttu-id="cb5e9-946">Dans ce cas, vous pouvez essayer de réduire le nombre d’instructions Include dans votre requête pour importer simplement les données dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-946">In such cases you can try to reduce the number of Include statements in your query to just bring in the data you need.</span></span> <span data-ttu-id="cb5e9-947">Vous pouvez également décomposer votre requête en une plus petite séquence de sous-requêtes, par exemple :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-947">Or you may be able to break your query into a smaller sequence of subqueries, for example:</span></span>

<span data-ttu-id="cb5e9-948">**Avant de rompre la requête :**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-948">**Before breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="cb5e9-949">**Après avoir endommagé la requête :**</span><span class="sxs-lookup"><span data-stu-id="cb5e9-949">**After breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="cb5e9-950">Cela ne fonctionne que sur les requêtes suivies, car nous utilisons la capacité du contexte à effectuer automatiquement la résolution d’identité et la correction d’association.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-950">This will work only on tracked queries, as we are making use of the ability the context has to perform identity resolution and association fixup automatically.</span></span>

<span data-ttu-id="cb5e9-951">Comme avec le chargement différé, le compromis sera plus de requêtes pour les charges utiles plus petites.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-951">As with lazy loading, the tradeoff will be more queries for smaller payloads.</span></span> <span data-ttu-id="cb5e9-952">Vous pouvez également utiliser des projections de propriétés individuelles pour sélectionner explicitement uniquement les données dont vous avez besoin à partir de chaque entité, mais vous ne devez pas charger d’entités dans ce cas, et les mises à jour ne seront pas prises en charge.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-952">You can also use projections of individual properties to explicitly select only the data you need from each entity, but you will not be loading entities in this case, and updates will not be supported.</span></span>

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a><span data-ttu-id="cb5e9-953">solution de contournement 8.2.3 pour bénéficier du chargement différé des propriétés</span><span class="sxs-lookup"><span data-stu-id="cb5e9-953">8.2.3 Workaround to get lazy loading of properties</span></span>

<span data-ttu-id="cb5e9-954">Entity Framework ne prend actuellement pas en charge le chargement différé de propriétés scalaires ou complexes.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-954">Entity Framework currently doesn’t support lazy loading of scalar or complex properties.</span></span> <span data-ttu-id="cb5e9-955">Toutefois, dans les cas où vous avez une table qui comprend un objet volumineux, tel qu’un objet BLOB, vous pouvez utiliser le fractionnement de table pour séparer les grandes propriétés dans une entité distincte.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-955">However, in cases where you have a table that includes a large object such as a BLOB, you can use table splitting to separate the large properties into a separate entity.</span></span> <span data-ttu-id="cb5e9-956">Supposons, par exemple, que vous disposiez d’une table Product qui comprend une colonne de photos varbinary.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-956">For example, suppose you have a Product table that includes a varbinary photo column.</span></span> <span data-ttu-id="cb5e9-957">Si vous n’avez pas besoin d’accéder fréquemment à cette propriété dans vos requêtes, vous pouvez utiliser le fractionnement de table pour importer uniquement les parties de l’entité dont vous avez normalement besoin.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-957">If you don't frequently need to access this property in your queries, you can use table splitting to bring in only the parts of the entity that you normally need.</span></span> <span data-ttu-id="cb5e9-958">L’entité représentant la photo de produit est chargée uniquement lorsque vous en avez besoin de manière explicite.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-958">The entity representing the product photo will only be loaded when you explicitly need it.</span></span>

<span data-ttu-id="cb5e9-959">Une bonne ressource qui montre comment activer le fractionnement de table est le billet de blog de Gil Fink "fractionnement de table dans Entity Framework" : \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-959">A good resource that shows how to enable table splitting is Gil Fink's "Table Splitting in Entity Framework" blog post: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span></span>

## <a name="9-other-considerations"></a><span data-ttu-id="cb5e9-960">9 autres considérations</span><span class="sxs-lookup"><span data-stu-id="cb5e9-960">9 Other considerations</span></span>

### <a name="91-server-garbage-collection"></a><span data-ttu-id="cb5e9-961">Garbage collection de serveur 9,1</span><span class="sxs-lookup"><span data-stu-id="cb5e9-961">9.1      Server Garbage Collection</span></span>

<span data-ttu-id="cb5e9-962">Certains utilisateurs peuvent rencontrer des conflits de ressources qui limitent le parallélisme qu’ils attendent quand le garbage collector n’est pas correctement configuré.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-962">Some users might experience resource contention that limits the parallelism they are expecting when the Garbage Collector is not properly configured.</span></span> <span data-ttu-id="cb5e9-963">Chaque fois que EF est utilisé dans un scénario multithread ou dans une application qui ressemble à un système côté serveur, veillez à activer le garbage collection de serveur.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-963">Whenever EF is used in a multithreaded scenario, or in any application that resembles a server-side system, make sure to enable Server Garbage Collection.</span></span> <span data-ttu-id="cb5e9-964">Pour cela, vous avez besoin d’un paramètre simple dans votre fichier de configuration d’application :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-964">This is done via a simple setting in your application config file:</span></span>

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

<span data-ttu-id="cb5e9-965">Cela devrait réduire la contention de vos threads et augmenter votre débit de 30% dans les scénarios de saturation de l’UC.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-965">This should decrease your thread contention and increase your throughput by up to 30% in CPU saturated scenarios.</span></span> <span data-ttu-id="cb5e9-966">En général, vous devez toujours tester le comportement de votre application à l’aide du garbage collection classique (qui est mieux adapté aux scénarios d’interface utilisateur et côté client), ainsi qu’au garbage collection de serveur.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-966">In general terms, you should always test how your application behaves using the classic Garbage Collection (which is better tuned for UI and client side scenarios) as well as the Server Garbage Collection.</span></span>

### <a name="92-autodetectchanges"></a><span data-ttu-id="cb5e9-967">9,2 AutoDetectChanges</span><span class="sxs-lookup"><span data-stu-id="cb5e9-967">9.2      AutoDetectChanges</span></span>

<span data-ttu-id="cb5e9-968">Comme mentionné précédemment, Entity Framework peut présenter des problèmes de performances lorsque le cache d’objets a de nombreuses entités.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-968">As mentioned earlier, Entity Framework might show performance issues when the object cache has many entities.</span></span> <span data-ttu-id="cb5e9-969">Certaines opérations, telles que Add, Remove, Find, Entry et SaveChanges, déclenchent des appels à DetectChanges qui peuvent consommer une grande quantité d’UC en fonction de la taille du cache d’objets.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-969">Certain operations, such as Add, Remove, Find, Entry and SaveChanges, trigger calls to DetectChanges which might consume a large amount of CPU based on how large the object cache has become.</span></span> <span data-ttu-id="cb5e9-970">Cela est dû au fait que le cache d’objets et le gestionnaire d’état d’objet essaient de rester synchronisés autant que possible sur chaque opération effectuée dans un contexte afin que les données produites soient correctes dans un vaste éventail de scénarios.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-970">The reason for this is that the object cache and the object state manager try to stay as synchronized as possible on each operation performed to a context so that the produced data is guaranteed to be correct under a wide array of scenarios.</span></span>

<span data-ttu-id="cb5e9-971">Il est généralement recommandé de conserver la détection automatique des modifications de Entity Framework activée pendant toute la durée de vie de votre application.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-971">It is generally a good practice to leave Entity Framework’s automatic change detection enabled for the entire life of your application.</span></span> <span data-ttu-id="cb5e9-972">Si votre scénario est affecté négativement par une utilisation intensive du processeur et que vos profils indiquent que le coupable est l’appel à DetectChanges, envisagez de désactiver temporairement AutoDetectChanges dans la partie sensible de votre code :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-972">If your scenario is being negatively affected by high CPU usage and your profiles indicate that the culprit is the call to DetectChanges, consider temporarily turning off AutoDetectChanges in the sensitive portion of your code:</span></span>

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

<span data-ttu-id="cb5e9-973">Avant de désactiver AutoDetectChanges, il est judicieux de comprendre qu’il est possible que Entity Framework perde sa capacité à effectuer le suivi de certaines informations sur les modifications qui ont lieu sur les entités.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-973">Before turning off AutoDetectChanges, it’s good to understand that this might cause Entity Framework to lose its ability to track certain information about the changes that are taking place on the entities.</span></span> <span data-ttu-id="cb5e9-974">En cas de gestion incorrecte, cela peut entraîner une incohérence des données sur votre application.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-974">If handled incorrectly, this might cause data inconsistency on your application.</span></span> <span data-ttu-id="cb5e9-975">Pour plus d’informations sur la désactivation de AutoDetectChanges, consultez \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-975">For more information on turning off AutoDetectChanges, read \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span></span>

### <a name="93-context-per-request"></a><span data-ttu-id="cb5e9-976">9,3 contexte par requête</span><span class="sxs-lookup"><span data-stu-id="cb5e9-976">9.3      Context per request</span></span>

<span data-ttu-id="cb5e9-977">Les contextes de Entity Framework sont destinés à être utilisés en tant qu’instances courtes afin de fournir une expérience de performances optimale.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-977">Entity Framework’s contexts are meant to be used as short-lived instances in order to provide the most optimal performance experience.</span></span> <span data-ttu-id="cb5e9-978">Les contextes sont supposés être à courte durée de vie et sont ignorés, et en tant que tels ont été implémentés pour être très légers et réutiliser les métadonnées chaque fois que cela est possible.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-978">Contexts are expected to be short lived and discarded, and as such have been implemented to be very lightweight and reutilize metadata whenever possible.</span></span> <span data-ttu-id="cb5e9-979">Dans les scénarios Web, il est important de garder cela à l’esprit et de ne pas avoir de contexte plus que la durée d’une requête unique.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-979">In web scenarios it’s important to keep this in mind and not have a context for more than the duration of a single request.</span></span> <span data-ttu-id="cb5e9-980">De même, dans les scénarios non Web, le contexte doit être ignoré en fonction de votre compréhension des différents niveaux de mise en cache dans le Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-980">Similarly, in non-web scenarios, context should be discarded based on your understanding of the different levels of caching in the Entity Framework.</span></span> <span data-ttu-id="cb5e9-981">En règle générale, il est préférable d’éviter d’avoir une instance de contexte tout au long de la vie de l’application, ainsi que des contextes par thread et des contextes statiques.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-981">Generally speaking, one should avoid having a context instance throughout the life of the application, as well as contexts per thread and static contexts.</span></span>

### <a name="94-database-null-semantics"></a><span data-ttu-id="cb5e9-982">sémantique null de la base de données 9,4</span><span class="sxs-lookup"><span data-stu-id="cb5e9-982">9.4      Database null semantics</span></span>

<span data-ttu-id="cb5e9-983">Entity Framework par défaut génère du code SQL avec une \# sémantique de comparaison C null.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-983">Entity Framework by default will generate SQL code that has C\# null comparison semantics.</span></span> <span data-ttu-id="cb5e9-984">Prenons l'exemple de requête suivant :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-984">Consider the following example query:</span></span>

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

<span data-ttu-id="cb5e9-985">Dans cet exemple, nous comparons un certain nombre de variables Nullable à des propriétés Nullable sur l’entité, telles que RéfFournisseur et UnitPrice.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-985">In this example, we’re comparing a number of nullable variables against nullable properties on the entity, such as SupplierID and UnitPrice.</span></span> <span data-ttu-id="cb5e9-986">Le SQL généré pour cette requête demande si la valeur du paramètre est la même que la valeur de la colonne, ou si les valeurs du paramètre et de la colonne sont null.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-986">The generated SQL for this query will ask if the parameter value is the same as the column value, or if both the parameter and the column values are null.</span></span> <span data-ttu-id="cb5e9-987">Cela permet de masquer la manière dont le serveur de base de données gère les valeurs NULL et fournit une expérience de type C null cohérente \# entre les différents fournisseurs de bases de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-987">This will hide the way the database server handles nulls and will provide a consistent C\# null experience across different database vendors.</span></span> <span data-ttu-id="cb5e9-988">En revanche, le code généré est un peu compliqué et peut ne pas s’exécuter correctement lorsque le nombre de comparaisons dans l’instruction WHERE de la requête augmente jusqu’à un grand nombre.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-988">On the other hand, the generated code is a bit convoluted and may not perform well when the amount of comparisons in the where statement of the query grows to a large number.</span></span>

<span data-ttu-id="cb5e9-989">Une façon de traiter cette situation consiste à utiliser la sémantique null de la base de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-989">One way to deal with this situation is by using database null semantics.</span></span> <span data-ttu-id="cb5e9-990">Notez que cela peut potentiellement se comporter différemment de la sémantique C null, dans la \# mesure où Entity Framework générera un SQL plus simple qui expose la manière dont le moteur de base de données gère les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-990">Note that this might potentially behave differently to the C\# null semantics since now Entity Framework will generate simpler SQL that exposes the way the database engine handles null values.</span></span> <span data-ttu-id="cb5e9-991">La sémantique null de la base de données peut être activée par contexte avec une seule ligne de configuration par rapport à la configuration du contexte :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-991">Database null semantics can be activated per-context with one single configuration line against the context configuration:</span></span>

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

<span data-ttu-id="cb5e9-992">Les requêtes de taille petite à moyenne n’affichent pas une amélioration notable des performances lors de l’utilisation de la sémantique null de la base de données, mais la différence est plus perceptible sur les requêtes avec un grand nombre de comparaisons de valeurs NULL potentielles.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-992">Small to medium sized queries will not display a perceptible performance improvement when using database null semantics, but the difference will become more noticeable on queries with a large number of potential null comparisons.</span></span>

<span data-ttu-id="cb5e9-993">Dans l’exemple de requête ci-dessus, la différence de performances était inférieure à 2% dans un microtest exécuté dans un environnement contrôlé.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-993">In the example query above, the performance difference was less than 2% in a microbenchmark running in a controlled environment.</span></span>

### <a name="95-async"></a><span data-ttu-id="cb5e9-994">9,5 Async</span><span class="sxs-lookup"><span data-stu-id="cb5e9-994">9.5      Async</span></span>

<span data-ttu-id="cb5e9-995">Entity Framework 6 a introduit la prise en charge des opérations asynchrones lors de l’exécution sur .NET 4,5 ou une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-995">Entity Framework 6 introduced support of async operations when running on .NET 4.5 or later.</span></span> <span data-ttu-id="cb5e9-996">Pour l’essentiel, les applications qui ont une contention liée à l’e/s tireront le meilleur parti de l’utilisation des opérations asynchrones de requête et d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-996">For the most part, applications that have IO related contention will benefit the most from using asynchronous query and save operations.</span></span> <span data-ttu-id="cb5e9-997">Si votre application ne subit pas de contention d’e/s, l’utilisation de Async va, dans les meilleurs cas, s’exécuter de façon synchrone et retourner le résultat dans le même laps de temps qu’un appel synchrone, ou dans le pire des cas, il suffit de différer l’exécution à une tâche asynchrone et d’ajouter du temps supplémentaire à la fin de votre scénario.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-997">If your application does not suffer from IO contention, the use of async will, in the best cases, run synchronously and return the result in the same amount of time as a synchronous call, or in the worst case, simply defer execution to an asynchronous task and add extra time to the completion of your scenario.</span></span>

<span data-ttu-id="cb5e9-998">Pour plus d’informations sur le fonctionnement de la programmation asynchrone qui vous permet de décider si Async améliorera les performances de votre application, consultez [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx) .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-998">For information on how asynchronous programming work that will help you deciding if async will improve the performance of your application visit [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span></span> <span data-ttu-id="cb5e9-999">Pour plus d’informations sur l’utilisation des opérations asynchrones sur Entity Framework, consultez [requête Async et enregistrement](xref:ef6/fundamentals/async
).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-999">For more information on the use of async operations on Entity Framework, see [Async Query and Save](xref:ef6/fundamentals/async
).</span></span>

### <a name="96-ngen"></a><span data-ttu-id="cb5e9-1000">9,6 NGEN</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1000">9.6      NGEN</span></span>

<span data-ttu-id="cb5e9-1001">Entity Framework 6 ne figure pas dans l’installation par défaut de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1001">Entity Framework 6 does not come in the default installation of .NET framework.</span></span> <span data-ttu-id="cb5e9-1002">Par conséquent, les assemblys Entity Framework ne sont pas NGEN par défaut, ce qui signifie que tous les Entity Framework code sont soumis aux mêmes coûts JIT’ing que tout autre assembly MSIL.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1002">As such, the Entity Framework assemblies are not NGEN’d by default which means that all the Entity Framework code is subject to the same JIT’ing costs as any other MSIL assembly.</span></span> <span data-ttu-id="cb5e9-1003">Cela peut dégrader l’expérience F5 lors du développement et du démarrage à froid de votre application dans les environnements de production.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1003">This might degrade the F5 experience while developing and also the cold startup of your application in the production environments.</span></span> <span data-ttu-id="cb5e9-1004">Afin de réduire les coûts liés au processeur et à la mémoire de JIT’ing, il est recommandé de NGEN les images de Entity Framework, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1004">In order to reduce the CPU and memory costs of JIT’ing it is advisable to NGEN the Entity Framework images as appropriate.</span></span> <span data-ttu-id="cb5e9-1005">Pour plus d’informations sur la façon d’améliorer les performances de démarrage de Entity Framework 6 avec NGEN, consultez [amélioration des performances de démarrage avec NGen](xref:ef6/fundamentals/performance/ngen).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1005">For more information on how to improve the startup performance of Entity Framework 6 with NGEN, see [Improving Startup Performance with NGen](xref:ef6/fundamentals/performance/ngen).</span></span>

### <a name="97-code-first-versus-edmx"></a><span data-ttu-id="cb5e9-1006">9,7 Code First versus EDMX</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1006">9.7      Code First versus EDMX</span></span>

<span data-ttu-id="cb5e9-1007">Entity Framework raisons du problème d’incompatibilité d’impédance entre la programmation orientée objet et les bases de données relationnelles en utilisant une représentation en mémoire du modèle conceptuel (les objets), le schéma de stockage (la base de données) et un mappage entre les deux.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1007">Entity Framework reasons about the impedance mismatch problem between object oriented programming and relational databases by having an in-memory representation of the conceptual model (the objects), the storage schema (the database) and a mapping between the two.</span></span> <span data-ttu-id="cb5e9-1008">Ces métadonnées sont appelées Entity Data Model ou EDM pour Short.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1008">This metadata is called an Entity Data Model, or EDM for short.</span></span> <span data-ttu-id="cb5e9-1009">À partir de ce modèle EDM, Entity Framework dérivera les vues pour aller-retour des données des objets en mémoire vers la base de données et inversement.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1009">From this EDM, Entity Framework will derive the views to roundtrip data from the objects in memory to the database and back.</span></span>

<span data-ttu-id="cb5e9-1010">Lorsque Entity Framework est utilisé avec un fichier EDMX qui spécifie formellement le modèle conceptuel, le schéma de stockage et le mappage, l’étape de chargement du modèle doit uniquement valider le fait que le modèle EDM est correct (par exemple, s’il n’existe pas de mappage), générer les vues, puis valider les vues et faire en sorte que ces métadonnées soient prêtes à être utilisées.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1010">When Entity Framework is used with an EDMX file that formally specifies the conceptual model, the storage schema, and the mapping, then the model loading stage only has to validate that the EDM is correct (for example, make sure that no mappings are missing), then generate the views, then validate the views and have this metadata ready for use.</span></span> <span data-ttu-id="cb5e9-1011">Seule une requête peut être exécutée ou de nouvelles données doivent être enregistrées dans le magasin de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1011">Only then can a query be executed or new data be saved to the data store.</span></span>

<span data-ttu-id="cb5e9-1012">L’approche Code First est, au cœur, un générateur de Entity Data Model sophistiqué.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1012">The Code First approach is, at its heart, a sophisticated Entity Data Model generator.</span></span> <span data-ttu-id="cb5e9-1013">Le Entity Framework doit générer un modèle EDM à partir du code fourni ; pour ce faire, il analyse les classes impliquées dans le modèle, en appliquant des conventions et en configurant le modèle via l’API Fluent.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1013">The Entity Framework has to produce an EDM from the provided code; it does so by analyzing the classes involved in the model, applying conventions and configuring the model via the Fluent API.</span></span> <span data-ttu-id="cb5e9-1014">Une fois le modèle EDM généré, le Entity Framework se comporte essentiellement de la même façon qu’un fichier EDMX était présent dans le projet.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1014">After the EDM is built, the Entity Framework essentially behaves the same way as it would had an EDMX file been present in the project.</span></span> <span data-ttu-id="cb5e9-1015">Par conséquent, la génération du modèle à partir de Code First ajoute une complexité supplémentaire qui se traduit par un temps de démarrage plus lent pour le Entity Framework par rapport à un EDMX.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1015">Thus, building the model from Code First adds extra complexity that translates into a slower startup time for the Entity Framework when compared to having an EDMX.</span></span> <span data-ttu-id="cb5e9-1016">Le coût dépend entièrement de la taille et de la complexité du modèle en cours de génération.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1016">The cost is completely dependent on the size and complexity of the model that’s being built.</span></span>

<span data-ttu-id="cb5e9-1017">Lorsque vous choisissez d’utiliser EDMX et Code First, il est important de savoir que la flexibilité introduite par Code First augmente le coût de la création du modèle pour la première fois.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1017">When choosing to use EDMX versus Code First, it’s important to know that the flexibility introduced by Code First increases the cost of building the model for the first time.</span></span> <span data-ttu-id="cb5e9-1018">Si votre application peut résister au coût de cette première charge, il est généralement Code First est la meilleure façon de procéder.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1018">If your application can withstand the cost of this first-time load then typically Code First will be the preferred way to go.</span></span>

## <a name="10-investigating-performance"></a><span data-ttu-id="cb5e9-1019">10 examen des performances</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1019">10 Investigating Performance</span></span>

### <a name="101-using-the-visual-studio-profiler"></a><span data-ttu-id="cb5e9-1020">10,1 utilisation du profileur Visual Studio</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1020">10.1 Using the Visual Studio Profiler</span></span>

<span data-ttu-id="cb5e9-1021">Si vous rencontrez des problèmes de performances avec la Entity Framework, vous pouvez utiliser un profileur comme celui qui est intégré à Visual Studio pour voir où votre application consacre son temps.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1021">If you are having performance issues with the Entity Framework, you can use a profiler like the one built into Visual Studio to see where your application is spending its time.</span></span> <span data-ttu-id="cb5e9-1022">Il s’agit de l’outil que nous avons utilisé pour générer les graphiques à secteurs dans le billet de blog « Exploring the performance of the ADO.NET Entity Framework-part 1 » (en anglais \<https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1> ) qui montre où Entity Framework passe son temps pendant les requêtes à froid et à chaud.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1022">This is the tool we used to generate the pie charts in the “Exploring the Performance of the ADO.NET Entity Framework - Part 1” blog post ( \<https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1>) that show where Entity Framework spends its time during cold and warm queries.</span></span>

<span data-ttu-id="cb5e9-1023">Le billet de blog « profilage Entity Framework à l’aide du profileur Visual Studio 2010 » écrit par l’équipe de Conseil des clients de modélisation et de données montre un exemple concret de la façon dont ils ont utilisé le profileur pour examiner un problème de   \<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler> performances.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1023">The "Profiling Entity Framework using the Visual Studio 2010 Profiler" blog post written by the Data and Modeling Customer Advisory Team shows a real-world example of how they used the profiler to investigate a performance problem.  \<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler>.</span></span> <span data-ttu-id="cb5e9-1024">Ce billet a été écrit pour une application Windows.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1024">This post was written for a windows application.</span></span> <span data-ttu-id="cb5e9-1025">Si vous devez profiler une application Web, l’enregistreur de performances Windows (WPR) et les outils de l’analyseur de performances Windows (WPA) peuvent fonctionner mieux que si vous utilisiez Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1025">If you need to profile a web application the Windows Performance Recorder (WPR) and Windows Performance Analyzer (WPA) tools may work better than working from Visual Studio.</span></span> <span data-ttu-id="cb5e9-1026">WPR et WPA font partie de Windows performance Toolkit, qui est inclus dans le kit de déploiement et d’évaluation Windows ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982) ).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1026">WPR and WPA are part of the Windows Performance Toolkit which is included with the Windows Assessment and Deployment Kit ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)).</span></span>

### <a name="102-applicationdatabase-profiling"></a><span data-ttu-id="cb5e9-1027">profilage de base de données/application 10,2</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1027">10.2 Application/Database profiling</span></span>

<span data-ttu-id="cb5e9-1028">Les outils tels que le profileur intégré à Visual Studio vous indiquent où votre application consacre du temps.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1028">Tools like the profiler built into Visual Studio tell you where your application is spending time.</span></span><span data-ttu-id="cb5e9-1029">Un autre type de profileur est disponible pour effectuer une analyse dynamique de votre application en cours d’exécution, soit en production, soit en préproduction en fonction des besoins, et recherche des pièges et des anti-modèles courants d’accès aux bases de données.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1029">  Another type of profiler is available that performs dynamic analysis of your running application, either in production or pre-production depending on needs, and looks for common pitfalls and anti-patterns of database access.</span></span>

<span data-ttu-id="cb5e9-1030">Deux profileurs disponibles dans le commerce sont le profileur Entity Framework ( \<http://efprof.com> ) et ORMProfiler ( \<http://ormprofiler.com> ).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1030">Two commercially available profilers are the Entity Framework Profiler ( \<http://efprof.com>) and ORMProfiler ( \<http://ormprofiler.com>).</span></span>

<span data-ttu-id="cb5e9-1031">Si votre application est une application MVC utilisant Code First, vous pouvez utiliser mini de StackExchange.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1031">If your application is an MVC application using Code First, you can use StackExchange's MiniProfiler.</span></span> <span data-ttu-id="cb5e9-1032">Scott Hanselman décrit cet outil dans son blog à l’adresse suivante : \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1032">Scott Hanselman describes this tool in his blog at: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span></span>

<span data-ttu-id="cb5e9-1033">Pour plus d’informations sur le profilage de l’activité de la base de données de votre application, consultez l’article du magazine MSDN de Julie Lerman intitulé [profilage de l’activité des bases de données dans le Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1033">For more information on profiling your application's database activity, see Julie Lerman's MSDN Magazine article titled [Profiling Database Activity in the Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span></span>

### <a name="103-database-logger"></a><span data-ttu-id="cb5e9-1034">enregistreur d’événements de base de données 10,3</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1034">10.3 Database logger</span></span>

<span data-ttu-id="cb5e9-1035">Si vous utilisez Entity Framework 6, pensez également à utiliser la fonctionnalité de journalisation intégrée.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1035">If you are using Entity Framework 6 also consider using the built-in logging functionality.</span></span> <span data-ttu-id="cb5e9-1036">La propriété de base de données du contexte peut être invitée à consigner son activité via une simple configuration à une seule ligne :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1036">The Database property of the context can be instructed to log its activity via a simple one-line configuration:</span></span>

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

<span data-ttu-id="cb5e9-1037">Dans cet exemple, l’activité de base de données est enregistrée dans la console, mais la propriété log peut être configurée pour appeler n’importe quel délégué de chaîne d’action &lt; &gt; .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1037">In this example the database activity will be logged to the console, but the Log property can be configured to call any Action&lt;string&gt; delegate.</span></span>

<span data-ttu-id="cb5e9-1038">Si vous souhaitez activer la journalisation de la base de données sans recompiler, et que vous utilisez Entity Framework 6,1 ou une version ultérieure, vous pouvez le faire en ajoutant un intercepteur dans le fichier web.config ou app.config de votre application.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1038">If you want to enable database logging without recompiling, and you are using Entity Framework 6.1 or later, you can do so by adding an interceptor in the web.config or app.config file of your application.</span></span>

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

<span data-ttu-id="cb5e9-1039">Pour plus d’informations sur la façon d’ajouter la journalisation sans recompilation, accédez à \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/> .</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1039">For more information on how to add logging without recompiling go to \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span></span>

## <a name="11-appendix"></a><span data-ttu-id="cb5e9-1040">11 Annexe</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1040">11 Appendix</span></span>

### <a name="111-a-test-environment"></a><span data-ttu-id="cb5e9-1041">11,1 A. environnement de test</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1041">11.1 A. Test Environment</span></span>

<span data-ttu-id="cb5e9-1042">Cet environnement utilise une configuration de 2 machines avec la base de données sur un ordinateur distinct de l’application cliente.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1042">This environment uses a 2-machine setup with the database on a separate machine from the client application.</span></span> <span data-ttu-id="cb5e9-1043">Les machines se trouvent dans le même rack, de sorte que la latence du réseau est relativement faible, mais plus réaliste qu’un environnement à un seul ordinateur.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1043">Machines are in the same rack, so network latency is relatively low, but more realistic than a single-machine environment.</span></span>

#### <a name="1111-app-server"></a><span data-ttu-id="cb5e9-1044">11.1.1 serveur d’applications</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1044">11.1.1       App Server</span></span>

##### <a name="11111-software-environment"></a><span data-ttu-id="cb5e9-1045">Environnement logiciel 11.1.1.1</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1045">11.1.1.1      Software Environment</span></span>

-   <span data-ttu-id="cb5e9-1046">Entity Framework 4 environnement logiciel</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1046">Entity Framework 4 Software Environment</span></span>
    -   <span data-ttu-id="cb5e9-1047">Nom du système d’exploitation : Windows Server 2008 R2 Entreprise SP1.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1047">OS Name: Windows Server 2008 R2 Enterprise SP1.</span></span>
    -   <span data-ttu-id="cb5e9-1048">Visual Studio 2010 – Ultimate.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1048">Visual Studio 2010 – Ultimate.</span></span>
    -   <span data-ttu-id="cb5e9-1049">Visual Studio 2010 SP1 (uniquement pour certaines comparaisons).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1049">Visual Studio 2010 SP1 (only for some comparisons).</span></span>
-   <span data-ttu-id="cb5e9-1050">Entity Framework un environnement logiciel de 5 et 6</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1050">Entity Framework 5 and 6 Software Environment</span></span>
    -   <span data-ttu-id="cb5e9-1051">Nom du système d’exploitation : Windows 8.1 Enterprise</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1051">OS Name: Windows 8.1 Enterprise</span></span>
    -   <span data-ttu-id="cb5e9-1052">Visual Studio 2013 – Ultimate.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1052">Visual Studio 2013 – Ultimate.</span></span>

##### <a name="11112-hardware-environment"></a><span data-ttu-id="cb5e9-1053">Environnement matériel 11.1.1.2</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1053">11.1.1.2      Hardware Environment</span></span>

-   <span data-ttu-id="cb5e9-1054">Processeur double : Intel (R) Xeon (R) CPU L5520 W3530 @ 2,27 GHz, 2261 Mhz8 GHz, 4 cœurs, 84 processeur logique (s).</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1054">Dual Processor:     Intel(R) Xeon(R) CPU L5520 W3530 @ 2.27GHz, 2261 Mhz8 GHz, 4 Core(s), 84 Logical Processor(s).</span></span>
-   <span data-ttu-id="cb5e9-1055">2412 Go RamRAM.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1055">2412 GB RamRAM.</span></span>
-   <span data-ttu-id="cb5e9-1056">lecteur 136 Go SCSI250GB SATA 7200 RPM 3 Go/s divisé en 4 partitions.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1056">136 GB SCSI250GB SATA 7200 rpm 3GB/s drive split into 4 partitions.</span></span>

#### <a name="1112-db-server"></a><span data-ttu-id="cb5e9-1057">serveur 11.1.2 DB</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1057">11.1.2       DB server</span></span>

##### <a name="11121-software-environment"></a><span data-ttu-id="cb5e9-1058">Environnement logiciel 11.1.2.1</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1058">11.1.2.1      Software Environment</span></span>

-   <span data-ttu-id="cb5e9-1059">Nom du système d’exploitation : Windows Server 2008 R 28.1 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1059">OS Name: Windows Server 2008 R28.1 Enterprise SP1.</span></span>
-   <span data-ttu-id="cb5e9-1060">SQL Server 2008 R22012.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1060">SQL Server 2008 R22012.</span></span>

##### <a name="11122-hardware-environment"></a><span data-ttu-id="cb5e9-1061">Environnement matériel 11.1.2.2</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1061">11.1.2.2      Hardware Environment</span></span>

-   <span data-ttu-id="cb5e9-1062">Processeur unique : Intel (R) Xeon (R) CPU L5520 @ 2,27 GHz, 2261 MhzES-1620 0 @ 3,60 GHz, 4 cœurs (s), 8 processeurs logiques.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1062">Single Processor: Intel(R) Xeon(R) CPU L5520  @ 2.27GHz, 2261 MhzES-1620 0 @ 3.60GHz, 4 Core(s), 8 Logical Processor(s).</span></span>
-   <span data-ttu-id="cb5e9-1063">824 Go RamRAM.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1063">824 GB RamRAM.</span></span>
-   <span data-ttu-id="cb5e9-1064">lecteur 465 Go ATA500GB SATA 7200 RPM 6 Go/s divisé en 4 partitions.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1064">465 GB ATA500GB SATA 7200 rpm 6GB/s drive split into 4 partitions.</span></span>

### <a name="112-b-query-performance-comparison-tests"></a><span data-ttu-id="cb5e9-1065">11,2 B. tests de comparaison des performances des requêtes</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1065">11.2      B. Query performance comparison tests</span></span>

<span data-ttu-id="cb5e9-1066">Le modèle Northwind a été utilisé pour exécuter ces tests.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1066">The Northwind model was used to execute these tests.</span></span> <span data-ttu-id="cb5e9-1067">Il a été généré à partir de la base de données à l’aide du concepteur de Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1067">It was generated from the database using the Entity Framework designer.</span></span> <span data-ttu-id="cb5e9-1068">Ensuite, le code suivant a été utilisé pour comparer les performances des options d’exécution de la requête :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1068">Then, the following code was used to compare the performance of the query execution options:</span></span>

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a><span data-ttu-id="cb5e9-1069">11,3 C. modèle Navision</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1069">11.3 C. Navision Model</span></span>

<span data-ttu-id="cb5e9-1070">La base de données Navision est une base de données volumineuse utilisée pour la démonstration de Microsoft Dynamics-NAV.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1070">The Navision database is a large database used to demo Microsoft Dynamics – NAV.</span></span> <span data-ttu-id="cb5e9-1071">Le modèle conceptuel généré contient les jeux d’entités 1005 et les ensembles d’associations 4227.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1071">The generated conceptual model contains 1005 entity sets and 4227 association sets.</span></span> <span data-ttu-id="cb5e9-1072">Le modèle utilisé dans le test est « Flat », aucun héritage n’a été ajouté à ce dernier.</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1072">The model used in the test is “flat” – no inheritance has been added to it.</span></span>

#### <a name="1131-queries-used-for-navision-tests"></a><span data-ttu-id="cb5e9-1073">requêtes 11.3.1 utilisées pour les tests Navision</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1073">11.3.1 Queries used for Navision tests</span></span>

<span data-ttu-id="cb5e9-1074">La liste de requêtes utilisée avec le modèle Navision contient 3 catégories de Entity SQL requêtes :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1074">The queries list used with the Navision model contains 3 categories of Entity SQL queries:</span></span>

##### <a name="11311-lookup"></a><span data-ttu-id="cb5e9-1075">recherche 11.3.1.1</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1075">11.3.1.1 Lookup</span></span>

<span data-ttu-id="cb5e9-1076">Requête de recherche simple sans agrégations</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1076">A simple lookup query with no aggregations</span></span>

-   <span data-ttu-id="cb5e9-1077">Nombre : 16232</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1077">Count: 16232</span></span>
-   <span data-ttu-id="cb5e9-1078">Exemple :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1078">Example:</span></span>

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a><span data-ttu-id="cb5e9-1079">11.3.1.2 SingleAggregating</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1079">11.3.1.2 SingleAggregating</span></span>

<span data-ttu-id="cb5e9-1080">Requête BI normale avec plusieurs agrégations, mais aucun sous-total (requête unique)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1080">A normal BI query with multiple aggregations, but no subtotals (single query)</span></span>

-   <span data-ttu-id="cb5e9-1081">Nombre : 2313</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1081">Count: 2313</span></span>
-   <span data-ttu-id="cb5e9-1082">Exemple :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1082">Example:</span></span>

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

<span data-ttu-id="cb5e9-1083">Où MDF \_ SessionLogin \_ Time \_ Max () est défini dans le modèle de la façon suivante :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1083">Where MDF\_SessionLogin\_Time\_Max() is defined in the model as:</span></span>

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a><span data-ttu-id="cb5e9-1084">11.3.1.3 AggregatingSubtotals</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1084">11.3.1.3 AggregatingSubtotals</span></span>

<span data-ttu-id="cb5e9-1085">Une requête BI avec des agrégations et des sous-totaux (par le biais de l’instruction Union All)</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1085">A BI query with aggregations and subtotals (via union all)</span></span>

-   <span data-ttu-id="cb5e9-1086">Nombre : 178</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1086">Count: 178</span></span>
-   <span data-ttu-id="cb5e9-1087">Exemple :</span><span class="sxs-lookup"><span data-stu-id="cb5e9-1087">Example:</span></span>

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
