---
title: Journalisation et interception des opérations de base de données-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: 35b0284a5ad8b2b732f074589bd458d243312575
ms.sourcegitcommit: 708b18520321c587b2046ad2ea9fa7c48aeebfe5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/09/2019
ms.locfileid: "72181659"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="abb30-102">Journalisation et interception des opérations de base de données</span><span class="sxs-lookup"><span data-stu-id="abb30-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="abb30-103">**EF6 et versions ultérieures uniquement** : Les fonctionnalités, les API, etc. décrites dans cette page ont été introduites dans Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="abb30-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="abb30-104">Si vous utilisez une version antérieure, certaines ou toutes les informations ne s’appliquent pas.</span><span class="sxs-lookup"><span data-stu-id="abb30-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="abb30-105">À partir de Entity Framework 6, chaque fois que Entity Framework envoie une commande à la base de données, cette commande peut être interceptée par le code de l’application.</span><span class="sxs-lookup"><span data-stu-id="abb30-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="abb30-106">C’est le plus souvent utilisé pour la journalisation SQL, mais elle peut également être utilisée pour modifier ou abandonner la commande.</span><span class="sxs-lookup"><span data-stu-id="abb30-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="abb30-107">En particulier, EF comprend les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="abb30-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="abb30-108">Une propriété de journal pour le contexte similaire à DataContext. log dans LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="abb30-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="abb30-109">Mécanisme de personnalisation du contenu et de la mise en forme de la sortie envoyée au Journal</span><span class="sxs-lookup"><span data-stu-id="abb30-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="abb30-110">Blocs de construction de bas niveau pour l’interception donnant plus de contrôle/flexibilité</span><span class="sxs-lookup"><span data-stu-id="abb30-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="abb30-111">Propriété du journal de contexte</span><span class="sxs-lookup"><span data-stu-id="abb30-111">Context Log property</span></span>  

<span data-ttu-id="abb30-112">La propriété DbContext. Database. log peut avoir pour valeur un délégué pour toute méthode qui prend une chaîne.</span><span class="sxs-lookup"><span data-stu-id="abb30-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="abb30-113">Le plus souvent, il est utilisé avec n’importe quel TextWriter en le définissant sur la méthode « Write » de ce TextWriter.</span><span class="sxs-lookup"><span data-stu-id="abb30-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="abb30-114">Toutes les SQL générées par le contexte actuel seront enregistrées dans ce writer.</span><span class="sxs-lookup"><span data-stu-id="abb30-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="abb30-115">Par exemple, le code suivant consignera SQL sur la console :</span><span class="sxs-lookup"><span data-stu-id="abb30-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="abb30-116">Notez ce contexte. Database. log est défini sur console. Write.</span><span class="sxs-lookup"><span data-stu-id="abb30-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="abb30-117">C’est tout ce qui est nécessaire pour enregistrer SQL sur la console.</span><span class="sxs-lookup"><span data-stu-id="abb30-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="abb30-118">Nous allons ajouter un code simple de requête/insertion/mise à jour pour pouvoir voir une sortie :</span><span class="sxs-lookup"><span data-stu-id="abb30-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="abb30-119">La sortie suivante est générée :</span><span class="sxs-lookup"><span data-stu-id="abb30-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="abb30-120">(Notez qu’il s’agit de la sortie en supposant que toutes les initialisations de base de données ont déjà eu lieu.</span><span class="sxs-lookup"><span data-stu-id="abb30-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="abb30-121">Si l’initialisation de la base de données ne s’est pas encore produite, il y aurait beaucoup plus de sortie qui indique que toutes les migrations de travail effectuées dans le cadre de la recherche ou de la création d’une nouvelle base de données.)</span><span class="sxs-lookup"><span data-stu-id="abb30-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="abb30-122">Qu’est-ce qui est enregistré ?</span><span class="sxs-lookup"><span data-stu-id="abb30-122">What gets logged?</span></span>  

<span data-ttu-id="abb30-123">Lorsque la propriété log est définie, tous les éléments suivants sont enregistrés :</span><span class="sxs-lookup"><span data-stu-id="abb30-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="abb30-124">SQL pour tous les différents types de commandes.</span><span class="sxs-lookup"><span data-stu-id="abb30-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="abb30-125">Exemple :</span><span class="sxs-lookup"><span data-stu-id="abb30-125">For example:</span></span>  
    - <span data-ttu-id="abb30-126">Requêtes, y compris les requêtes LINQ normales, les requêtes eSQL et les requêtes brutes à partir de méthodes telles que SqlQuery</span><span class="sxs-lookup"><span data-stu-id="abb30-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="abb30-127">Insertions, mises à jour et suppressions générées dans le cadre d’SaveChanges</span><span class="sxs-lookup"><span data-stu-id="abb30-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="abb30-128">Requêtes de chargement des relations, telles que celles générées par le chargement différé</span><span class="sxs-lookup"><span data-stu-id="abb30-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="abb30-129">Paramètres</span><span class="sxs-lookup"><span data-stu-id="abb30-129">Parameters</span></span>  
- <span data-ttu-id="abb30-130">Indique si la commande est exécutée de façon asynchrone</span><span class="sxs-lookup"><span data-stu-id="abb30-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="abb30-131">Horodateur indiquant le début de l’exécution de la commande</span><span class="sxs-lookup"><span data-stu-id="abb30-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="abb30-132">Si la commande a été exécutée avec succès, a échoué en levant une exception ou, pour Async, a été annulée</span><span class="sxs-lookup"><span data-stu-id="abb30-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="abb30-133">Indication de la valeur de résultat</span><span class="sxs-lookup"><span data-stu-id="abb30-133">Some indication of the result value</span></span>  
- <span data-ttu-id="abb30-134">Durée approximative nécessaire à l’exécution de la commande.</span><span class="sxs-lookup"><span data-stu-id="abb30-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="abb30-135">Notez qu’il s’agit de l’heure à partir de l’envoi de la commande pour récupérer l’objet de résultat.</span><span class="sxs-lookup"><span data-stu-id="abb30-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="abb30-136">Elle n’inclut pas le temps nécessaire pour lire les résultats.</span><span class="sxs-lookup"><span data-stu-id="abb30-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="abb30-137">En examinant l’exemple de sortie ci-dessus, chacune des quatre commandes journalisées est la suivante :</span><span class="sxs-lookup"><span data-stu-id="abb30-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="abb30-138">Requête résultant de l’appel au contexte. Blogs.</span><span class="sxs-lookup"><span data-stu-id="abb30-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="abb30-139">Notez que la méthode ToString pour obtenir le SQL n’aurait pas fonctionné pour cette requête puisque « First » ne fournit pas de IQueryable sur lequel ToString pourrait être appelé</span><span class="sxs-lookup"><span data-stu-id="abb30-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="abb30-140">Requête résultant du chargement différé du blog. Publié</span><span class="sxs-lookup"><span data-stu-id="abb30-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="abb30-141">Notez les détails des paramètres pour la valeur de clé pour laquelle le chargement différé se produit</span><span class="sxs-lookup"><span data-stu-id="abb30-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="abb30-142">Seules les propriétés du paramètre définies à des valeurs non définies par défaut sont journalisées.</span><span class="sxs-lookup"><span data-stu-id="abb30-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="abb30-143">Par exemple, la propriété Size s’affiche uniquement si elle est différente de zéro.</span><span class="sxs-lookup"><span data-stu-id="abb30-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="abb30-144">Deux commandes résultant de SaveChangesAsync ; une pour la mise à jour pour modifier un titre de publication, l’autre pour une insertion pour ajouter une nouvelle publication</span><span class="sxs-lookup"><span data-stu-id="abb30-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="abb30-145">Notez les détails des paramètres pour les propriétés FK et title</span><span class="sxs-lookup"><span data-stu-id="abb30-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="abb30-146">Notez que ces commandes sont exécutées de façon asynchrone</span><span class="sxs-lookup"><span data-stu-id="abb30-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="abb30-147">Journalisation dans différents emplacements</span><span class="sxs-lookup"><span data-stu-id="abb30-147">Logging to different places</span></span>  

<span data-ttu-id="abb30-148">Comme indiqué ci-dessus, la journalisation dans la console est très facile.</span><span class="sxs-lookup"><span data-stu-id="abb30-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="abb30-149">Il est également facile de se connecter à la mémoire, au fichier, etc. en utilisant différents genres de [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span><span class="sxs-lookup"><span data-stu-id="abb30-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="abb30-150">Si vous êtes familiarisé avec LINQ to SQL vous pouvez remarquer que dans LINQ to SQL la propriété log est définie sur l’objet TextWriter réel (par exemple, console. out) alors que dans EF, la propriété log est définie sur une méthode qui accepte une chaîne (par exemple, , Console. Write ou console. out. Write).</span><span class="sxs-lookup"><span data-stu-id="abb30-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="abb30-151">Cela consiste à découpler EF de TextWriter en acceptant tout délégué pouvant agir en tant que récepteur pour les chaînes.</span><span class="sxs-lookup"><span data-stu-id="abb30-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="abb30-152">Par exemple, imaginez que vous disposez déjà d’une infrastructure de journalisation et qu’elle définit une méthode de journalisation comme :</span><span class="sxs-lookup"><span data-stu-id="abb30-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="abb30-153">Cela peut être raccordé à la propriété du journal EF comme suit :</span><span class="sxs-lookup"><span data-stu-id="abb30-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="abb30-154">Journalisation des résultats</span><span class="sxs-lookup"><span data-stu-id="abb30-154">Result logging</span></span>  

<span data-ttu-id="abb30-155">L’enregistreur d’événements par défaut enregistre le texte de la commande (SQL), les paramètres et la ligne « en cours d’exécution » avec un horodateur avant que la commande ne soit envoyée à la base de données.</span><span class="sxs-lookup"><span data-stu-id="abb30-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="abb30-156">Une ligne « terminée » contenant le temps écoulé est journalisée après l’exécution de la commande.</span><span class="sxs-lookup"><span data-stu-id="abb30-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="abb30-157">Notez que, pour les commandes Async, la ligne « terminé » n’est journalisée que lorsque la tâche asynchrone se termine, échoue ou est annulée.</span><span class="sxs-lookup"><span data-stu-id="abb30-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="abb30-158">La ligne « terminé » contient des informations différentes selon le type de commande et si l’exécution a réussi ou non.</span><span class="sxs-lookup"><span data-stu-id="abb30-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="abb30-159">Exécution réussie</span><span class="sxs-lookup"><span data-stu-id="abb30-159">Successful execution</span></span>  

<span data-ttu-id="abb30-160">Pour les commandes qui se terminent correctement, la sortie est « terminée en x ms avec le résultat : », suivie d’une indication du résultat.</span><span class="sxs-lookup"><span data-stu-id="abb30-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="abb30-161">Pour les commandes qui retournent un lecteur de données, l’indication du résultat est le type de [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) retourné.</span><span class="sxs-lookup"><span data-stu-id="abb30-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="abb30-162">Pour les commandes qui retournent une valeur entière, comme la commande de mise à jour affichée au-dessus du résultat affiché, est cet entier.</span><span class="sxs-lookup"><span data-stu-id="abb30-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="abb30-163">Échec de l’exécution</span><span class="sxs-lookup"><span data-stu-id="abb30-163">Failed execution</span></span>  

<span data-ttu-id="abb30-164">Pour les commandes qui échouent en levant une exception, la sortie contient le message de l’exception.</span><span class="sxs-lookup"><span data-stu-id="abb30-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="abb30-165">Par exemple, l’utilisation de SqlQuery pour effectuer des requêtes sur une table qui existe entraîne une sortie de journal similaire à ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="abb30-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="abb30-166">Exécution annulée</span><span class="sxs-lookup"><span data-stu-id="abb30-166">Canceled execution</span></span>  

<span data-ttu-id="abb30-167">Pour les commandes Async où la tâche est annulée, le résultat peut être un échec avec une exception, car c’est ce que fait souvent le fournisseur ADO.NET sous-jacent lorsqu’une tentative d’annulation est effectuée.</span><span class="sxs-lookup"><span data-stu-id="abb30-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="abb30-168">Si cela ne se produit pas et que la tâche est annulée correctement, la sortie se présente comme suit :</span><span class="sxs-lookup"><span data-stu-id="abb30-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```console
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="abb30-169">Modification du contenu et de la mise en forme du journal</span><span class="sxs-lookup"><span data-stu-id="abb30-169">Changing log content and formatting</span></span>  

<span data-ttu-id="abb30-170">En coulisses, la propriété Database. log utilise un objet DatabaseLogFormatter.</span><span class="sxs-lookup"><span data-stu-id="abb30-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="abb30-171">Cet objet lie efficacement une implémentation de IDbCommandInterceptor (voir ci-dessous) à un délégué qui accepte des chaînes et un DbContext.</span><span class="sxs-lookup"><span data-stu-id="abb30-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="abb30-172">Cela signifie que les méthodes sur DatabaseLogFormatter sont appelées avant et après l’exécution de commandes par EF.</span><span class="sxs-lookup"><span data-stu-id="abb30-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="abb30-173">Ces méthodes DatabaseLogFormatter rassemblent et mettent en forme la sortie de journal et l’envoient au délégué.</span><span class="sxs-lookup"><span data-stu-id="abb30-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="abb30-174">Personnalisation de DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="abb30-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="abb30-175">La modification de ce qui est enregistré et de sa mise en forme peut être obtenue en créant une nouvelle classe qui dérive de DatabaseLogFormatter et substitue les méthodes selon le cas.</span><span class="sxs-lookup"><span data-stu-id="abb30-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="abb30-176">Les méthodes les plus courantes de remplacement sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="abb30-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="abb30-177">LogCommand : remplacez cette valeur pour modifier la façon dont les commandes sont journalisées avant leur exécution.</span><span class="sxs-lookup"><span data-stu-id="abb30-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="abb30-178">Par défaut, LogCommand appelle LogParameter pour chaque paramètre ; vous pouvez choisir d’effectuer la même opération dans votre remplacement ou gérer les paramètres différemment.</span><span class="sxs-lookup"><span data-stu-id="abb30-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="abb30-179">LogResult : remplacez cette valeur pour modifier le mode de journalisation du résultat de l’exécution d’une commande.</span><span class="sxs-lookup"><span data-stu-id="abb30-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="abb30-180">LogParameter : remplacez cette valeur pour modifier la mise en forme et le contenu de la journalisation des paramètres.</span><span class="sxs-lookup"><span data-stu-id="abb30-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="abb30-181">Par exemple, supposons que nous voulions enregistrer une seule ligne avant que chaque commande ne soit envoyée à la base de données.</span><span class="sxs-lookup"><span data-stu-id="abb30-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="abb30-182">Pour ce faire, vous pouvez utiliser deux remplacements :</span><span class="sxs-lookup"><span data-stu-id="abb30-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="abb30-183">Remplacer LogCommand pour mettre en forme et écrire la ligne unique de SQL</span><span class="sxs-lookup"><span data-stu-id="abb30-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="abb30-184">Remplacez LogResult pour ne rien faire.</span><span class="sxs-lookup"><span data-stu-id="abb30-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="abb30-185">Le code doit ressembler à ceci :</span><span class="sxs-lookup"><span data-stu-id="abb30-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="abb30-186">Pour consigner la sortie, appelez simplement la méthode Write qui enverra la sortie au délégué d’écriture configuré.</span><span class="sxs-lookup"><span data-stu-id="abb30-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="abb30-187">(Notez que ce code effectue une suppression simpliste des sauts de ligne comme un exemple.</span><span class="sxs-lookup"><span data-stu-id="abb30-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="abb30-188">Elle ne fonctionnera probablement pas correctement pour l’affichage de SQL complexe.)</span><span class="sxs-lookup"><span data-stu-id="abb30-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="abb30-189">Définition de DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="abb30-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="abb30-190">Une fois qu’une nouvelle classe DatabaseLogFormatter a été créée, elle doit être inscrite auprès d’EF.</span><span class="sxs-lookup"><span data-stu-id="abb30-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="abb30-191">Cette opération s’effectue à l’aide de la configuration basée sur le code.</span><span class="sxs-lookup"><span data-stu-id="abb30-191">This is done using code-based configuration.</span></span> <span data-ttu-id="abb30-192">En résumé, cela implique la création d’une nouvelle classe qui dérive de DbConfiguration dans le même assembly que votre classe DbContext, puis l’appel de SetDatabaseLogFormatter dans le constructeur de cette nouvelle classe.</span><span class="sxs-lookup"><span data-stu-id="abb30-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="abb30-193">Exemple :</span><span class="sxs-lookup"><span data-stu-id="abb30-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="abb30-194">Utilisation du nouveau DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="abb30-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="abb30-195">Ce nouveau DatabaseLogFormatter sera désormais utilisé à chaque fois que Database. log est défini.</span><span class="sxs-lookup"><span data-stu-id="abb30-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="abb30-196">Par conséquent, l’exécution du code de la partie 1 génère désormais la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="abb30-196">So, running the code from part 1 will now result in the following output:</span></span>  

```console
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="abb30-197">Blocs de construction d’interception</span><span class="sxs-lookup"><span data-stu-id="abb30-197">Interception building blocks</span></span>  

<span data-ttu-id="abb30-198">Jusqu’à présent, nous avons vu comment utiliser DbContext. Database. log pour journaliser le SQL généré par EF.</span><span class="sxs-lookup"><span data-stu-id="abb30-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="abb30-199">Mais ce code est en fait une façade relativement légère sur certains blocs de construction de bas niveau pour une interception plus générale.</span><span class="sxs-lookup"><span data-stu-id="abb30-199">But this code is actually a relatively thin facade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="abb30-200">Interfaces d’interception</span><span class="sxs-lookup"><span data-stu-id="abb30-200">Interception interfaces</span></span>  

<span data-ttu-id="abb30-201">Le code d’interception est construit autour du concept d’interfaces d’interception.</span><span class="sxs-lookup"><span data-stu-id="abb30-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="abb30-202">Ces interfaces héritent de IDbInterceptor et définissent les méthodes appelées quand EF effectue une action.</span><span class="sxs-lookup"><span data-stu-id="abb30-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="abb30-203">L’objectif est d’avoir une interface par type d’objet qui est intercepté.</span><span class="sxs-lookup"><span data-stu-id="abb30-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="abb30-204">Par exemple, l’interface IDbCommandInterceptor définit des méthodes qui sont appelées avant que EF effectue un appel à ExecuteNonQuery, ExecuteScalar, ExecuteReader et les méthodes associées.</span><span class="sxs-lookup"><span data-stu-id="abb30-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="abb30-205">De même, l’interface définit les méthodes qui sont appelées lorsque chacune de ces opérations se termine.</span><span class="sxs-lookup"><span data-stu-id="abb30-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="abb30-206">La classe DatabaseLogFormatter que nous avons examinée ci-dessus implémente cette interface pour enregistrer des commandes.</span><span class="sxs-lookup"><span data-stu-id="abb30-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="abb30-207">Contexte d’interception</span><span class="sxs-lookup"><span data-stu-id="abb30-207">The interception context</span></span>  

<span data-ttu-id="abb30-208">En examinant les méthodes définies sur l’une des interfaces d’intercepteur, il est évident que chaque appel reçoit un objet de type DbInterceptionContext ou un type dérivé de celui-ci, tel que DbCommandInterceptionContext\<\>.</span><span class="sxs-lookup"><span data-stu-id="abb30-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="abb30-209">Cet objet contient des informations contextuelles sur l’action effectuée par EF.</span><span class="sxs-lookup"><span data-stu-id="abb30-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="abb30-210">Par exemple, si l’action est effectuée pour le compte d’un DbContext, le DbContext est inclus dans le DbInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="abb30-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="abb30-211">De même, pour les commandes qui sont exécutées de façon asynchrone, l’indicateur IsAsync est défini sur DbCommandInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="abb30-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="abb30-212">Gestion des résultats</span><span class="sxs-lookup"><span data-stu-id="abb30-212">Result handling</span></span>  

<span data-ttu-id="abb30-213">La classe DbCommandInterceptionContext\<\> contient des propriétés appelées result, OriginalResult, exception et OriginalException.</span><span class="sxs-lookup"><span data-stu-id="abb30-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="abb30-214">Ces propriétés ont la valeur null/zéro pour les appels aux méthodes d’interception qui sont appelées avant l’exécution de l’opération, c’est-à-dire pour le... Exécution des méthodes.</span><span class="sxs-lookup"><span data-stu-id="abb30-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="abb30-215">Si l’opération est exécutée et réussit, result et OriginalResult sont définis sur le résultat de l’opération.</span><span class="sxs-lookup"><span data-stu-id="abb30-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="abb30-216">Ces valeurs peuvent ensuite être observées dans les méthodes d’interception qui sont appelées après l’exécution de l’opération, c’est-à-dire sur le... Méthodes exécutées.</span><span class="sxs-lookup"><span data-stu-id="abb30-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="abb30-217">De même, si l’opération lève, les propriétés exception et OriginalException sont définies.</span><span class="sxs-lookup"><span data-stu-id="abb30-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="abb30-218">Suppression de l’exécution</span><span class="sxs-lookup"><span data-stu-id="abb30-218">Suppressing execution</span></span>  

<span data-ttu-id="abb30-219">Si un intercepteur définit la propriété Result avant l’exécution de la commande (dans l’un des... Exécution des méthodes) ensuite, EF ne tente pas d’exécuter la commande, mais utilise simplement le jeu de résultats.</span><span class="sxs-lookup"><span data-stu-id="abb30-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="abb30-220">En d’autres termes, l’intercepteur peut supprimer l’exécution de la commande, mais l’EF continue comme si la commande avait été exécutée.</span><span class="sxs-lookup"><span data-stu-id="abb30-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="abb30-221">Un exemple d’utilisation de cette méthode est le traitement par lot de commandes qui a traditionnellement été fait avec un fournisseur d’encapsulation.</span><span class="sxs-lookup"><span data-stu-id="abb30-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="abb30-222">L’intercepteur stocke la commande en vue d’une exécution ultérieure sous la forme d’un lot, mais prétend « prétendre » à EF que la commande a été exécutée normalement.</span><span class="sxs-lookup"><span data-stu-id="abb30-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="abb30-223">Notez qu’il faut plus que cela pour implémenter le traitement par lot, mais il s’agit d’un exemple de la façon dont la modification du résultat de l’interception peut être utilisée.</span><span class="sxs-lookup"><span data-stu-id="abb30-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="abb30-224">L’exécution peut également être supprimée en définissant la propriété d’exception dans l’un des... Exécution des méthodes.</span><span class="sxs-lookup"><span data-stu-id="abb30-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="abb30-225">EF se poursuit alors comme si l’exécution de l’opération avait échoué en levant l’exception donnée.</span><span class="sxs-lookup"><span data-stu-id="abb30-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="abb30-226">Cela peut, bien sûr, provoquer le blocage de l’application, mais il peut également s’agir d’une exception temporaire ou d’une autre exception gérée par EF.</span><span class="sxs-lookup"><span data-stu-id="abb30-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="abb30-227">Par exemple, il peut être utilisé dans les environnements de test pour tester le comportement d’une application lorsque l’exécution de la commande échoue.</span><span class="sxs-lookup"><span data-stu-id="abb30-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="abb30-228">Modification du résultat après l’exécution</span><span class="sxs-lookup"><span data-stu-id="abb30-228">Changing the result after execution</span></span>  

<span data-ttu-id="abb30-229">Si un intercepteur définit la propriété Result après l’exécution de la commande (dans l’un des... Méthodes exécutées) ensuite, EF utilise le résultat modifié au lieu du résultat qui a été réellement retourné par l’opération.</span><span class="sxs-lookup"><span data-stu-id="abb30-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="abb30-230">De même, si un intercepteur définit la propriété d’exception après l’exécution de la commande, EF lèvera l’exception Set comme si l’opération avait levé l’exception.</span><span class="sxs-lookup"><span data-stu-id="abb30-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="abb30-231">Un intercepteur peut également définir la propriété d’exception sur null pour indiquer qu’aucune exception ne doit être levée.</span><span class="sxs-lookup"><span data-stu-id="abb30-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="abb30-232">Cela peut être utile si l’exécution de l’opération a échoué, mais que l’intercepteur souhaite que EF continue comme si l’opération avait réussi.</span><span class="sxs-lookup"><span data-stu-id="abb30-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="abb30-233">Cela implique généralement de définir le résultat afin que EF ait une valeur de résultat à utiliser lorsqu’il continue.</span><span class="sxs-lookup"><span data-stu-id="abb30-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="abb30-234">OriginalResult et OriginalException</span><span class="sxs-lookup"><span data-stu-id="abb30-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="abb30-235">Une fois que EF a exécuté une opération, il définit les propriétés result et OriginalResult si l’exécution n’a pas échoué ou les propriétés exception et OriginalException si l’exécution a échoué avec une exception.</span><span class="sxs-lookup"><span data-stu-id="abb30-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="abb30-236">Les propriétés OriginalResult et OriginalException sont en lecture seule et ne sont définies par EF qu’après l’exécution d’une opération.</span><span class="sxs-lookup"><span data-stu-id="abb30-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="abb30-237">Ces propriétés ne peuvent pas être définies par des intercepteurs.</span><span class="sxs-lookup"><span data-stu-id="abb30-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="abb30-238">Cela signifie qu’un intercepteur peut faire la distinction entre une exception ou un résultat qui a été défini par un autre intercepteur, par opposition à l’exception réelle ou au résultat qui s’est produit lors de l’exécution de l’opération.</span><span class="sxs-lookup"><span data-stu-id="abb30-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="abb30-239">Inscription des intercepteurs</span><span class="sxs-lookup"><span data-stu-id="abb30-239">Registering interceptors</span></span>  

<span data-ttu-id="abb30-240">Une fois qu’une classe qui implémente une ou plusieurs interfaces d’interception a été créée, elle peut être inscrite auprès d’EF à l’aide de la classe DbInterception.</span><span class="sxs-lookup"><span data-stu-id="abb30-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="abb30-241">Exemple :</span><span class="sxs-lookup"><span data-stu-id="abb30-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="abb30-242">Les intercepteurs peuvent également être inscrits au niveau du domaine d’application à l’aide du mécanisme de configuration basé sur le code DbConfiguration.</span><span class="sxs-lookup"><span data-stu-id="abb30-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="abb30-243">Exemple : journalisation dans NLog</span><span class="sxs-lookup"><span data-stu-id="abb30-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="abb30-244">Nous allons rassembler tout cela dans un exemple qui utilise IDbCommandInterceptor et [nlog](https://nlog-project.org/) pour :</span><span class="sxs-lookup"><span data-stu-id="abb30-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](https://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="abb30-245">Consigne un avertissement pour toute commande exécutée de façon non asynchrone</span><span class="sxs-lookup"><span data-stu-id="abb30-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="abb30-246">Consigner une erreur pour toute commande qui lève une exception quand elle est exécutée</span><span class="sxs-lookup"><span data-stu-id="abb30-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="abb30-247">Voici la classe qui effectue la journalisation, qui doit être enregistrée comme indiqué ci-dessus :</span><span class="sxs-lookup"><span data-stu-id="abb30-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="abb30-248">Notez que ce code utilise le contexte d’interception pour découvrir quand une commande est exécutée de façon non asynchrone et pour découvrir quand une erreur s’est produite lors de l’exécution d’une commande.</span><span class="sxs-lookup"><span data-stu-id="abb30-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
